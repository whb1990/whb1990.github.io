<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java多线程-10之-线程优先级和守护线程]]></title>
    <url>%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-10%E4%B9%8B-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B.html</url>
    <content type="text"><![CDATA[线程优先级java 中的线程优先级的范围是1～10，默认的优先级是5。“高优先级线程”会优先于“低优先级线程”执行。 java 中有两种线程：用户线程和守护线程。可以通过isDaemon()方法来区别它们：如果返回false，则说明该线程是“用户线程”；否则就是“守护线程”。用户线程一般用户执行用户级任务，而守护线程也就是“后台线程”，一般用来执行后台任务。需要注意的是：Java虚拟机在“用户线程”都结束后会后退出。 JDK 中关于线程优先级和守护线程的介绍如下： 1234567Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs:The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place.All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method. Marks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads. 大致意思是： 1234567每个线程都有一个优先级。“高优先级线程”会优先于“低优先级线程”执行。每个线程都可以被标记为一个守护进程或非守护进程。在一些运行的主线程中创建新的子线程时，子线程的优先级被设置为等于“创建它的主线程的优先级”，当且仅当“创建它的主线程是守护线程”时“子线程才会是守护线程”。当Java虚拟机启动时，通常有一个单一的非守护线程（该线程通过是通过main()方法启动）。JVM会一直运行直到下面的任意一个条件发生，JVM就会终止运行：(01) 调用了exit()方法，并且exit()有权限被正常执行。(02) 所有的“非守护线程”都死了(即JVM中仅仅只有“守护线程”)。每一个线程都被标记为“守护线程”或“用户线程”。当只有守护线程运行时，JVM会自动退出。 线程优先级的示例12345678910111213141516171819202122232425262728293031323334353637383940package main.java.com.study.thread.priority;/** * @author: whb * @description: 线程优先级测试 */public class PriorityDemo &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName() + "(" + Thread.currentThread().getPriority() + ")"); // 新建线程t1 Thread t1 = new MyThread("t1"); // 新建线程t2 Thread t2 = new MyThread("t2"); // 设置t1的优先级为1 t1.setPriority(1); // 设置t2的优先级为10 t2.setPriority(10); // 启动t1 t1.start(); // 启动t2 t2.start(); &#125;&#125;class MyThread extends Thread &#123; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + "(" + Thread.currentThread().getPriority() + ")" + ", loop " + i); &#125; &#125;&#125;; 运行结果： 1234567891011main(5)t1(1), loop 0t2(10), loop 0t1(1), loop 1t1(1), loop 2t1(1), loop 3t2(10), loop 1t1(1), loop 4t2(10), loop 2t2(10), loop 3t2(10), loop 4 结果说明： 主线程main的优先级是5。 t1的优先级被设为1，而t2的优先级被设为10。cpu在执行t1和t2的时候，根据时间片轮循调度，所以能够并发执行。 守护线程的示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package main.java.com.study.thread.priority;/** * @author: whb * @description: 守护线程示例 */public class DaemonDemo &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName() + "(isDaemon=" + Thread.currentThread().isDaemon() + ")"); // 新建线程t1 Thread t1 = new MyThread2("t1"); // 新建线程t2 Thread t2 = new MyDaemon("t2"); // 设置t2为守护线程 t2.setDaemon(true); // 启动t1 t1.start(); // 启动t2 t2.start(); &#125;&#125;class MyThread2 extends Thread &#123; public MyThread2(String name) &#123; super(name); &#125; @Override public void run() &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(3); System.out.println(this.getName() + "(isDaemon=" + this.isDaemon() + ")" + ", loop " + i); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125;;class MyDaemon extends Thread &#123; public MyDaemon(String name) &#123; super(name); &#125; @Override public void run() &#123; try &#123; for (int i = 0; i &lt; 10000; i++) &#123; Thread.sleep(1); System.out.println(this.getName() + "(isDaemon=" + this.isDaemon() + ")" + ", loop " + i); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125;&#125; 运行结果： 12345678910111213141516main(isDaemon=false)t2(isDaemon=true), loop 0t2(isDaemon=true), loop 1t1(isDaemon=false), loop 0t2(isDaemon=true), loop 2t1(isDaemon=false), loop 1t2(isDaemon=true), loop 3t2(isDaemon=true), loop 4t1(isDaemon=false), loop 2t2(isDaemon=true), loop 5t2(isDaemon=true), loop 6t2(isDaemon=true), loop 7t1(isDaemon=false), loop 3t2(isDaemon=true), loop 8t2(isDaemon=true), loop 9t1(isDaemon=false), loop 4 结果说明： 主线程main是用户线程，它创建的子线程t1也是用户线程。 t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-09之-线程中断和终止方式]]></title>
    <url>%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-09%E4%B9%8B-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E5%92%8C%E7%BB%88%E6%AD%A2%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[interrupt()说明关于interrupt()，java的djk文档描述如下：http://docs.oracle.com/javase/7/docs/api/ Interrupts this thread.Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown. If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException. If this thread is blocked in an I/O operation upon an interruptible channel then the channel will be closed, the thread’s interrupt status will be set, and the thread will receive a ClosedByInterruptException. If this thread is blocked in a Selector then the thread’s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector’s wakeup method were invoked. If none of the previous conditions hold then this thread’s interrupt status will be set. Interrupting a thread that is not alive need not have any effect. 大致意思是： interrupt()的作用是中断本线程。本线程中断自己是被允许的；其它线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。如果本线程是处于阻塞状态：调用线程的wait(), wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的“中断状态”会被清除并且会收到一个InterruptedException异常。例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。中断一个“已终止的线程”不会产生任何操作。 终止线程的方式终止处于“阻塞状态”的线程通常，我们通过“中断”方式终止处于“阻塞状态”的线程。当线程由于被调用了sleep(), wait(), join()等方法而进入阻塞状态；若此时调用线程的interrupt()将线程的中断标记设为true。由于处于阻塞状态，中断标记会被清除，同时产生一个InterruptedException异常。将InterruptedException放在适当的为止就能终止线程，形式如下： 12345678910@Overridepublic void run() &#123; try &#123; while (true) &#123; // 执行任务... &#125; &#125; catch (InterruptedException ie) &#123; // 由于产生InterruptedException异常，退出while(true)循环，线程终止！ &#125;&#125; 说明： 在while(true)中不断的执行任务，当线程处于阻塞状态时，调用线程的interrupt()产生InterruptedException中断。中断的捕获在while(true)之外，这样就退出了while(true)循环！ 注意： 对InterruptedException的捕获务一般放在while(true)循环体的外面，这样，在产生异常时就退出了while(true)循环。否则，InterruptedException在while(true)循环体之内，就需要额外的添加退出处理。 形式如下： 123456789101112@Overridepublic void run() &#123; while (true) &#123; try &#123; // 执行任务... &#125; catch (InterruptedException ie) &#123; // InterruptedException在while(true)循环体内。 // 当线程产生了InterruptedException异常时，while(true)仍能继续运行！需要手动退出 break; &#125; &#125;&#125; 说明： 上面的InterruptedException异常的捕获在whle(true)之内。当产生InterruptedException异常时，被catch处理之外，仍然在while(true)循环体内；要退出while(true)循环体，需要额外的执行退出while(true)的操作。 终止处于“运行状态”的线程通常，我们通过“标记”方式终止处于“运行状态”的线程。其中，包括“中断标记”和“额外添加标记”。 通过“中断标记”终止线程形式如下： 123456@Overridepublic void run() &#123; while (!isInterrupted()) &#123; // 执行任务... &#125;&#125; 说明： isInterrupted()是判断线程的中断标记是不是为true。当线程处于运行状态，并且我们需要终止它时；可以调用线程的interrupt()方法，使用线程的中断标记为true，即isInterrupted()会返回true。此时，就会退出while循环。 注意：interrupt()并不会终止处于“运行状态”的线程！它会将线程的中断标记设为true。 通过“额外添加标记”形式如下： 1234567891011private volatile boolean flag= true;protected void stopTask() &#123; flag = false;&#125;@Overridepublic void run() &#123; while (flag) &#123; // 执行任务... &#125;&#125; 说明： 线程中有一个flag标记，它的默认值是true；并且我们提供stopTask()来设置flag标记。当我们需要终止该线程时，调用该线程的stopTask()方法就可以让线程退出while循环。 注意：将flag定义为volatile类型，是为了保证flag的可见性。即其它线程通过stopTask()修改了flag之后，本线程能看到修改后的flag的值。 综合线程处于“阻塞状态”和“运行状态”的终止方式，比较 通用的终止线程的形式 如下： 1234567891011@Overridepublic void run() &#123; try &#123; // 1. isInterrupted()保证，只要中断标记为true就终止线程。 while (!isInterrupted()) &#123; // 执行任务... &#125; &#125; catch (InterruptedException ie) &#123; // 2. InterruptedException异常保证，当InterruptedException异常产生时，线程被终止。 &#125;&#125; 终止线程的示例首先定义线程对象MyThread 1234567891011121314151617181920212223242526package main.java.com.study.thread.interrupt;/** * @author: whb * @description: 线程对象 */public class MyThread extends Thread &#123; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; int i = 0; while (!isInterrupted()) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException ie) &#123; System.out.println(Thread.currentThread().getName() + " (" + this.getState() + ") catch InterruptedException."); &#125; i++; System.out.println(Thread.currentThread().getName() + " (" + this.getState() + ") loop " + i); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930package main.java.com.study.thread.interrupt;/** * @author: whb * @description: 线程终止示例1 */public class Demo1 &#123; public static void main(String[] args) &#123; try &#123; // 新建“线程t1” Thread t1 = new MyThread("t1"); System.out.println(t1.getName() + " (" + t1.getState() + ") is new."); t1.start(); // 启动“线程t1” System.out.println(t1.getName() + " (" + t1.getState() + ") is started."); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.interrupt(); System.out.println(t1.getName() + " (" + t1.getState() + ") is interrupted."); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() + " (" + t1.getState() + ") is interrupted now."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 1234567t1 (NEW) is new.t1 (RUNNABLE) is started.t1 (RUNNABLE) loop 1t1 (RUNNABLE) loop 2t1 (TIMED_WAITING) is interrupted.t1 (RUNNABLE) catch InterruptedException.t1 (TERMINATED) is interrupted now. 结果说明： 主线程main中通过new MyThread(“t1”)创建线程t1，之后通过t1.start()启动线程t1。 t1启动之后，会不断的检查它的中断标记，如果中断标记为“false”；则休眠100ms。 t1休眠之后，会切换到主线程main；主线程再次运行时，会执行t1.interrupt()中断线程t1。t1收到中断指令之后，会将t1的中断标记设置“false”，而且会抛出InterruptedException异常。在t1的run()方法中，是在循环体while之外捕获的异常；因此循环被终止。 对上面的代码进行小小的修改，将run()方法中捕获InterruptedException异常的代码块移到while循环体内。 12345678910111213141516171819202122232425262728293031package main.java.com.study.thread.interrupt;/** * @author: whb * @description: 线程终止示例2 */public class Demo2 &#123; public static void main(String[] args) &#123; try &#123; // 新建“线程t1” Thread t1 = new MyThread("t1"); System.out.println(t1.getName() + " (" + t1.getState() + ") is new."); // 启动“线程t1” t1.start(); System.out.println(t1.getName() + " (" + t1.getState() + ") is started."); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.interrupt(); System.out.println(t1.getName() + " (" + t1.getState() + ") is interrupted."); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() + " (" + t1.getState() + ") is interrupted now."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 123456789101112131415t1 (NEW) is new.t1 (RUNNABLE) is started.t1 (RUNNABLE) loop 1t1 (RUNNABLE) loop 2t1 (TIMED_WAITING) is interrupted.t1 (RUNNABLE) catch InterruptedException.t1 (RUNNABLE) loop 3t1 (RUNNABLE) loop 4t1 (RUNNABLE) loop 5t1 (TIMED_WAITING) is interrupted now.t1 (RUNNABLE) loop 6t1 (RUNNABLE) loop 7t1 (RUNNABLE) loop 8t1 (RUNNABLE) loop 9... 结果说明： 程序进入了死循环！ 为什么会这样呢？这是因为，t1在“等待(阻塞)状态”时，被interrupt()中断；此时，会清除中断标记「即isInterrupted()会返回false」，而且会抛出InterruptedException异常「该异常在while循环体内被捕获」。因此，t1理所当然的会进入死循环了。 解决该问题，需要在捕获异常时，额外的进行退出while循环的处理。例如，在MyThread的catch(InterruptedException)中添加break 或 return就能解决该问题。 下面是通过“额外添加标记”的方式终止“状态状态”的线程的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package main.java.com.study.thread.interrupt;/** * @author: whb * @description: 线程终止示例3 */public class Demo3 &#123; public static void main(String[] args) &#123; try &#123; // 新建“线程t1” TestThread t1 = new TestThread("t1"); System.out.println(t1.getName() + " (" + t1.getState() + ") is new."); t1.start(); // 启动“线程t1” System.out.println(t1.getName() + " (" + t1.getState() + ") is started."); // 主线程休眠300ms，然后主线程给t1发“中断”指令。 Thread.sleep(300); t1.stopTask(); System.out.println(t1.getName() + " (" + t1.getState() + ") is interrupted."); // 主线程休眠300ms，然后查看t1的状态。 Thread.sleep(300); System.out.println(t1.getName() + " (" + t1.getState() + ") is interrupted now."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class TestThread extends Thread &#123; private volatile boolean flag = true; public void stopTask() &#123; flag = false; &#125; public TestThread(String name) &#123; super(name); &#125; @Override public void run() &#123; synchronized (this) &#123; try &#123; int i = 0; while (flag) &#123; Thread.sleep(100); i++; System.out.println(Thread.currentThread().getName() + " (" + this.getState() + ") loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; System.out.println(Thread.currentThread().getName() + " (" + this.getState() + ") catch InterruptedException."); &#125; &#125; &#125;&#125; 运行结果： 1234567t1 (NEW) is new.t1 (RUNNABLE) is started.t1 (RUNNABLE) loop 1t1 (RUNNABLE) loop 2t1 (TIMED_WAITING) is interrupted.t1 (RUNNABLE) loop 3t1 (TERMINATED) is interrupted now. interrupted() 和 isInterrupted()的区别interrupted() 和 isInterrupted()都能够用于检测对象的“中断标记”。区别是，interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)；而isInterrupted()仅仅返回中断标记。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-08之-线程Join]]></title>
    <url>%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-08%E4%B9%8B-%E7%BA%BF%E7%A8%8BJoin.html</url>
    <content type="text"><![CDATA[join()介绍join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。通过例子来理解： 123456789101112131415// 主线程public class Father extends Thread &#123; public void run() &#123; Son s = new Son(); s.start(); s.join(); ... &#125;&#125;// 子线程public class Son extends Thread &#123; public void run() &#123; ... &#125;&#125; 说明： 上面的有两个类Father(主线程类)和Son(子线程类)。因为Son是在Father中创建并启动的，所以，Father是主线程类，Son是子线程类。在Father主线程中，通过new Son()新建“子线程s”。接着通过s.start()启动“子线程s”，并且调用s.join()。在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！ join()源码分析12345678910111213141516171819202122232425262728public final void join() throws InterruptedException &#123; join(0);&#125;public final synchronized void join(long millis)throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125; 说明： 从代码中，可以发现。当millis==0时，会进入while(isAlive())循环；即只要子线程是活的，主线程就不停的等待。根据上面解释join()作用时的代码来理解join()的用法！ 问题： 虽然s.join()被调用的地方是发生在“Father主线程”中，但是s.join()是通过“子线程s”去调用的join()。那么，join()方法中的isAlive()应该是判断“子线程s”是不是Alive状态；对应的wait(0)也应该是“让子线程s”等待才对。但如果是这样的话，s.join()的作用怎么可能是“让主线程等待，直到子线程s完成为止”呢，应该是让"子线程等待才对(因为调用子线程对象s的wait方法嘛)"？ 答案： wait()的作用是让“当前线程”等待，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！ join()示例12345678910111213141516171819202122232425262728293031323334353637383940package main.java.com.study.thread.join;/** * @author: whb * @description: join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。 */public class JoinTest &#123; public static void main(String[] args) &#123; try &#123; // 新建“线程t1” ThreadA t1 = new ThreadA("t1"); t1.start(); // 启动“线程t1” t1.join(); // 将“线程t1”加入到“主线程main”中，并且“主线程main()会等待它的完成” System.out.printf("%s finish\n", Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; static class ThreadA extends Thread &#123; public ThreadA(String name) &#123; super(name); &#125; @Override public void run() &#123; System.out.printf("%s start\n", this.getName()); // 延时操作 for (int i = 0; i &lt; 1000000; i++) &#123; ; &#125; System.out.printf("%s finish\n", this.getName()); &#125; &#125;&#125; 运行结果： 123t1 startt1 finishmain finish 运行结果：(01) 在“主线程main”中通过 new ThreadA(“t1”) 新建“线程t1”。 接着，通过 t1.start() 启动“线程t1”，并执行t1.join()。(02) 执行t1.join()之后，“主线程main”会进入“阻塞状态”等待t1运行结束。“子线程t1”结束之后，会唤醒“主线程main”，“主线程”重新获取cpu执行权，继续运行。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-07之-线程休眠]]></title>
    <url>%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-07%E4%B9%8B-%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0.html</url>
    <content type="text"><![CDATA[sleep()介绍sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。 sleep()示例123456789101112131415161718192021222324252627282930313233package main.java.com.study.thread.sleep;/** * @author: whb * @description: 线程休眠测试 */public class SleepTest &#123; public static void main(String[] args) &#123; ThreadA t1 = new ThreadA("t1"); t1.start(); &#125;&#125;class ThreadA extends Thread &#123; public ThreadA(String name) &#123; super(name); &#125; @Override public synchronized void run() &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.printf("%s: %d\n", this.getName(), i); // i能被4整除时，休眠100毫秒 if (i % 4 == 0) &#123; Thread.sleep(100); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 12345678910t1: 0t1: 1t1: 2t1: 3t1: 4t1: 5t1: 6t1: 7t1: 8t1: 9 结果说明： 程序比较简单，在主线程main中启动线程t1。t1启动之后，当t1中的计算i能被4整除时，t1会通过Thread.sleep(100)休眠100毫秒。 sleep() 与 wait()的比较wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。 下面通过示例演示sleep()是不会释放锁的。 123456789101112131415161718192021222324252627282930313233343536373839404142package main.java.com.study.thread.sleep;/** * @author: whb * @description: wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。 * 但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。 */public class SleepLockTest &#123; private static Object obj = new Object(); public static void main(String[] args) &#123; ThreadA t1 = new ThreadA("t1"); ThreadA t2 = new ThreadA("t2"); t1.start(); t2.start(); &#125; static class ThreadA extends Thread &#123; public ThreadA(String name) &#123; super(name); &#125; @Override public void run() &#123; // 获取obj对象的同步锁 synchronized (obj) &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.printf("%s: %d\n", this.getName(), i); // i能被4整除时，休眠100毫秒 if (i % 4 == 0) &#123; Thread.sleep(100); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 运行结果： 1234567891011121314151617181920t1: 0t1: 1t1: 2t1: 3t1: 4t1: 5t1: 6t1: 7t1: 8t1: 9t2: 0t2: 1t2: 2t2: 3t2: 4t2: 5t2: 6t2: 7t2: 8t2: 9 结果说明： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.sleep(100)；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-06之-线程让步]]></title>
    <url>%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-06%E4%B9%8B-%E7%BA%BF%E7%A8%8B%E8%AE%A9%E6%AD%A5.html</url>
    <content type="text"><![CDATA[yield()介绍 yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！ yield()示例12345678910111213141516171819202122232425262728293031package main.java.com.study.thread.yield;/** * @author: whb * @description: yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权；但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权；也有可能是当前线程又进入到“运行状态”继续运行！ */public class YieldTest &#123; public static void main(String[] args) &#123; ThreadA t1 = new ThreadA("t1"); ThreadA t2 = new ThreadA("t2"); t1.start(); t2.start(); &#125;&#125;class ThreadA extends Thread &#123; public ThreadA(String name) &#123; super(name); &#125; @Override public synchronized void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.printf("%s [%d]:%d\n", this.getName(), this.getPriority(), i); // i整除4时，调用yield if (i % 4 == 0) &#123; Thread.yield(); &#125; &#125; &#125;&#125; (某一次的)运行结果: 1234567891011121314151617181920t1 [5]:0t2 [5]:0t1 [5]:1t1 [5]:2t1 [5]:3t1 [5]:4t1 [5]:5t1 [5]:6t1 [5]:7t1 [5]:8t1 [5]:9t2 [5]:1t2 [5]:2t2 [5]:3t2 [5]:4t2 [5]:5t2 [5]:6t2 [5]:7t2 [5]:8t2 [5]:9 结果说明： “线程t1”在能被4整数的时候，并没有切换到“线程t2”。这表明，yield()虽然可以让线程由“运行状态”进入到“就绪状态”；但是，它不一定会让其它线程获取CPU执行权(即，其它线程进入到“运行状态”)，即使这个“其它线程”与当前调用yield()的线程具有相同的优先级。 yield() 与 wait()的比较 wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是：(01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。(02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。 下面通过示例演示yield()是不会释放锁的。 123456789101112131415161718192021222324252627282930313233343536373839package main.java.com.study.thread.yield;/** * @author: whb * @description: wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是： * (01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。 * (02) wait()是会线程释放它所持有对象的同步锁，而yield()方法不会释放锁。 */public class YieldLockTest &#123; private static Object obj = new Object(); public static void main(String[] args) &#123; ThreadA t1 = new ThreadA("t1"); ThreadA t2 = new ThreadA("t2"); t1.start(); t2.start(); &#125; static class ThreadA extends Thread &#123; public ThreadA(String name) &#123; super(name); &#125; @Override public void run() &#123; // 获取obj对象的同步锁 synchronized (obj) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.printf("%s [%d]:%d\n", this.getName(), this.getPriority(), i); // i整除4时，调用yield if (i % 4 == 0) &#123; Thread.yield(); &#125; &#125; &#125; &#125; &#125;&#125; (某一次)运行结果： 1234567891011121314151617181920t1 [5]:0t1 [5]:1t1 [5]:2t1 [5]:3t1 [5]:4t1 [5]:5t1 [5]:6t1 [5]:7t1 [5]:8t1 [5]:9t2 [5]:0t2 [5]:1t2 [5]:2t2 [5]:3t2 [5]:4t2 [5]:5t2 [5]:6t2 [5]:7t2 [5]:8t2 [5]:9 结果说明： 主线程main中启动了两个线程t1和t2。t1和t2在run()会引用同一个对象的同步锁，即synchronized(obj)。在t1运行过程中，虽然它会调用Thread.yield()；但是，t2是不会获取cpu执行权的。因为，t1并没有释放“obj所持有的同步锁”！]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-05之-线程等待与唤醒]]></title>
    <url>%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-05%E4%B9%8B-%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92.html</url>
    <content type="text"><![CDATA[wait(), notify(), notifyAll()等方法介绍在Object.java中，定义了wait(), notify()和notifyAll()等接口。wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。而notify()和notifyAll()的作用，则是唤醒当前对象上的等待线程；notify()是唤醒单个线程，而notifyAll()是唤醒所有的线程。 Object类中关于等待/唤醒的API详细信息如下：notify() – 唤醒在此对象监视器上等待的单个线程。notifyAll() – 唤醒在此对象监视器上等待的所有线程。wait() – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)。wait(long timeout) – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。wait(long timeout, int nanos) – 让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量”，当前线程被唤醒(进入“就绪状态”)。 wait()和notify()示例123456789101112131415161718192021222324252627282930313233343536373839404142434445package main.java.com.study.thread.waitNotify;/** * @author: whb * @description: wait()和notify()使用示例 */public class WaitTest &#123; public static void main(String[] args) &#123; ThreadA t1 = new ThreadA("t1"); synchronized (t1) &#123; try &#123; // 启动“线程t1” System.out.println(Thread.currentThread().getName() + " start t1"); t1.start(); // 主线程等待t1通过notify()唤醒。 System.out.println(Thread.currentThread().getName() + " wait()"); t1.wait(); System.out.println(Thread.currentThread().getName() + " continue"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class ThreadA extends Thread &#123; public ThreadA(String name) &#123; super(name); &#125; @Override public void run() &#123; synchronized (this) &#123; System.out.println(Thread.currentThread().getName() + " call notify()"); // 唤醒当前的wait线程 notify(); &#125; &#125;&#125; 运行结果: 1234main start t1main wait()t1 call notify()main continue 结果说明： 如下图，说明了“主线程”和“线程t1”的流程。 (01) 注意，图中”主线程” 代表“主线程main”。”线程t1” 代表WaitTest中启动的“线程t1”。 而“锁” 代表“t1这个对象的同步锁”。(02) “主线程”通过 new ThreadA(“t1”) 新建“线程t1”。随后通过synchronized(t1)获取“t1对象的同步锁”。然后调用t1.start()启动“线程t1”。(03) “主线程”执行t1.wait() 释放“t1对象的锁”并且进入“等待(阻塞)状态”。等待t1对象上的线程通过notify() 或 notifyAll()将其唤醒。(04) “线程t1”运行之后，通过synchronized(this)获取“当前对象的锁”；接着调用notify()唤醒“当前对象上的等待线程”，也就是唤醒“主线程”。(05) “线程t1”运行完毕之后，释放“当前对象的锁”。紧接着，“主线程”获取“t1对象的锁”，然后接着运行。 对于上面的代码：t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？ 在解答该问题前，先看看jdk文档中关于wait的一段介绍： Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. In other words, this method behaves exactly as if it simply performs the call wait(0). The current thread must own this object's monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object's monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution. 中文意思大概是： 引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。 “当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。 注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！ 这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！ wait(long timeout)和notify()wait(long timeout)会让当前线程处于“等待(阻塞)状态”，“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量”，当前线程被唤醒(进入“就绪状态”)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package main.java.com.study.thread.waitNotify;/** * @author: whb * @description: wait(long timeout)和notify()的使用示例 */public class WaitTimeoutTest &#123; public static void main(String[] args) &#123; ThreadB t1 = new ThreadB("t1"); synchronized (t1) &#123; try &#123; // 启动“线程t1” System.out.println(Thread.currentThread().getName() + " start t1"); t1.start(); // 主线程等待t1通过notify()唤醒 或 notifyAll()唤醒，或超过3000ms延时；然后才被唤醒。 System.out.println(Thread.currentThread().getName() + " call wait "); t1.wait(3000); System.out.println(Thread.currentThread().getName() + " continue"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class ThreadB extends Thread &#123; public ThreadB(String name) &#123; super(name); &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + " run "); // 死循环，不断运行。 while (true) &#123; ; &#125; &#125;&#125; 运行结果： 1234main start t1main call wait t1 run // 大约3秒之后...输出“main continue”main continue 结果说明： 如下图，说明了“主线程”和“线程t1”的流程。(01) 注意，图中”主线程” 代表WaitTimeoutTest主线程(即，线程main)。”线程t1” 代表WaitTest中启动的线程t1。 而“锁” 代表“t1这个对象的同步锁”。(02) 主线程main执行t1.start()启动“线程t1”。(03) 主线程main执行t1.wait(3000)，此时，主线程进入“阻塞状态”。需要“用于t1对象锁的线程通过notify() 或者 notifyAll()将其唤醒” 或者 “超时3000ms之后”，主线程main才进入到“就绪状态”，然后才可以运行。(04) “线程t1”运行之后，进入了死循环，一直不断的运行。(05) 超时3000ms之后，主线程main会进入到“就绪状态”，然后接着进入“运行状态”。 wait() 和 notifyAll()通过前面的示例，我们知道 notify() 可以唤醒在此对象监视器上等待的单个线程。下面，通过示例演示notifyAll()的用法；它的作用是唤醒在此对象监视器上等待的所有线程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package main.java.com.study.thread.waitNotify;/** * @author: whb * @description: wait() 和 notifyAll()使用示例 */public class NotifyAllTest &#123; private static Object obj = new Object(); public static void main(String[] args) &#123; ThreadA t1 = new ThreadA("t1"); ThreadA t2 = new ThreadA("t2"); ThreadA t3 = new ThreadA("t3"); t1.start(); t2.start(); t3.start(); try &#123; System.out.println(Thread.currentThread().getName() + " sleep(3000)"); Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (obj) &#123; // 主线程等待唤醒。 System.out.println(Thread.currentThread().getName() + " notifyAll()"); obj.notifyAll(); &#125; &#125; static class ThreadA extends Thread &#123; public ThreadA(String name) &#123; super(name); &#125; @Override public void run() &#123; synchronized (obj) &#123; try &#123; // 打印输出结果 System.out.println(Thread.currentThread().getName() + " wait"); // 唤醒当前的wait线程 obj.wait(); // 打印输出结果 System.out.println(Thread.currentThread().getName() + " continue"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 运行结果： 12345678t1 waitmain sleep(3000)t3 waitt2 waitmain notifyAll()t2 continuet3 continuet1 continue 结果说明： (01) 主线程中新建并且启动了3个线程”t1”, “t2”和”t3”。(02) 主线程通过sleep(3000)休眠3秒。在主线程休眠3秒的过程中，我们假设”t1”, “t2”和”t3”这3个线程都运行了。以”t1”为例，当它运行的时候，它会执行obj.wait()等待其它线程通过notify()或额nofityAll()来唤醒它；相同的道理，”t2”和”t3”也会等待其它线程通过nofity()或nofityAll()来唤醒它们。(03) 主线程休眠3秒之后，接着运行。执行 obj.notifyAll() 唤醒obj上的等待线程，即唤醒”t1”, “t2”和”t3”这3个线程。 紧接着，主线程的synchronized(obj)运行完毕之后，主线程释放“obj锁”。这样，”t1”, “t2”和”t3”就可以获取“obj锁”而继续运行了！ 为什么notify(), wait()等函数定义在Object中，而不是Thread中Object中的wait(), notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。 wait()会使“当前线程”等待，因为线程进入等待状态，所以线程应该释放它锁持有的“同步锁”，否则其它线程获取不到该“同步锁”而无法运行！线程调用wait()之后，会释放它锁持有的“同步锁”；而且，等待线程可以被notify()或notifyAll()唤醒。那么问题来了：notify()是依据什么唤醒等待线程的？或者说，wait()等待线程和notify()之间是通过什么关联起来的？答案是：依据“对象的同步锁”。 负责唤醒等待线程的那个线程(称为“唤醒线程”)，它只有在获取“该对象的同步锁”(这里的同步锁必须和等待线程的同步锁是同一个)，并且调用notify()或notifyAll()方法之后，才能唤醒等待线程。虽然，等待线程被唤醒；但是，它不能立刻执行，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。 总之，notify(), wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(), wait()等函数定义在Object类，而不是Thread类中的原因。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-04之-synchronized关键字]]></title>
    <url>%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-04%E4%B9%8B-synchronized%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content type="text"><![CDATA[synchronized原理在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了“obj这个对象”的同步锁。不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。例如，现在有两个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。 synchronized基本规则 1. 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 2. 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。 3. 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 第一条规则当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 12345678910111213141516171819202122232425262728293031323334package main.java.com.study.thread.synchronizedDemo;/** * @author: whb * @description: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 */public class Demo1_1 &#123; public static void main(String[] args) &#123; // 新建“Runnable对象” Runnable demo = new MyRunable(); // 新建“线程t1”, t1是基于demo这个Runnable对象 Thread t1 = new Thread(demo, "t1"); // 新建“线程t2”, t2是基于demo这个Runnable对象 Thread t2 = new Thread(demo, "t2"); t1.start(); // 启动“线程t1” t2.start(); // 启动“线程t2” &#125;&#125;class MyRunable implements Runnable &#123; @Override public void run() &#123; synchronized (this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; // 休眠100ms Thread.sleep(100); System.out.println(Thread.currentThread().getName() + " loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125;&#125; 运行结果： 12345678910t1 loop 0t1 loop 1t1 loop 2t1 loop 3t1 loop 4t2 loop 0t2 loop 1t2 loop 2t2 loop 3t2 loop 4 结果说明： run()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于”demo这个Runnable对象”创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“demo这个Runnable对象”；因此，线程t1和t2共享“demo对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“demo的同步锁”之后才能运行。 接下来将上面的代码进行修改，然后再运行看看结果怎么样。修改后的源码如下： 12345678910111213141516171819202122232425262728293031323334353637package main.java.com.study.thread.synchronizedDemo;/** * @author: whb * @description: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 */public class Demo1_2 &#123; public static void main(String[] args) &#123; // 新建“线程t1” Thread t1 = new MyThread("t1"); // 新建“线程t2” Thread t2 = new MyThread("t2"); t1.start(); // 启动“线程t1” t2.start(); // 启动“线程t2” &#125;&#125;class MyThread extends Thread &#123; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; synchronized (this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; // 休眠100ms Thread.sleep(100); System.out.println(Thread.currentThread().getName() + " loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125;&#125; 代码说明： 比较Demo1_2 和 Demo1_1后发现，Demo1_2中的MyThread类是直接继承于Thread，而且t1和t2都是MyThread子线程。在“Demo1_2的run()方法”也调用了synchronized(this)，正如“Demo1_1的run()方法”也调用了synchronized(this)一样！那么，Demo1_2的执行流程是不是和Demo1_1一样呢？ 运行结果： 12345678910t1 loop 0t2 loop 0t1 loop 1t2 loop 1t1 loop 2t2 loop 2t1 loop 3t2 loop 3t1 loop 4t2 loop 4 结果说明： synchronized(this)中的this是指“当前的类对象”，即synchronized(this)所在的类对应的当前对象。它的作用是获取“当前对象的同步锁”。对于Demo1_2中，synchronized(this)中的this代表的是MyThread对象，而t1和t2是两个不同的MyThread对象，因此t1和t2在执行synchronized(this)时，获取的是不同对象的同步锁。对于Demo1_1对而言，synchronized(this)中的this代表的是MyRunable对象；t1和t2共同一个MyRunable对象，因此，一个线程获取了对象的同步锁，会造成另外一个线程等待。 第二条规则当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package main.java.com.study.thread.synchronizedDemo;/** * @author: whb * @description: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。 */public class Demo2 &#123; public static void main(String[] args) &#123; final Count count = new Count(); // 新建t1, t1会调用“count对象”的synMethod()方法 Thread t1 = new Thread( new Runnable() &#123; @Override public void run() &#123; count.synMethod(); &#125; &#125;, "t1"); // 新建t2, t2会调用“count对象”的nonSynMethod()方法 Thread t2 = new Thread( new Runnable() &#123; @Override public void run() &#123; count.nonSynMethod(); &#125; &#125;, "t2"); t1.start(); // 启动t1 t2.start(); // 启动t2 &#125;&#125;class Count &#123; /** * 含有synchronized同步块的方法 */ public void synMethod() &#123; synchronized (this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; // 休眠100ms Thread.sleep(100); System.out.println(Thread.currentThread().getName() + " synMethod loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125; /** * 非同步的方法 */ public void nonSynMethod() &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + " nonSynMethod loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125;&#125; 运行结果： 12345678910t1 synMethod loop 0t2 nonSynMethod loop 0t1 synMethod loop 1t2 nonSynMethod loop 1t1 synMethod loop 2t2 nonSynMethod loop 2t1 synMethod loop 3t2 nonSynMethod loop 3t1 synMethod loop 4t2 nonSynMethod loop 4 结果说明： 主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。 第三条规则当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package main.java.com.study.thread.synchronizedDemo;/** * @author: whb * @description: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 */public class Demo3 &#123; public static void main(String[] args) &#123; final Count2 count = new Count2(); // 新建t1, t1会调用“count对象”的synMethod()方法 Thread t1 = new Thread( new Runnable() &#123; @Override public void run() &#123; count.synMethod(); &#125; &#125;, "t1"); // 新建t2, t2会调用“count对象”的nonSynMethod()方法 Thread t2 = new Thread( new Runnable() &#123; @Override public void run() &#123; count.nonSynMethod(); &#125; &#125;, "t2"); t1.start(); // 启动t1 t2.start(); // 启动t2 &#125;&#125;class Count2 &#123; /** * 含有synchronized同步块的方法 */ public void synMethod() &#123; synchronized (this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; // 休眠100ms Thread.sleep(100); System.out.println(Thread.currentThread().getName() + " synMethod loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125; /** * 也包含synchronized同步块的方法 */ public void nonSynMethod() &#123; synchronized (this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + " nonSynMethod loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125;&#125; 运行结果： 12345678910t1 synMethod loop 0t1 synMethod loop 1t1 synMethod loop 2t1 synMethod loop 3t1 synMethod loop 4t2 nonSynMethod loop 0t2 nonSynMethod loop 1t2 nonSynMethod loop 2t2 nonSynMethod loop 3t2 nonSynMethod loop 4 结果说明： 主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。 synchronized方法 和 synchronized代码块“synchronized方法”是用synchronized修饰方法，而 “synchronized代码块”则是用synchronized修饰代码块。 synchronized方法示例: 123public synchronized void foo1() &#123; System.out.println("synchronized methoed");&#125; synchronized代码块示例： 12345public void foo2() &#123; synchronized (this) &#123; System.out.println("synchronized methoed"); &#125;&#125; synchronized代码块中的this是指当前对象。也可以将this替换成其他对象，例如将this替换成obj，则foo2()在执行synchronized(obj)时就获取的是obj的同步锁。 synchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率。下面通过一个示例来演示： 123456789101112131415161718192021222324252627282930313233343536373839404142package main.java.com.study.thread.synchronizedDemo;/** * @author: whb * @description: synchronized代码块可以更精确的控制冲突限制访问区域，有时候表现更高效率。 */public class Demo4 &#123; public synchronized void synMethod() &#123; for (int i = 0; i &lt; 1000000; i++) &#123; ; &#125; &#125; public void synBlock() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 1000000; i++) &#123; ; &#125; &#125; &#125; public static void main(String[] args) &#123; Demo4 demo = new Demo4(); long start, diff; // 获取当前时间(millis) start = System.currentTimeMillis(); // 调用“synchronized方法” demo.synMethod(); // 获取“时间差值” diff = System.currentTimeMillis() - start; System.out.println("synMethod() : " + diff); // 获取当前时间(millis) start = System.currentTimeMillis(); // 调用“synchronized方法块” demo.synBlock(); // 获取“时间差值” diff = System.currentTimeMillis() - start; System.out.println("synBlock() : " + diff); &#125;&#125; (某一次)执行结果： 12synMethod() : 11synBlock() : 3 实例锁 和 全局锁实例锁 – 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。 实例锁对应的就是synchronized关键字。 全局锁 – 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。 关于“实例锁”和“全局锁”有一个很形象的例子： 123456pulbic class Something &#123; public synchronized void isSyncA()&#123;&#125; public synchronized void isSyncB()&#123;&#125; public static synchronized void cSyncA()&#123;&#125; public static synchronized void cSyncB()&#123;&#125;&#125; 假设，Something有两个实例x和y。分析下面4组表达式获取的锁的情况。(01) x.isSyncA()与x.isSyncB()(02) x.isSyncA()与y.isSyncA()(03) x.cSyncA()与y.cSyncB()(04) x.isSyncA()与Something.cSyncA() 下面通过四个示例演示进行分析。首先定义Something对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package main.java.com.study.thread.synchronizedDemo;/** * @author: whb * @description: Something对象 */public class Something &#123; public synchronized void isSyncA() &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + " : isSyncA"); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; public synchronized void isSyncB() &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + " : isSyncB"); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncA() &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + " : cSyncA"); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncB() &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + " : cSyncB"); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125;&#125; (01) 不能被同时访问。因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！ 123456789101112131415161718192021222324252627282930313233package main.java.com.study.thread.synchronizedDemo;/** * @author: whb * @description: 实例锁和全局锁分析示例1 * 不能被同时访问。因为isSyncA()和isSyncB()都是访问同一个对象(对象x)的同步锁！ */public class LockTest1 &#123; Something x = new Something(); Something y = new Something(); /** * 比较(01) x.isSyncA()与x.isSyncB() */ private void test1() &#123; // 新建t11, t11会调用 x.isSyncA() Thread t11 = new Thread( () -&gt; x.isSyncA(), "t11"); // 新建t12, t12会调用 x.isSyncB() Thread t12 = new Thread( () -&gt; x.isSyncB(), "t12"); t11.start(); // 启动t11 t12.start(); // 启动t12 &#125; public static void main(String[] args) &#123; LockTest1 demo = new LockTest1(); demo.test1(); &#125;&#125; 运行结果： 12345678910t11 : isSyncAt11 : isSyncAt11 : isSyncAt11 : isSyncAt11 : isSyncAt12 : isSyncBt12 : isSyncBt12 : isSyncBt12 : isSyncBt12 : isSyncB (02) 可以同时被访问。因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。 1234567891011121314151617181920212223242526272829303132333435package main.java.com.study.thread.synchronizedDemo;/** * @author: whb * @description: 实例锁和全局锁示例2 * 可以同时被访问。因为访问的不是同一个对象的同步锁，x.isSyncA()访问的是x的同步锁，而y.isSyncA()访问的是y的同步锁。 */public class LockTest2 &#123; Something x = new Something(); Something y = new Something(); /** * 比较(02) x.isSyncA()与y.isSyncA() */ private void test2() &#123; // 新建t21, t21会调用 x.isSyncA() Thread t21 = new Thread( () -&gt; x.isSyncA(), "t21"); // 新建t22, t22会调用 x.isSyncB() Thread t22 = new Thread( () -&gt; y.isSyncA(), "t22"); t21.start(); // 启动t21 t22.start(); // 启动t22 &#125; public static void main(String[] args) &#123; LockTest2 demo = new LockTest2(); demo.test2(); &#125;&#125; 运行结果： 12345678910t21 : isSyncAt22 : isSyncAt21 : isSyncAt22 : isSyncAt21 : isSyncAt22 : isSyncAt21 : isSyncAt22 : isSyncAt21 : isSyncAt22 : isSyncA (03) 不能被同时访问。因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。 1234567891011121314151617181920212223242526272829303132333435package main.java.com.study.thread.synchronizedDemo;/** * @author: whb * @description: 实例锁和全局锁示例3 * 不能被同时访问。因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。 */public class LockTest3 &#123; Something x = new Something(); Something y = new Something(); /** * 比较(03) x.cSyncA()与y.cSyncB() */ private void test3() &#123; // 新建t31, t31会调用 x.isSyncA() Thread t31 = new Thread( () -&gt; x.cSyncA(), "t31"); // 新建t32, t32会调用 x.isSyncB() Thread t32 = new Thread( () -&gt; y.cSyncB(), "t32"); t31.start(); // 启动t31 t32.start(); // 启动t32 &#125; public static void main(String[] args) &#123; LockTest3 demo = new LockTest3(); demo.test3(); &#125;&#125; 运行结果： 12345678910t31 : cSyncAt31 : cSyncAt31 : cSyncAt31 : cSyncAt31 : cSyncAt32 : cSyncBt32 : cSyncBt32 : cSyncBt32 : cSyncBt32 : cSyncB (04) 可以被同时访问。因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。 1234567891011121314151617181920212223242526272829303132333435package main.java.com.study.thread.synchronizedDemo;/** * @author: whb * @description: 实例锁和全局锁示例4 * 可以被同时访问。因为isSyncA()是实例方法，x.isSyncA()使用的是对象x的锁；而cSyncA()是静态方法，Something.cSyncA()可以理解对使用的是“类的锁”。因此，它们是可以被同时访问的。 */public class LockTest4 &#123; Something x = new Something(); Something y = new Something(); /** * 比较(04) x.isSyncA()与Something.cSyncA() */ private void test4() &#123; // 新建t41, t41会调用 x.isSyncA() Thread t41 = new Thread( () -&gt; x.isSyncA(), "t41"); // 新建t42, t42会调用 x.isSyncB() Thread t42 = new Thread( () -&gt; Something.cSyncA(), "t42"); t41.start(); // 启动t41 t42.start(); // 启动t42 &#125; public static void main(String[] args) &#123; LockTest4 demo = new LockTest4(); demo.test4(); &#125;&#125; 运行结果： 12345678910t41 : isSyncAt42 : cSyncAt41 : isSyncAt42 : cSyncAt41 : isSyncAt42 : cSyncAt41 : isSyncAt42 : cSyncAt41 : isSyncAt42 : cSyncA]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地代码上传到GitHub]]></title>
    <url>%2F%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0GitHub.html</url>
    <content type="text"><![CDATA[首先你需要一个github账号，所有还没有的话先去注册吧！ https://github.com/ 我们使用git需要先安装git工具，这里给出下载地址，下载后一路直接安装即可： https://git-for-windows.github.io/ 进入Github首页，点击New repository新建一个项目 填写相应信息后点击create即可 Repository name: 仓库名称 Description(可选): 仓库描述介绍 Public, Private : 仓库权限（公开共享，私有或指定合作者） Initialize this repository with a README: 添加一个README.md gitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignore license: 证书类型，对应生成文件LICENSE 点击Clone or dowload会出现一个地址，copy这个地址备用。 接下来就到本地操作了，首先鼠标右键，如果你之前安装git成功的话，右键会出现两个新选项，分别为Git Gui Here,Git Bash Here,这里我们选择Git Bash Here，进入如下界面： 接下来输入如下代码（关键步骤），把github上面的仓库克隆到本地 1git clone https://github.com/whb1990/blogSourceCode.git 地址换成你自己的。 这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你github上面的项目名，如图我多出了个blogSourceCode文件夹，我们把本地需要上传的文件都复制到该文件夹下： 接着继续输入命令 cd blogSourceCode，进入 blogSourceCode 文件夹 接下来依次输入以下代码即可完成其他剩余操作： git add . （注：别忘记后面的.，此操作是把Test文件夹下面的文件都添加进来） 执行完该命令可以看到有如下提示信息： 这个提示的大致意思就是： 1234567您已经在当前存储库中添加了另一个Git存储库。外部存储库的克隆将不包含嵌入存储库的内容，也不知道如何获取它。如果要添加子模块，请使用： git submodule add &lt;url&gt; themes/next如果错误地添加了此路径，则可以使用 git rm --cached themes/next 因为这个项目是我用Hexo搭建的个人博客，用到了Next主题(另一个Git存储库)，上面的提示也告诉了我们该怎么做，其实除了上面两种方式，还有一种方式就是直接删除你要包含的子库目录下的.git文件夹即可。 git commit -m &quot;提交信息&quot; （注：“提交信息”里面换成你需要，如“first commit”） git push -u origin master （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码） 去GitHub上看下上传后的代码 问题解决： 在上传代码到GitHub的时候，提示如下错误： 原因是推送的文件太大。我这次推送的内容超过的1G，所以报错了。 方法一：修改提交缓存大小为5000M，或者更大的数字 1git config --global http.postBuffer 5242880000 –global配置对当前用户生效，如果需要对所有用户生效，则用–system 或者在克隆/创建版本库生成的 .git目录下面修改生成的config文件增加如下： 12[http] postBuffer = 524288000 方法二： 配置git的最低速度和最低速度时间： 12git config --global http.lowSpeedLimit 0git config --global http.lowSpeedTime 999999 单位 秒 –global配置对当前用户生效，如果需要对所有用户生效，则用–system 我是选择的方法一，解决效果如下：]]></content>
      <categories>
        <category>Git</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo live2d插件效果预览]]></title>
    <url>%2FHexo-live2d%E6%8F%92%E4%BB%B6%E6%95%88%E6%9E%9C%E9%A2%84%E8%A7%88.html</url>
    <content type="text"><![CDATA[Epsilon2.1 Gantzert_Felixander haru miku ni-j nico nietzche nipsilon nito shizuku tsumiki wanko z16 hibiki koharu haruto Unitychan tororo hijiki]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-ReentrantReadWriteLock]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91-ReentrantReadWriteLock.html</url>
    <content type="text"><![CDATA[概述ReadWriteLock，顾名思义，是读写锁。它维护了一对相关的锁 — — “读取锁”和“写入锁”，一个用于读取操作，另一个用于写入操作。 “读取锁”用于只读操作，它是“共享锁”，能同时被多个线程获取。 “写入锁”用于写入操作，它是“独占锁”，写入锁只能被一个线程锁获取。注意：不能同时存在读取锁和写入锁！ReadWriteLock是一个接口。ReentrantReadWriteLock是它的实现类，ReentrantReadWriteLock包括子类ReadLock和WriteLock。读写锁底层也是通过AQS框架实现的，通过之前的文章可知，如果使用AQS框架，在这个类内部必定有一个AQS框架的子类，AQS子类无非就是实现如下几点： 第一点：对共享资源state进行操作第二点：如果是独占模式下对资源的获取和释放，那么必须实现tryAcquire()方法和tryRelease()方法。第三点：如果是共享模式下对资源的获取和释放，那么必须实现tryAcquireShared()方法和tryReleaseShared()方法。 而读写锁ReentrantReadWriteLock即包含独占模式下资源的获取和释放(写锁)，也包含共享模式下资源的获取和释放(读锁)，所以需要上面的四个方法都需要实现。 用state一个整形变量怎样去维护读和写两种状态共享资源state是一个整形变量，在读写锁中又必须维护读和写两种状态，所以只能按位把state分割成两个部分，一个整形有32位，高16位代表读，低16位代表写。如图所示：![img][link1] 123456789101112//读状态占用位数static final int SHARED_SHIFT = 16;//每一次增加的读状态：(1&lt;&lt;16),因为读状态是state的高16位static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT);//读状态或写状态最大的数量static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1;//用来计算写的同步状态static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;//计算读锁的数量static int sharedCount(int c) &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;//计算写锁的数量static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125; 读操作，因为高16位为读操作，要想获取读的数量，只需将state无符号右移16位即可：state&gt;&gt;&gt;16。读最大的数量：65535(二进制表示：11111111110000000000000000) 写操作，因为低16位为写操作，要向获取写数量，只需要把state的高16位抹去就可以了，很容易想到“按位与”操作：state&amp;1111111111111111。写最大的数量：65535(二进制表示：00000000000000001111111111111111) 共享锁12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static class ReadLock implements Lock, java.io.Serializable &#123; private static final long serialVersionUID = -5992448646407690164L; // ReentrantReadWriteLock的AQS对象 private final Sync sync; protected ReadLock(ReentrantReadWriteLock lock) &#123; sync = lock.sync; &#125; // 获取“共享锁” public void lock() &#123; sync.acquireShared(1); &#125; // 如果线程是中断状态，则抛出一场，否则尝试获取共享锁。 public void lockInterruptibly() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; // 尝试获取“共享锁” public boolean tryLock() &#123; return sync.tryReadLock(); &#125; // 在指定时间内，尝试获取“共享锁” public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); &#125; // 释放“共享锁” public void unlock() &#123; sync.releaseShared(1); &#125; // 新建条件 public Condition newCondition() &#123; throw new UnsupportedOperationException(); &#125; public String toString() &#123; int r = sync.getReadLockCount(); return super.toString() + "[Read locks = " + r + "]"; &#125;&#125; ReadLock中的sync是一个Sync对象，Sync继承于AQS类，即Sync就是一个锁。ReentrantReadWriteLock中也有一个Sync对象，而且ReadLock中的sync和ReentrantReadWriteLock中的sync是对应关系。即ReentrantReadWriteLock和ReadLock共享同一个AQS对象，共享同一把锁。 获取共享锁获取共享锁的思想(即lock函数的步骤)，是先通过tryAcquireShared()尝试获取共享锁。尝试成功的话，则直接返回；尝试失败的话，则通过doAcquireShared()不断的循环并尝试获取锁，若有需要，则阻塞等待。doAcquireShared()在循环中每次尝试获取锁时，都是通过tryAcquireShared()来进行尝试的。下面看看“获取共享锁”的详细流程。 lock()123public void lock() &#123; sync.acquireShared(1);&#125; acquireShared()Sync继承于AQS，acquireShared()定义在AQS中。源码如下： 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; acquireShared()首先会通过tryAcquireShared()来尝试获取锁。尝试成功的话，则不再做任何动作(因为已经成功获取到锁了)。尝试失败的话，则通过doAcquireShared()来获取锁。doAcquireShared()会获取到锁了才返回。 tryAcquireShared()123456789101112131415161718192021222324252627282930313233343536protected final int tryAcquireShared(int unused) &#123; Thread current = Thread.currentThread(); // 获取“锁”的状态 int c = getState(); // 如果“锁”是“互斥锁”，并且获取锁的线程不是current线程；则返回-1。 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; // 获取“读取锁”的共享计数 int r = sharedCount(c); // 如果“不需要阻塞等待”，并且“读取锁”的共享计数小于MAX_COUNT； // 则通过CAS函数更新“锁的状态”，将“读取锁”的共享计数+1。 if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; // 第1次获取“读取锁”。 if (r == 0) &#123; firstReader = current; firstReaderHoldCount = 1; // 如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程 &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; // HoldCounter是用来统计该线程获取“读取锁”的次数。 HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); // 将该线程获取“读取锁”的次数+1。 rh.count++; &#125; return 1; &#125; return fullTryAcquireShared(current);&#125; tryAcquireShared()的作用是尝试获取“共享锁”。如果在尝试获取锁时，“不需要阻塞等待”并且“读取锁的共享计数小于MAX_COUNT”，则直接通过CAS函数更新“读取锁的共享计数”，以及将“当前线程获取读取锁的次数+1”。否则，通过fullTryAcquireShared()获取读取锁。 fullTryAcquireShared()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758final int fullTryAcquireShared(Thread current) &#123; HoldCounter rh = null; for (;;) &#123; // 获取“锁”的状态 int c = getState(); // 如果“锁”是“互斥锁”，并且获取锁的线程不是current线程；则返回-1。 if (exclusiveCount(c) != 0) &#123; if (getExclusiveOwnerThread() != current) return -1; // 如果“需要阻塞等待”。 // (01) 当“需要阻塞等待”的线程是第1个获取锁的线程的话，则继续往下执行。 // (02) 当“需要阻塞等待”的线程获取锁的次数=0时，则返回-1。 &#125; else if (readerShouldBlock()) &#123; // 如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程 if (firstReader == current) &#123; &#125; else &#123; if (rh == null) &#123; rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) &#123; rh = readHolds.get(); if (rh.count == 0) readHolds.remove(); &#125; &#125; // 如果当前线程获取锁的计数=0,则返回-1。 if (rh.count == 0) return -1; &#125; &#125; // 如果“不需要阻塞等待”，则获取“读取锁”的共享统计数； // 如果共享统计数超过MAX_COUNT，则抛出异常。 if (sharedCount(c) == MAX_COUNT) throw new Error("Maximum lock count exceeded"); // 将线程获取“读取锁”的次数+1。 if (compareAndSetState(c, c + SHARED_UNIT)) &#123; // 如果是第1次获取“读取锁”，则更新firstReader和firstReaderHoldCount。 if (sharedCount(c) == 0) &#123; firstReader = current; firstReaderHoldCount = 1; // 如果想要获取锁的线程(current)是第1个获取锁(firstReader)的线程， // 则将firstReaderHoldCount+1。 &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; if (rh == null) rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); // 更新线程的获取“读取锁”的共享计数 rh.count++; cachedHoldCounter = rh; // cache for release &#125; return 1; &#125; &#125;&#125; fullTryAcquireShared()会根据“是否需要阻塞等待”，“读取锁的共享计数是否超过限制”等等进行处理。如果不需要阻塞等待，并且锁的共享计数没有超过限制，则通过CAS尝试获取锁，并返回1。 doAcquireShared()1234567891011121314151617181920212223242526272829303132private void doAcquireShared(int arg) &#123; // addWaiter(Node.SHARED)的作用是，创建“当前线程”对应的结点，并将该线程添加到同步队列中。 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; // 获取“node”的前一结点 final Node p = node.predecessor(); // 如果“当前线程”是同步队列的表头，则尝试获取共享锁。 if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; // 如果“当前线程”不是同步队列的表头，则通过shouldParkAfterFailedAcquire()判断是否需要等待， // 需要的话，则通过parkAndCheckInterrupt()进行阻塞等待。若阻塞等待过程中，线程被中断过，则设置interrupted为true。 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; doAcquireShared()的作用是获取共享锁。它会首先创建线程对应的同步队列的结点，然后将该结点添加到同步队列中。同步队列是管理获取锁的等待线程的队列。如果“当前线程”是同步队列的表头，则尝试获取共享锁；否则，则需要通过shouldParkAfterFailedAcquire()判断是否阻塞等待，需要的话，则通过parkAndCheckInterrupt()进行阻塞等待。doAcquireShared()会通过for循环，不断的进行上面的操作；目的就是获取共享锁。需要注意的是：doAcquireShared()在每一次尝试获取锁时，是通过tryAcquireShared()来执行的！ 释放共享锁释放共享锁的思想，是先通过tryReleaseShared()尝试释放共享锁。尝试成功的话，则通过doReleaseShared()唤醒“其他等待获取共享锁的线程”，并返回true；否则的话，返回flase。 unlock()123public void unlock() &#123; sync.releaseShared(1);&#125; 该函数实际上调用releaseShared(1)释放共享锁。 releaseShared()1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; releaseShared()的目的是让当前线程释放它所持有的共享锁。它首先会通过tryReleaseShared()去尝试释放共享锁。尝试成功，则直接返回；尝试失败，则通过doReleaseShared()去释放共享锁。 tryReleaseShared()123456789101112131415161718192021222324252627282930313233343536protected final boolean tryReleaseShared(int unused) &#123; // 获取当前线程，即释放共享锁的线程。 Thread current = Thread.currentThread(); // 如果想要释放锁的线程(current)是第1个获取锁(firstReader)的线程， // 并且“第1个获取锁的线程获取锁的次数”=1，则设置firstReader为null； // 否则，将“第1个获取锁的线程的获取次数”-1。 if (firstReader == current) &#123; // assert firstReaderHoldCount &gt; 0; if (firstReaderHoldCount == 1) firstReader = null; else firstReaderHoldCount--; // 获取rh对象，并更新“当前线程获取锁的信息”。 &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != current.getId()) rh = readHolds.get(); int count = rh.count; if (count &lt;= 1) &#123; readHolds.remove(); if (count &lt;= 0) throw unmatchedUnlockException(); &#125; --rh.count; &#125; for (;;) &#123; // 获取锁的状态 int c = getState(); // 将锁的获取次数-1。 int nextc = c - SHARED_UNIT; // 通过CAS更新锁的状态。 if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; tryReleaseShared()的作用是尝试释放共享锁。 doReleaseShared()1234567891011121314151617181920212223242526private void doReleaseShared() &#123; for (;;) &#123; // 获取CLH队列的头节点 Node h = head; // 如果头节点不为null，并且头节点不等于tail节点。 if (h != null &amp;&amp; h != tail) &#123; // 获取头节点对应的线程的状态 int ws = h.waitStatus; // 如果头节点对应的线程是SIGNAL状态，则意味着“头节点的下一个节点所对应的线程”需要被unpark唤醒。 if (ws == Node.SIGNAL) &#123; // 设置“头节点对应的线程状态”为空状态。失败的话，则继续循环。 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // 唤醒“头节点的下一个节点所对应的线程”。 unparkSuccessor(h); &#125; // 如果头节点对应的线程是空状态，则设置“文件点对应的线程所拥有的共享锁”为其它线程获取锁的空状态。 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; // 如果头节点发生变化，则继续循环。否则，退出循环。 if (h == head) // loop if head changed break; &#125;&#125; doReleaseShared()会释放“共享锁”。它会从前往后的遍历同步队列，依次“唤醒”然后“执行”队列中每个节点对应的线程；最终的目的是让这些线程释放它们所持有的锁。 公平/非公平共享锁和互斥锁ReentrantLock一样，ReadLock也分为公平锁和非公平锁。 公平锁和非公平锁的区别，体现在判断是否需要阻塞的函数readerShouldBlock()是不同的。 公平锁的readerShouldBlock()的源码如下： 123final boolean readerShouldBlock() &#123; return hasQueuedPredecessors();&#125; 在公平共享锁中，如果在当前线程的前面有其他线程在等待获取共享锁，则返回true；否则，返回false。 非公平锁的readerShouldBlock()的源码如下： 123final boolean readerShouldBlock() &#123; return apparentlyFirstQueuedIsExclusive();&#125; 在非公平共享锁中，它会无视当前线程的前面是否有其他线程在等待获取共享锁。只要该非公平共享锁对应的线程不为null，则返回true。]]></content>
      <categories>
        <category>Java</category>
        <category>J.U.C</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J.U.C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-LockSupport]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91-LockSupport.html</url>
    <content type="text"><![CDATA[概述LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程，而且park()和unpark()不会遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题。因为park() 和 unpark()有许可的存在；调用 park() 的线程和另一个试图将其 unpark() 的线程之间的竞争将保持活性。 方法列表12345678910111213141516// 返回提供给最近一次尚未解除阻塞的 park 方法调用的 blocker 对象，如果该调用不受阻塞，则返回 null。static Object getBlocker(Thread t)// 为了线程调度，禁用当前线程，除非许可可用。static void park()// 为了线程调度，在许可可用之前禁用当前线程。static void park(Object blocker)// 为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用。static void parkNanos(long nanos)// 为了线程调度，在许可可用前禁用当前线程，并最多等待指定的等待时间。static void parkNanos(Object blocker, long nanos)// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。static void parkUntil(long deadline)// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。static void parkUntil(Object blocker, long deadline)// 如果给定线程的许可尚不可用，则使其可用。static void unpark(Thread thread) 应用示例123456789101112131415161718192021222324252627282930313233343536373839package main.java.com.study.lock.lockSupport;import java.util.concurrent.locks.LockSupport;/** * @author: whb * @description: 阻塞原语测试 */public class LockSupportTest &#123; /** * 主线程 */ private static Thread mainThread; public static void main(String[] args) &#123; ThreadA ta = new ThreadA("ta"); //获取主线程 mainThread = Thread.currentThread(); System.out.println(Thread.currentThread().getName() + " start ta"); //启动线程ta ta.start(); System.out.println(Thread.currentThread().getName() + " block"); //主线程阻塞 LockSupport.park(mainThread); System.out.println(Thread.currentThread().getName() + " continue"); &#125; static class ThreadA extends Thread &#123; public ThreadA(String name) &#123; super(name); &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + " wakeup others."); LockSupport.unpark(mainThread); &#125; &#125;&#125; 执行结果：]]></content>
      <categories>
        <category>Java</category>
        <category>J.U.C</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J.U.C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-Semaphore]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91-Semaphore.html</url>
    <content type="text"><![CDATA[概述Semaphore(信号量)是AQS共享模式的一个应用，可以允许多个线程同时对共享资源进行操作，并且可以有效的控制并发数，利用它可以很好的实现流量控制。Semaphore提供了一个许可证的概念，可以把这个许可证看作车票，只有成功获取车票的人才能够上车，并且车票是有数量的，不可能毫无限制的发下去，这样就会导致车辆超载。所以当车票发完的时候(车辆满载)，其他人就只能等下一趟车。如果中途有人下车，那么他的位置将会空闲出来，因此如果这时其他人想要上车的话就又可以获得车票了。 构造器123456789//构造器1public Semaphore(int permits) &#123; sync = new NonfairSync(permits);&#125;//构造器2public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125; Semaphore提供了两个带参构造器，没有提供无参构造器。这两个构造器都必须传入一个初始的许可证数量，使用构造器1构造出来的信号量在获取许可证时会采用非公平方式获取，使用构造器2可以通过参数指定获取许可证的方式(公平or非公平)。Semaphore主要对外提供了两类API，获取许可证和释放许可证，默认的是获取和释放一个许可证，也可以传入参数来同时获取和释放多个许可证。 获取许可证12345678910111213141516171819//获取一个许可证(响应中断)public void acquire() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;//获取一个许可证(不响应中断)public void acquireUninterruptibly() &#123; sync.acquireShared(1);&#125;//尝试获取许可证(非公平获取)public boolean tryAcquire() &#123; return sync.nonfairTryAcquireShared(1) &gt;= 0;&#125;//尝试获取许可证(定时获取)public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));&#125; 上面的API是Semaphore提供的默认获取许可证操作。每次只获取一个许可证。除了直接获取还提供了尝试获取，直接获取操作在失败之后可能会阻塞线程，而尝试获取则不会。另外还需注意的是tryAcquire方法是使用非公平方式尝试获取的。平时比较常用到的是acquire方法去获取许可证。acquire方法里面直接就是调用sync.acquireSharedInterruptibly(1)，这个方法是AQS里面的方法，下面再来回顾一下这个方法。 123456789101112//以可中断模式获取锁(共享模式)public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; //首先判断线程是否中断, 如果是则抛出异常 if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; //1.尝试去获取锁，获取成功直接返回 if (tryAcquireShared(arg) &lt; 0) &#123; //2. 如果获取失败则进入该方法 doAcquireSharedInterruptibly(arg); &#125;&#125; acquireSharedInterruptibly方法首先就是去调用tryAcquireShared方法去尝试获取，tryAcquireShared在AQS里面是抽象方法，FairSync和NonfairSync这两个派生类实现了该方法的逻辑。FairSync实现的是公平获取的逻辑，而NonfairSync实现的非公平获取的逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859abstract static class Sync extends AbstractQueuedSynchronizer &#123; //非公平方式尝试获取 final int nonfairTryAcquireShared(int acquires) &#123; for (;;) &#123; //获取可用许可证 int available = getState(); //获取剩余许可证 int remaining = available - acquires; //1.如果remaining小于0则直接返回remaining //2.如果remaining大于0则先更新同步状态再返回remaining if (remaining &lt; 0 || compareAndSetState(available, remaining)) &#123; return remaining; &#125; &#125; &#125;&#125;//非公平同步器static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = -2694183684443567898L; NonfairSync(int permits) &#123; super(permits); &#125; //尝试获取许可证 protected int tryAcquireShared(int acquires) &#123; return nonfairTryAcquireShared(acquires); &#125;&#125;//公平同步器static final class FairSync extends Sync &#123; private static final long serialVersionUID = 2014338818796000944L; FairSync(int permits) &#123; super(permits); &#125; //尝试获取许可证 protected int tryAcquireShared(int acquires) &#123; for (;;) &#123; //判断同步队列前面有没有人排队 if (hasQueuedPredecessors()) &#123; //如果有的话就直接返回-1，表示尝试获取失败 return -1; &#125; //获取可用许可证 int available = getState(); //获取剩余许可证 int remaining = available - acquires; //1.如果remaining小于0则直接返回remaining //2.如果remaining大于0则先更新同步状态再返回remaining if (remaining &lt; 0 || compareAndSetState(available, remaining)) &#123; return remaining; &#125; &#125; &#125;&#125; NonfairSync的tryAcquireShared方法直接调用的是nonfairTryAcquireShared方法，这个方法是在父类Sync里面的。非公平获取锁的逻辑是先取出当前同步状态(同步状态表示许可证个数)，将当前同步状态减去传入的参数，如果结果不小于0的话证明还有可用的许可证，那么就直接使用CAS操作更新同步状态的值，最后不管结果是否小于0都会返回该结果值。这里要了解tryAcquireShared方法返回值的含义，返回负数表示获取失败，零表示当前线程获取成功但后续线程不能再获取，正数表示当前线程获取成功并且后续线程也能够获取。再来看看acquireSharedInterruptibly方法的代码。 123456789101112131415//以可中断模式获取锁(共享模式)public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; //首先判断线程是否中断, 如果是则抛出异常 if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; //1.尝试去获取锁 //负数：表示获取失败 //零值：表示当前线程获取成功, 但是后继线程不能再获取了 //正数：表示当前线程获取成功, 并且后继线程同样可以获取成功 if (tryAcquireShared(arg) &lt; 0) &#123; //2. 如果获取失败则进人该方法 doAcquireSharedInterruptibly(arg); &#125;&#125; 如果返回的remaining小于0的话就代表获取失败，因此tryAcquireShared(arg) &lt; 0就为true，所以接下来就会调用doAcquireSharedInterruptibly方法，这个方法是AQS的方法，它会将当前线程包装成结点放入同步队列尾部，并且有可能挂起线程。这也是当remaining小于0时线程会排队阻塞的原因。而如果返回的remaining&gt;=0的话就代表当前线程获取成功，因此tryAcquireShared(arg) &lt; 0就为flase，所以就不会再去调用doAcquireSharedInterruptibly方法阻塞当前线程了。以上是非公平获取的整个逻辑，而公平获取时仅仅是在此之前先去调用hasQueuedPredecessors方法判断同步队列是否有人在排队，如果有的话就直接return -1表示获取失败，否则才继续执行下面和非公平获取一样的步骤。 释放许可1234//释放一个许可证public void release() &#123; sync.releaseShared(1);&#125; 调用release方法是释放一个许可证，它的操作很简单，就调用了AQS的releaseShared方法，下面来看看这个方法。 12345678910//释放锁的操作(共享模式)public final boolean releaseShared(int arg) &#123; //1.尝试去释放锁 if (tryReleaseShared(arg)) &#123; //2.如果释放成功就唤醒其他线程 doReleaseShared(); return true; &#125; return false;&#125; AQS的releaseShared方法首先调用tryReleaseShared方法尝试释放锁，这个方法的实现逻辑在子类Sync里面。Semaphore重写了tryReleaseShared()，它的源码如下： 12345678910111213protected final boolean tryReleaseShared(int releases) &#123; for (;;) &#123; // 获取“可以获得的信号量的许可数” int current = getState(); // 获取“释放releases个信号量许可之后，剩余的信号量许可数” int next = current + releases; if (next &lt; current) // overflow throw new Error("Maximum permit count exceeded"); // 设置“可以获得的信号量的许可数”为next。 if (compareAndSetState(current, next)) return true; &#125;&#125; tryReleaseShared方法里面采用for循环进行自旋，首先获取同步状态，将同步状态加上传入的参数，然后以CAS方式更新同步状态，更新成功就返回true并跳出方法，否则就继续循环直到成功为止。如果tryReleaseShared()尝试释放共享锁失败，则会调用doReleaseShared()去释放共享锁。doReleaseShared()的源码如下： 1234567891011121314151617181920212223242526private void doReleaseShared() &#123; for (;;) &#123; // 获取同步队列的头节点 Node h = head; // 如果头节点不为null，并且头节点不等于tail节点。 if (h != null &amp;&amp; h != tail) &#123; // 获取头节点对应的线程的状态 int ws = h.waitStatus; // 如果头节点对应的线程是SIGNAL状态，则意味着“头节点的下一个节点所对应的线程”需要被unpark唤醒。 if (ws == Node.SIGNAL) &#123; // 设置“头节点对应的线程状态”为空状态。失败的话，则继续循环。 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // 唤醒“头节点的下一个节点所对应的线程”。 unparkSuccessor(h); &#125; // 如果头节点对应的线程是空状态，则设置“文件点对应的线程所拥有的共享锁”为其它线程获取锁的空状态。 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; // 如果头节点发生变化，则继续循环。否则，退出循环。 if (h == head) // loop if head changed break; &#125;&#125; doReleaseShared()会释放“共享锁”。它会从前往后的遍历同步队列，依次“唤醒”然后“执行”队列中每个节点对应的线程；最终的目的是让这些线程释放它们所持有的信号量。 应用示例利用Semaphore实现数据库连接池。 连接池代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118package main.java.com.study.lock.semaphore;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;/** * @author: whb * @description: 连接池 */public class ConnectPool &#123; /** * 连接池大小 */ private int size; /** * 连接集合 */ private Connect[] connects; /** * 连接状态标志 */ private boolean[] connectFlag; /** * 剩余可用连接数 */ private volatile int available; /** * 信号量 */ private Semaphore semaphore; public ConnectPool(int size) &#123; this.size = size; this.available = size; semaphore = new Semaphore(size, true); connects = new Connect[size]; connectFlag = new boolean[size]; initConnects(); &#125; /** * 初始化连接 */ private void initConnects() &#123; //生成指定数量的连接 for (int i = 0; i &lt; this.size; i++) &#123; connects[i] = new Connect(); &#125; &#125; /** * 获取连接 */ private synchronized Connect getConnect() &#123; for (int i = 0; i &lt; connectFlag.length; i++) &#123; //遍历集合找到未使用的连接 if (!connectFlag[i]) &#123; //将连接设置为使用中 connectFlag[i] = true; //可用连接数减一 available--; System.out.println("【" + Thread.currentThread().getName() + "】已获取连接，剩余可用连接：" + available); //返回连接 return connects[i]; &#125; &#125; return null; &#125; /** * 打开链接 * * @return */ public Connect openConnect() throws InterruptedException &#123; //获取许可 semaphore.acquire(); //获取连接 return getConnect(); &#125; /** * 释放连接 */ public synchronized void release(Connect connect) &#123; for (int i = 0; i &lt; this.size; i++) &#123; if (connect == connects[i]) &#123; //将连接设置为未使用 connectFlag[i] = false; //可用连接加一 available++; System.out.println("【" + Thread.currentThread().getName() + "】已释放连接，剩余可用连接：" + available); //释放许可 semaphore.release(); &#125; &#125; &#125;&#125;class Connect &#123; private static int count = 1; private int id = count++; public Connect() &#123; //模拟打开一个连接很耗费资源，需要等待1秒 try &#123; TimeUnit.MILLISECONDS.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("连接#" + id + "#已与数据库建立通道！"); &#125; @Override public String toString() &#123; return "【" + id + "】"; &#125;&#125; 测试代码： 123456789101112131415161718192021222324252627package main.java.com.study.lock.semaphore;/** * @author: whb * @description: 测试连接池 */public class TestConnectPool extends Thread &#123; private static ConnectPool pool = new ConnectPool(3); @Override public void run() &#123; try &#123; Connect connect = pool.openConnect(); Thread.sleep(100); pool.release(connect); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; new TestConnectPool().start(); &#125; &#125;&#125; 执行结果：]]></content>
      <categories>
        <category>Java</category>
        <category>J.U.C</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J.U.C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-CyclicBarrier]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91-CyclicBarrier.html</url>
    <content type="text"><![CDATA[概述现实生活中经常会遇到这样的情景，在进行某个活动前需要等待人全部都齐了才开始。例如吃饭时要等全家人都上座了才动筷子，旅游时要等全部人都到齐了才出发，比赛时要等运动员都上场后才开始。在J.U.C包中提供了一个同步工具类能够很好的模拟这类场景，它就是CyclicBarrier类。利用CyclicBarrier类可以实现一组线程相互等待，当所有线程都到达某个屏障点后再进行后续的操作。下图演示了这一过程。 成员变量在CyclicBarrier类的内部有一个计数器，每个线程在到达屏障点的时候都会调用await方法将自己阻塞，此时计数器会减1，当计数器减为0的时候所有因调用await方法而被阻塞的线程将被唤醒。这就是实现一组线程相互等待的原理，下面看下CyclicBarrier有哪些成员变量。 1234567891011121314151617//同步操作锁private final ReentrantLock lock = new ReentrantLock();//线程拦截器private final Condition trip = lock.newCondition();//每次拦截的线程数private final int parties;//换代前执行的任务private final Runnable barrierCommand;//表示栅栏的当前代private Generation generation = new Generation();//计数器private int count;//静态内部类Generationprivate static class Generation &#123; boolean broken = false;&#125; CyclicBarrier内部是通过条件队列trip来对线程进行阻塞的，并且其内部维护了两个int型的变量parties和count。parties表示每次拦截的线程数，该值在构造时进行赋值。count是内部计数器，它的初始值和parties相同，以后随着每次await方法的调用而减1，直到减为0就将所有线程唤醒。CyclicBarrier有一个静态内部类Generation，该类的对象代表栅栏的当前代，就像玩游戏时代表的本局游戏，利用它可以实现循环等待。barrierCommand表示换代前执行的任务，当count减为0时表示本局游戏结束，需要转到下一局。在转到下一局游戏之前会将所有阻塞的线程唤醒，在唤醒所有线程之前你可以通过指定barrierCommand来执行自己的任务。 构造器123456789101112131415//构造器1public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); // parties表示“必须同时到达barrier的线程个数”。 this.parties = parties; // count表示“处在等待状态的线程个数”。 this.count = parties; // barrierCommand表示“parties个线程到达barrier时，会执行的动作”。 this.barrierCommand = barrierAction;&#125;//构造器2public CyclicBarrier(int parties) &#123; this(parties, null);&#125; CyclicBarrier有两个构造器，其中构造器1是它的核心构造器，在这里可以指定要拦截的线程数以及结束时要执行的任务，还可以看到计数器count的初始值被设置为parties。 等待方法12345678910111213//非定时等待public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); &#125;&#125;//定时等待public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; return dowait(true, unit.toNanos(timeout));&#125; 不管是定时等待还是非定时等待，它们都调用了dowait方法，只不过是传入的参数不同而已。下面看下dowait方法都做了些什么。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//核心等待方法private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; final ReentrantLock lock = this.lock; //获取独占锁 lock.lock(); try &#123; //保存当前的generation final Generation g = generation; //检查当前栅栏是否被打翻 if (g.broken) &#123; throw new BrokenBarrierException(); &#125; //检查当前线程是否被中断 if (Thread.interrupted()) &#123; //如果当前线程被中断会做以下三件事 //1.打翻当前栅栏 //2.唤醒拦截的所有线程 //3.抛出中断异常 breakBarrier(); throw new InterruptedException(); &#125; //每次都将计数器的值减1 int index = --count; //计数器的值减为0则需唤醒所有线程并转换到下一代 if (index == 0) &#123; boolean ranAction = false; try &#123; //唤醒所有线程前先执行指定的任务 final Runnable command = barrierCommand; if (command != null) &#123; command.run(); &#125; ranAction = true; //唤醒所有线程并转到下一代 nextGeneration(); return 0; &#125; finally &#123; //确保在任务未成功执行时能将所有线程唤醒 if (!ranAction) &#123; breakBarrier(); &#125; &#125; &#125; //当前线程一直阻塞，直到“有parties个线程到达barrier” 或 “当前线程被中断” 或 “超时”这3者之一发生，当前线程才继续执行。 for (;;) &#123; try &#123; //根据传入的参数来决定是定时等待还是非定时等待 if (!timed) &#123; trip.await(); &#125;else if (nanos &gt; 0L) &#123; nanos = trip.awaitNanos(nanos); &#125; &#125; catch (InterruptedException ie) &#123; //若当前线程在等待期间被中断则打翻栅栏唤醒其他线程 if (g == generation &amp;&amp; ! g.broken) &#123; breakBarrier(); throw ie; &#125; else &#123; //若在捕获中断异常前已经完成在栅栏上的等待, 则直接调用中断操作 Thread.currentThread().interrupt(); &#125; &#125; //如果线程因为打翻栅栏操作而被唤醒则抛出异常 if (g.broken) &#123; throw new BrokenBarrierException(); &#125; //如果线程因为换代操作而被唤醒则返回计数器的值 if (g != generation) &#123; return index; &#125; //如果线程因为时间到了而被唤醒则打翻栅栏并抛出异常 if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 在dowait方法中每次都将count减1，减完后立马进行判断看看是否等于0，如果等于0的话就会先去执行之前指定好的任务，执行完之后再调用nextGeneration方法将栅栏转到下一代，在该方法中会将所有线程唤醒，将计数器的值重新设为parties，最后会重新设置栅栏代次，在执行完nextGeneration方法之后就意味着游戏进入下一局。如果计数器此时还不等于0的话就进入for循环，根据参数来决定是调用trip.awaitNanos(nanos)还是trip.await()方法，这两方法对应着定时和非定时等待。如果在等待过程中当前线程被中断就会执行breakBarrier方法，该方法叫做打破栅栏，意味着游戏在中途被掐断，设置generation的broken状态为true并唤醒所有线程。同时这也说明在等待过程中有一个线程被中断整盘游戏就结束，所有之前被阻塞的线程都会被唤醒。线程醒来后会执行下面三个判断，看看是否因为调用breakBarrier方法而被唤醒，如果是则抛出异常；看看是否是正常的换代操作而被唤醒，如果是则返回计数器的值；看看是否因为超时而被唤醒，如果是的话就调用breakBarrier打破栅栏并抛出异常。这里还需要注意的是，如果其中有一个线程因为等待超时而退出，那么整盘游戏也会结束，其他线程都会被唤醒。下面贴出nextGeneration方法和breakBarrier方法的具体代码。 12345678910111213141516171819//切换栅栏到下一代private void nextGeneration() &#123; //唤醒条件队列所有线程 trip.signalAll(); //设置计数器的值为需要拦截的线程数 count = parties; //重新设置栅栏代次 generation = new Generation();&#125;//打翻当前栅栏private void breakBarrier() &#123; //将当前栅栏状态设置为打翻 generation.broken = true; //设置计数器的值为需要拦截的线程数 count = parties; //唤醒所有线程 trip.signalAll();&#125; 应用示例赛马:通过在控制台不停的打印各赛马的当前轨迹，以达到动态显示的效果。整场比赛有多个轮次，每一轮次各个赛马都会随机走上几步然后调用await方法进行等待，当所有赛马走完一轮的时候将会执行任务将所有赛马的当前轨迹打印到控制台上。这样每一轮下来各赛马的轨迹都在不停的增长，当其中某个赛马的轨迹最先增长到指定的值的时候将会结束整场比赛，该赛马成为整场比赛的胜利者！程序如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class Horse implements Runnable &#123; private static int counter = 0; private final int id = counter++; private int strides = 0; private static Random rand = new Random(47); private static CyclicBarrier barrier; public Horse(CyclicBarrier b) &#123; barrier = b; &#125; @Override public void run() &#123; try &#123; while(!Thread.interrupted()) &#123; synchronized(this) &#123; //赛马每次随机跑几步 strides += rand.nextInt(3); &#125; barrier.await(); &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; public String tracks() &#123; StringBuilder s = new StringBuilder(); for(int i = 0; i &lt; getStrides(); i++) &#123; s.append("*"); &#125; s.append(id); return s.toString(); &#125; public synchronized int getStrides() &#123; return strides; &#125; public String toString() &#123; return "Horse " + id + " "; &#125; &#125;public class HorseRace implements Runnable &#123; private static final int FINISH_LINE = 75; private static List&lt;Horse&gt; horses = new ArrayList&lt;Horse&gt;(); private static ExecutorService exec = Executors.newCachedThreadPool(); @Override public void run() &#123; StringBuilder s = new StringBuilder(); //打印赛道边界 for(int i = 0; i &lt; FINISH_LINE; i++) &#123; s.append("="); &#125; System.out.println(s); //打印赛马轨迹 for(Horse horse : horses) &#123; System.out.println(horse.tracks()); &#125; //判断是否结束 for(Horse horse : horses) &#123; if(horse.getStrides() &gt;= FINISH_LINE) &#123; System.out.println(horse + "won!"); exec.shutdownNow(); return; &#125; &#125; //休息指定时间再到下一轮 try &#123; TimeUnit.MILLISECONDS.sleep(200); &#125; catch(InterruptedException e) &#123; System.out.println("barrier-action sleep interrupted"); &#125; &#125; public static void main(String[] args) &#123; CyclicBarrier barrier = new CyclicBarrier(7, new HorseRace()); for(int i = 0; i &lt; 7; i++) &#123; Horse horse = new Horse(barrier); horses.add(horse); exec.execute(horse); &#125; &#125; &#125; 程序的运行结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>J.U.C</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J.U.C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-CountDownLatch]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91-CountDownLatch.html</url>
    <content type="text"><![CDATA[概述CountDownLatch(闭锁)是一个很有用的工具类，利用它我们可以拦截一个或多个线程使其在某个条件成熟后再执行。它的内部提供了一个计数器，在构造闭锁时必须指定计数器的初始值，且计数器的初始值必须大于0。另外它还提供了一个countDown方法来操作计数器的值，每调用一次countDown方法计数器都会减1，直到计数器的值减为0时就代表条件已成熟，所有因调用await方法而阻塞的线程都会被唤醒。这就是CountDownLatch的内部机制，看起来很简单，无非就是阻塞一部分线程让其在达到某个条件之后再执行。但是CountDownLatch的应用场景却比较广泛，只要你脑洞够大利用它就可以玩出各种花样。最常见的一个应用场景是开启多个线程同时执行某个任务，等到所有任务都执行完再统计汇总结果。下图动态演示了闭锁阻塞线程的整个过程。 上图演示了有5个线程因调用await方法而被阻塞，它们需要等待计数器的值减为0才能继续执行。计数器的初始值在构造闭锁时被指定，后面随着每次countDown方法的调用而减1。 构造器12345//构造器public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0"); this.sync = new Sync(count);&#125; CountDownLatch只有一个带参构造器，必须传入一个大于0的值作为计数器初始值，否则会报错。可以看到在构造方法中只是去new了一个Sync对象并赋值给成员变量sync。和其他同步工具类一样，CountDownLatch的实现依赖于AQS，它是AQS共享模式下的一个应用。CountDownLatch实现了一个内部类Sync并用它去继承AQS，这样就能使用AQS提供的大部分方法了。下面来看一下Sync内部类的代码。 123456789101112131415161718192021222324252627282930313233343536373839//同步器private static final class Sync extends AbstractQueuedSynchronizer &#123; //构造器 Sync(int count) &#123; setState(count); &#125; //获取当前同步状态 int getCount() &#123; return getState(); &#125; //尝试获取锁 //返回负数：表示当前线程获取失败 //返回零值：表示当前线程获取成功, 但是后继线程不能再获取了 //返回正数：表示当前线程获取成功, 并且后继线程同样可以获取成功 protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; //尝试释放锁 protected boolean tryReleaseShared(int releases) &#123; for (;;) &#123; //获取同步状态 int c = getState(); //如果同步状态为0, 则不能再释放了 if (c == 0) &#123; return false; &#125; //否则的话就将同步状态减1 int nextc = c-1; //使用CAS方式更新同步状态 if (compareAndSetState(c, nextc)) &#123; return nextc == 0; &#125; &#125; &#125;&#125; 可以看到Sync的构造方法会将同步状态的值设置为传入的参数值。之后每次调用countDown方法都会将同步状态的值减1，这也就是计数器的实现原理。在平时使用CountDownLatch工具类时最常用的两个方法就是await方法和countDown方法。调用await方法会阻塞当前线程直到计数器为0，调用countDown方法会将计数器的值减1直到减为0。 阻塞线程await123456789101112131415161718//导致当前线程等待, 直到state减少到0, 或者线程被打断public void await() throws InterruptedException &#123; //以响应线程中断方式获取 sync.acquireSharedInterruptibly(1);&#125;//以可中断模式获取锁(共享模式)public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; //首先判断线程是否中断, 如果是则抛出异常 if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; //1.尝试去获取锁 if (tryAcquireShared(arg) &lt; 0) &#123; //2. 如果获取失败则进人该方法 doAcquireSharedInterruptibly(arg); &#125;&#125; 当线程调用await方法时其实是调用到了AQS的acquireSharedInterruptibly方法，该方法是以响应线程中断的方式来获取锁的。在acquireSharedInterruptibly方法首先会去调用tryAcquireShared方法尝试获取锁。Sync里面重写的tryAcquireShared方法的逻辑，方法的实现逻辑很简单，就是判断当前同步状态是否为0，如果为0则返回1表明可以获取锁，否则返回-1表示不能获取锁。如果tryAcquireShared方法返回1则线程能够不必等待而继续执行，如果返回-1那么后续就会去调用doAcquireSharedInterruptibly方法让线程进入到同步队列里面等待。这就是调用await方法会阻塞当前线程的原理。 唤醒线程countDown123456789101112131415//减少state的方法public void countDown() &#123; sync.releaseShared(1);&#125;//释放锁的操作(共享模式)public final boolean releaseShared(int arg) &#123; //1.尝试去释放锁 if (tryReleaseShared(arg)) &#123; //2.如果释放成功就唤醒其他线程 doReleaseShared(); return true; &#125; return false;&#125; countDown方法里面调用了releaseShared方法，该方法同样是AQS里面的方法。releaseShared方法里面首先是调用tryReleaseShared方法尝试释放锁，tryReleaseShared方法在AQS里面是一个抽象方法，它的具体实现逻辑在子类Sync类里面，在上面贴出的Sync类代码里可以找到该方法。tryReleaseShared方法如果返回true表示释放成功，返回false表示释放失败，只有当将同步状态减1后该同步状态恰好为0时才会返回true，其他情况都是返回false。那么当tryReleaseShared返回true之后就会马上调用doReleaseShared方法去唤醒同步队列的所有线程。这样就解释了为什么最后一次调用countDown方法将计数器减为0后就会唤醒所有被阻塞的线程。 总结 CountDownLatch是通过“共享锁”实现的。在创建CountDownLatch中时，会传递一个int类型参数count，该参数是“锁计数器”的初始状态，表示该“共享锁”最多能被count个线程同时获取。当某线程调用该CountDownLatch对象的await()方法时，该线程会等待“共享锁”可用时，才能获取“共享锁”进而继续运行。而“共享锁”可用的条件，就是“锁计数器”的值为0！而“锁计数器”的初始值为count，每当一个线程调用该CountDownLatch对象的countDown()方法时，才将“锁计数器”-1；通过这种方式，必须有count个线程调用countDown()之后，“锁计数器”才为0，而前面提到的等待线程才能继续运行！ 应用示例在玩欢乐斗地主时必须等待三个玩家都到齐才可以进行发牌。 123456789101112131415161718192021222324252627public class Player extends Thread &#123; private static int count = 1; private final int id = count++; private CountDownLatch latch; public Player(CountDownLatch latch) &#123; this.latch = latch; &#125; @Override public void run() &#123; System.out.println("【玩家" + id + "】已入场"); latch.countDown(); &#125; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch latch = new CountDownLatch(3); System.out.println("牌局开始, 等待玩家入场..."); new Player(latch).start(); new Player(latch).start(); new Player(latch).start(); latch.await(); System.out.println("玩家已到齐, 开始发牌..."); &#125; &#125; 运行结果显示发牌操作一定是在所有玩家都入场后才进行。将latch.await()注释掉，对比下看看结果。 可以看到在注释掉latch.await()这行之后，就不能保证在所有玩家入场后才开始发牌了。]]></content>
      <categories>
        <category>Java</category>
        <category>J.U.C</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J.U.C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-ReentrantLock]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91-ReentrantLock.html</url>
    <content type="text"><![CDATA[概述在Jdk5.0之前，协调对共享对象的访问可以使用的机制只有synchronized和volatile。synchronized关键字实现了内置锁，而volatile关键字保证了多线程的内存可见性。在大多数情况下，这些机制都能很好地完成工作，但却无法实现一些更高级的功能，例如，无法中断一个正在等待获取锁的线程，无法实现限定时间的获取锁机制，无法实现非阻塞结构的加锁规则等。而这些更灵活的加锁机制通常都能够提供更好的活跃性或性能。因此，在Jdk5.0中增加了一种新的机制：ReentrantLock。ReentrantLock类实现了Lock接口，并提供了与synchronized相同的互斥性和内存可见性，它的底层是通过AQS来实现多线程同步的。与内置锁相比ReentrantLock不仅提供了更丰富的加锁机制，而且在性能上也不逊色于内置锁(在以前的版本中甚至优于内置锁)。 synchronized关键字Java提供了内置锁来支持多线程的同步，JVM根据synchronized关键字来标识同步代码块。当线程进入同步代码块时会自动获取锁，退出同步代码块时会自动释放锁。一个线程获得锁后其他线程将会被阻塞。每个Java对象都可以用做一个实现同步的锁，synchronized关键字可以用来修饰对象方法，静态方法和代码块。当修饰对象方法和静态方法时锁分别是方法所在的对象和Class对象，当修饰代码块时需提供额外的对象作为锁。每个Java对象之所以可以作为锁，是因为在对象头中关联了一个monitor对象(管程)。线程进入同步代码块时会自动持有monitor对象，退出时会自动释放monitor对象，当monitor对象被持有时其他线程将会被阻塞。当然这些同步操作都由JVM底层帮你实现了，但以synchronized关键字修饰的方法和代码块在底层实现上还是有些区别的。synchronized关键字修饰的方法是隐式同步的，即无需通过字节码指令来控制的，JVM可以根据方法表中的ACC_SYNCHRONIZED访问标志来区分一个方法是否是同步方法；而synchronized关键字修饰的代码块是显式同步的，它是通过monitorenter和monitorexit字节码指令来控制线程对管程的持有和释放。monitor对象内部持有_count字段，_count等于0表示管程未被持有，_count大于0表示管程已被持有，每次持有线程重入时_count都会加1，每次持有线程退出时_count都会减1，这就是内置锁重入性的实现原理。另外，monitor对象内部还有两条队列_EntryList和_WaitSet，对应着AQS的同步队列和条件队列，当线程获取锁失败时会到_EntryList中阻塞，当调用锁对象的wait方法时线程将会进入_WaitSet中等待，这是内置锁的线程同步和条件等待的实现原理。 ReentrantLock和Synchronized的对比synchronized关键字是Java提供的内置锁机制，其同步操作由底层JVM实现，而ReentrantLock是java.util.concurrent包提供的显式锁，其同步操作由AQS同步器提供支持。ReentrantLock在加锁和内存上提供的语义与内置锁相同，此外它还提供了一些其他功能，包括定时的锁等待，可中断的锁等待，公平锁，以及实现非块结构的加锁。在早期的JDK版本中ReentrantLock在性能上还占有一定的优势，既然ReentrantLock拥有这么多优势，为什么还要使用synchronized关键字呢？事实上确实有许多人使用ReentrantLock来替代synchronized关键字的加锁操作。但是内置锁仍然有它特有的优势，内置锁为许多开发人员所熟悉，使用方式也更加的简洁紧凑，因为显式锁必须手动在finally块中调用unlock，所以使用内置锁相对来说会更加安全些。同时未来更加可能会去提升synchronized而不是ReentrantLock的性能。因为synchronized是JVM的内置属性，它能执行一些优化，例如对线程封闭的锁对象的锁消除优化，通过增加锁的粒度来消除内置锁的同步，而如果通过基于类库的锁来实现这些功能，则可能性不大。所以当需要一些高级功能时才应该使用ReentrantLock，这些功能包括：可定时的，可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁。否则，还是应该优先使用synchronized。 获取锁和释放锁首先通过一个例子来了解下ReentrantLock的用法：如果有一个共享变量count，有10个线程对它进行累加，每一个线程累加1000次，这段代码怎样设计呢？ 有很多种办法，可以利用synchronized关键字，也可以利用原子类AtomicInteger,那我们利用ReentrantLock怎样处理的？ 123456789101112131415161718192021222324252627282930package main.java.com.study.lock;/** * @author: whb * @description: ReentrantLock测试类 */public class ReentrantLockTest &#123; private static int count = 0; //默认是获取一个非公平锁 private static ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; try &#123; //执行前先加锁 lock.lock(); for (int j = 0; j &lt; 1000; j++) &#123; count++; &#125; &#125; finally &#123; //最后释放锁 lock.unlock(); &#125; &#125;).start(); &#125; Thread.sleep(5000); System.out.println("count=" + count); &#125;&#125; 以下是获取锁和释放锁这两个操作的API。 12345678//获取锁的操作public void lock() &#123; sync.lock();&#125;//释放锁的操作public void unlock() &#123; sync.release(1);&#125; 锁的获取和释放的源码并没有更多的逻辑，而核心的逻辑分别委托给Sync对象的lock方法和release方法。那么Sync又是什么呢？在AQS的文章中提到过，在并发包中锁的底层实现都是通过AQS框架实现的。如果想实现独占锁，子类只需要实现如下方法： 1：获取锁：tryAcquire()2：释放锁：tryRelease() 如果想实现共享锁： 1: 获取锁：tryAcquireShared()2: 释放锁：tryReleaseShared() Sync就是AQS的子类,并且是独占锁模式。 在ReentrantLock中有两种模式：一种是非公平模式获取锁，另一种是公平模式获取锁。默认情况下是非公平的。 1234567891011121314151617181920212223242526272829303132public class ReentrantLock implements Lock, java.io.Serializable &#123; private final Sync sync; abstract static class Sync extends AbstractQueuedSynchronizer &#123; abstract void lock(); &#125; //实现非公平锁的同步器 static final class NonfairSync extends Sync &#123; final void lock() &#123; ... &#125; &#125; //实现公平锁的同步器 static final class FairSync extends Sync &#123; final void lock() &#123; ... &#125; &#125; //默认构造器：非公平锁 public ReentrantLock() &#123; sync = new NonfairSync(); &#125; //带参构造器：fair=true表示是公平模式获取锁;fair=false表示是非公平模式获取锁 public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125;&#125; 调用默认无参构造器会将NonfairSync实例赋值给sync，此时锁是非公平锁。有参构造器允许通过参数来指定是将FairSync实例还是NonfairSync实例赋值给sync。NonfairSync和FairSync都是继承自Sync类并重写了lock()方法，所以公平锁和非公平锁在获取锁的方式上有些区别。再来看看释放锁的操作，每次调用unlock()方法都只是去执行sync.release(1)操作，这步操作会调用AbstractQueuedSynchronizer类的release()方法，下面看一下： 123456789101112131415//释放锁的操作(独占模式)public final boolean release(int arg) &#123; //尝试释放锁 if (tryRelease(arg)) &#123; //获取head结点 Node h = head; //如果head结点不为空并且等待状态不等于0就去唤醒后继结点 if (h != null &amp;&amp; h.waitStatus != 0) &#123; //唤醒后继结点 unparkSuccessor(h); &#125; return true; &#125; return false;&#125; 这个release方法是AQS提供的释放锁操作的API，它首先会去调用tryRelease方法去尝试获取锁，tryRelease方法是抽象方法，它的实现逻辑在子类Sync里面。 123456789101112131415161718//尝试释放锁protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; //如果持有锁的线程不是当前线程就抛出异常 if (Thread.currentThread() != getExclusiveOwnerThread()) &#123; throw new IllegalMonitorStateException(); &#125; boolean free = false; //如果同步状态为0则表明锁被释放 if (c == 0) &#123; //设置锁被释放的标志为真 free = true; //设置占用线程为空 setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; 这个tryRelease方法首先会获取当前同步状态，并将当前同步状态减去传入的参数值得到新的同步状态，然后判断新的同步状态是否等于0，如果等于0则表明当前锁被释放，然后先将锁的释放状态置为真，再将当前占有锁的线程清空，最后调用setState方法设置新的同步状态并返回锁的释放状态。 公平锁/非公平锁ReentrantLock是公平锁还是非公平锁是基于sync指向的是哪个具体实例。在构造时会为成员变量sync赋值，如果赋值为NonfairSync实例则表明是非公平锁，如果赋值为FairSync实例则表明为公平锁。如果是公平锁，线程将按照它们发出请求的顺序来获得锁，但在非公平锁上，则允许插队行为：当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过队列中所有等待的线程直接获得这个锁。 非公平锁12345678910111213141516171819202122232425//非公平同步器static final class NonfairSync extends Sync &#123; //实现父类的抽象获取锁的方法 final void lock() &#123; //使用CAS方式设置同步状态 if (compareAndSetState(0, 1)) &#123; //如果设置成功则表明锁没被占用 setExclusiveOwnerThread(Thread.currentThread()); &#125; else &#123; //否则表明锁已经被占用, 调用acquire让线程去同步队列排队获取 acquire(1); &#125; &#125; //尝试获取锁的方法 protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125;//以不可中断模式获取锁(独占模式)public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123; selfInterrupt(); &#125;&#125; 可以看到在非公平锁的lock方法中，线程第一步就会以CAS方式将同步状态的值从0改为1。其实这步操作就等于去尝试获取锁，如果更改成功则表明线程刚来就获取了锁，而不必再去同步队列里面排队了。如果更改失败则表明线程刚来时锁还未被释放，所以接下来就调用acquire方法。这个acquire方法是继承自AbstractQueuedSynchronizer的方法：线程进入acquire方法后首先去调用tryAcquire方法尝试去获取锁，由于NonfairSync覆盖了tryAcquire方法，并在方法中调用了父类Sync的nonfairTryAcquire方法，所以这里会调用到nonfairTryAcquire方法去尝试获取锁。下面看看这个方法具体做了些什么。 123456789101112131415161718192021222324252627//非公平的获取锁final boolean nonfairTryAcquire(int acquires) &#123; //获取当前线程 final Thread current = Thread.currentThread(); //获取当前同步状态 int c = getState(); //如果同步状态为0则表明锁没有被占用 if (c == 0) &#123; //使用CAS更新同步状态 if (compareAndSetState(0, acquires)) &#123; //设置目前占用锁的线程 setExclusiveOwnerThread(current); return true; &#125; //否则的话就判断持有锁的是否是当前线程 &#125;else if (current == getExclusiveOwnerThread()) &#123; //如果锁是被当前线程持有的, 就直接修改当前同步状态 int nextc = c + acquires; if (nextc &lt; 0) &#123; throw new Error("Maximum lock count exceeded"); &#125; setState(nextc); return true; &#125; //如果持有锁的不是当前线程则返回失败标志 return false;&#125; nonfairTryAcquire方法是Sync的方法，可以看到线程进入此方法后首先去获取同步状态，如果同步状态为0就使用CAS操作更改同步状态，其实这又是获取了一遍锁。如果同步状态不为0表明锁被占用，此时会先去判断持有锁的线程是否是当前线程，如果是的话就将同步状态加1，否则的话这次尝试获取锁的操作宣告失败。于是会调用addWaiter方法将线程添加到同步队列。综上来看，在非公平锁的模式下一个线程在进入同步队列之前会尝试获取两遍锁，如果获取成功则不进入同步队列排队，否则才进入同步队列排队。 公平锁1234567891011121314151617181920212223242526272829303132333435363738394041424344//实现公平锁的同步器static final class FairSync extends Sync &#123; //实现父类的抽象获取锁的方法 final void lock() &#123; //调用acquire让线程去同步队列排队获取 acquire(1); &#125; //尝试获取锁的方法 protected final boolean tryAcquire(int acquires) &#123; //获取当前线程 final Thread current = Thread.currentThread(); //获取当前同步状态 int c = getState(); //如果同步状态0则表示锁没被占用 if (c == 0) &#123; //判断同步队列是否有前驱结点 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; //如果没有前驱结点且设置同步状态成功就表示获取锁成功 setExclusiveOwnerThread(current); return true; &#125; //否则判断是否是当前线程持有锁 &#125;else if (current == getExclusiveOwnerThread()) &#123; //如果是当前线程持有锁就直接修改同步状态 int nextc = c + acquires; if (nextc &lt; 0) &#123; throw new Error("Maximum lock count exceeded"); &#125; setState(nextc); return true; &#125; //如果不是当前线程持有锁则获取失败 return false; &#125;&#125;//判断是否有前驱结点public final boolean hasQueuedPredecessors() &#123; Node t = tail; Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 调用公平锁的lock方法时会直接调用acquire方法。同样的，acquire方法首先会调用FairSync重写的tryAcquire方法来尝试获取锁。在该方法中也是首先获取同步状态的值，如果同步状态为0则表明此时锁刚好被释放，这时和非公平锁不同的是它会先去调用hasQueuedPredecessors方法查询同步队列中是否有人在排队，如果没人在排队才会去修改同步状态的值，可以看到公平锁在这里采取礼让的方式而不是自己马上去获取锁。除了这一步和非公平锁不一样之外，其他的操作都是一样的。综上所述，可以看到公平锁在进入同步队列之前只检查了一遍锁的状态，即使是发现了锁是开的也不会自己马上去获取，而是先让同步队列中的线程先获取，所以可以保证在公平锁下所有线程获取锁的顺序都是先来后到的，这也保证了获取锁的公平性。 那么为什么不希望所有锁都是公平的呢？毕竟公平是一种好的行为，而不公平是一种不好的行为。由于线程的挂起和唤醒操作存在较大的开销而影响系统性能，特别是在竞争激烈的情况下公平锁将导致线程频繁的挂起和唤醒操作，而非公平锁可以减少这样的操作，所以在性能上将会优于公平锁。另外，由于大部分线程使用锁的时间都是非常短暂的，而线程的唤醒操作会存在延时情况，有可能在A线程被唤醒期间B线程马上获取了锁并使用完释放了锁，这就导致了双赢的局面，A线程获取锁的时刻并没有推迟，但B线程提前使用了锁，并且吞吐量也获得了提高。 条件队列的实现机制内置条件队列存在一些缺陷，每个内置锁都只能有一个相关联的条件队列，这导致多个线程可能在同一个条件队列上等待不同的条件谓词，那么每次调用notifyAll时都会将所有等待的线程唤醒，当线程醒来后发现并不是自己等待的条件谓词，转而又会被挂起。这导致做了很多无用的线程唤醒和挂起操作，而这些操作将会大量浪费系统资源，降低系统的性能。如果想编写一个带有多个条件谓词的并发对象，或者想获得除了条件队列可见性之外的更多控制权，就需要使用显式的Lock和Condition而不是内置锁和条件队列。一个Condition和一个Lock关联在一起，就像一个条件队列和一个内置锁相关联一样。要创建一个Condition，可以在相关联的Lock上调用Lock.newCondition方法。下面看一个使用Condition的示例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package main.java.com.study.producerconsumer.v2;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * @author: whb * @description: 缓冲区 */public class ConditionBuffer &#123; private final Lock lock = new ReentrantLock(); /** * 不满 */ final Condition notFull = lock.newCondition(); /** * 不空 */ final Condition notEmpty = lock.newCondition(); /** * 缓冲区 */ final Object[] items = new Object[100]; int putptr, takeptr, count; //生产方法 public void put(Object x) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length) &#123; //队列已满, 线程在notFull队列上等待 notFull.await(); &#125; items[putptr] = x; if (++putptr == items.length) &#123; putptr = 0; &#125; ++count; //生产成功, 唤醒notEmpty队列的结点 notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; //消费方法 public Object take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0) &#123; //队列为空, 线程在notEmpty队列上等待 notEmpty.await(); &#125; Object x = items[takeptr]; if (++takeptr == items.length) &#123; takeptr = 0; &#125; --count; //消费成功, 唤醒notFull队列的结点 notFull.signal(); return x; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 一个lock对象可以产生多个条件队列，这里产生了两个条件队列notFull和notEmpty。当容器已满时再调用put方法的线程需要进行阻塞，等待条件谓词为真(容器不满)才醒来继续执行；当容器为空时再调用take方法的线程也需要阻塞，等待条件谓词为真(容器不空)才醒来继续执行。这两类线程是根据不同的条件谓词进行等待的，所以它们会进入两个不同的条件队列中阻塞，等到合适时机再通过调用Condition对象上的API进行唤醒。下面是newCondition方法的实现代码。 1234567891011//创建条件队列public Condition newCondition() &#123; return sync.newCondition();&#125;abstract static class Sync extends AbstractQueuedSynchronizer &#123; //新建Condition对象 final ConditionObject newCondition() &#123; return new ConditionObject(); &#125;&#125; ReentrantLock上的条件队列的实现都是基于AbstractQueuedSynchronizer的，在调用newCondition方法时所获得的Condition对象就是AQS的内部类ConditionObject的实例。所有对条件队列的操作都是通过调用ConditionObject对外提供的API来完成的。]]></content>
      <categories>
        <category>Java</category>
        <category>J.U.C</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J.U.C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-AQS源码分析之条件队列]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91-AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97.html</url>
    <content type="text"><![CDATA[通过之前的分析，深入了解了AbstractQueuedSynchronizer的内部结构和一些设计理念，知道了AbstractQueuedSynchronizer内部维护了一个同步状态和两个排队区，这两个排队区分别是同步队列和条件队列。拿ATM机取款举例，ATM机如下图所示： 同步队列是主要的排队区，如果ATM机没开放，所有想要进入人都得在这里排队。而条件队列主要是为条件等待设置的，想象一下如果一个人通过排队终于成功获取锁进入了ATM机，但在取款之前发现自己没带银行卡，碰到这种情况虽然很无奈，但是它也必须接受这个事实，这时它只好乖乖的出去先准备好银行卡(进入条件队列等待)，当然在出去之前还得把锁给释放了好让其他人能够进来，在准备好了银行卡(条件满足)之后它又得重新回到同步队列中去排队。当然进入房间的人并不都是因为没带银行卡，可能还有其他一些原因必须中断操作先去条件队列中去排队，所以条件队列可以有多个，依不同的等待条件而设置不同的条件队列。同步队列和条件队列的区别： 同步队列的头结点为head，而条件队列的头结点为firstWaiter; 同步队列的尾结点为tail，而条件队列的尾结点为lastWaiter; 同步队列的头结点没有和任何线程绑定，而条件队列的firstWaiter绑定了线程。 同步队列是一条双向链表，而条件队列是一条单向链表。 Condition接口定义了条件队列中的所有操作，AbstractQueuedSynchronizer内部的ConditionObject类实现了Condition接口，下面看看Condition接口都定义了哪些操作。 123456789101112131415161718192021222324public interface Condition &#123; //响应线程中断的条件等待 void await() throws InterruptedException; //不响应线程中断的条件等待 void awaitUninterruptibly(); //设置相对时间的条件等待(不进行自旋) long awaitNanos(long nanosTimeout) throws InterruptedException; //设置相对时间的条件等待(进行自旋) boolean await(long time, TimeUnit unit) throws InterruptedException; //设置绝对时间的条件等待 boolean awaitUntil(Date deadline) throws InterruptedException; //唤醒条件队列中的头结点 void signal(); //唤醒条件队列的所有结点 void signalAll(); &#125; Condition接口虽然定义了这么多方法，但总共就分为两类，以await开头的是线程进入条件队列等待的方法，以signal开头的是将条件队列中的线程“唤醒”的方法。需要注意的是，调用signal方法可能唤醒线程也可能不会唤醒线程，什么时候会唤醒线程这得看情况，但是调用signal方法一定会将线程从条件队列中移到同步队列尾部。await方法分为5种，分别是响应线程中断等待，不响应线程中断等待，设置相对时间不自旋等待，设置相对时间自旋等待，设置绝对时间等待；signal方法只有2种，分别是只唤醒条件队列头结点和唤醒条件队列所有结点的操作。同一类的方法基本上是相通的。 响应线程中断的条件等待123456789101112131415161718192021222324252627282930313233343536//响应线程中断的条件等待public final void await() throws InterruptedException &#123; //如果线程被中断则抛出异常 if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; //将当前线程包装秤结点添加到条件队列尾部 Node node = addConditionWaiter(); //在进入条件等待之前先完全释放锁 int savedState = fullyRelease(node); int interruptMode = 0; //线程一直在while循环里进行条件等待，直到线程被唤醒或者线程被中断并且进入同步队列中 while (!isOnSyncQueue(node)) &#123; //进行条件等待的线程都在这里被挂起, 线程被唤醒的情况有以下几种： //1.同步队列的前驱结点已取消 //2.设置同步队列的前驱结点的状态为SIGNAL失败 //3.前驱结点释放锁后唤醒当前结点 LockSupport.park(this); //当前线程醒来后立马检查是否被中断, 如果是则代表结点取消条件等待, 此时需要将结点移出条件队列 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) &#123; break; &#125; &#125; //线程醒来后就会以独占模式获取锁，如果获取时发生了中断，如果在调用await()方法时被中断，则依然是THROW_IE if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) &#123; interruptMode = REINTERRUPT; &#125; //这步操作主要为防止线程在signal之前中断而导致没与条件队列断绝联系 if (node.nextWaiter != null) &#123; unlinkCancelledWaiters(); &#125; //根据中断模式进行响应的中断处理 if (interruptMode != 0) &#123; reportInterruptAfterWait(interruptMode); &#125;&#125; 上述代码整个流程总结如下： 第一步：首先判断当前线程是否中断，如果被中断，则抛出异常，如果没有被中断，则继续下面的流程。第二步：通过调用addConditionWaiter()将当前线程封装成Node节点存放到Condition队列的尾部。第三步：因为当前线程已经获取了锁，所以调用await需要释放资源，所以通过调用fullyRelease()释放资源，也就是释放锁，因为这个锁是独占锁并且可以重入，所以要全部把资源释放，从fully字面上也可以理解。第四步：通过while循环判断当前线程是否在同步队列上，如果没有在同步队列上，则需要阻塞当前线程，然后调用checkInterruptWaiting()方法判断是否被中断过，如果被中断过，则跳出while循环。第五步：通过调用acquireQueued()方法获取资源，如果在调用这个方法时被中断，则中断类型变成REINTERRUPT(稍后处理中断)，这个方法返回值只是记录是否被中断过，并不会响应中断。第六步：如果是因为中断，此时waitStatus=0,但是此时它仍在条件队列中，所以需要从条件队列中清除。第七步：如果被中断，则调用reportInterruptAfterWait()方法处理不同的中断类型。 第一步：将线程添加到条件队列 1234567891011121314151617private Node addConditionWaiter() &#123; //获取条件队列尾结点 Node t = lastWaiter; // 如果尾结点被取消，则从条件队列中清除 if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; unlinkCancelledWaiters(); t = lastWaiter; &#125; //将当前线程包装成Node结点，并且waitStatus状态是CONDITION。 Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node;&#125; 将当前线程封装成Node节点，然后加入到Condition的尾部，在加入之前需要检查以下尾部节点t是否还在等待Condition条件，如果被signal或者被中断，则调用清除方法将尾节点从Condition队列中清除掉。 第二步：完全将锁释放 1234567891011121314151617181920212223//完全释放锁final int fullyRelease(Node node) &#123; //判断资源是否释放成功 boolean failed = true; try &#123; //获取当前的同步状态 int savedState = getState(); //使用当前的同步状态去释放锁 if (release(savedState)) &#123; failed = false; //如果释放锁成功就返回当前同步状态 return savedState; &#125; else &#123; //如果释放锁失败就抛出运行时异常 throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; //保证没有成功释放锁就将该结点设置为取消状态 if (failed) &#123; node.waitStatus = Node.CANCELLED; &#125; &#125;&#125; 将当前线程包装成结点添加到条件队列尾部后，紧接着就调用fullyRelease方法释放锁。注意，方法名为fullyRelease也就这步操作会完全的释放锁，因为锁是可重入的，所以在进行条件等待前需要将锁全部释放了，不然的话别人就获取不了锁了。如果释放锁失败的话就会抛出一个运行时异常，如果成功释放了锁的话就返回之前的同步状态。 第三步：进行条件等待 1234567891011121314151617181920212223242526272829303132333435363738//线程一直在while循环里进行条件等待while (!isOnSyncQueue(node)) &#123; //进行条件等待的线程都在这里被挂起, 线程被唤醒的情况有以下几种： //1.同步队列的前驱结点已取消 //2.设置同步队列的前驱结点的状态为SIGNAL失败 //3.前驱结点释放锁后唤醒当前结点 LockSupport.park(this); //当前线程醒来后立马检查是否被中断, 如果是则代表结点取消条件等待, 此时需要将结点移出条件队列 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) &#123; break; &#125;&#125;//检查条件等待时的线程中断情况private static final int REINTERRUPT = 1;private static final int THROW_IE = -1;private int checkInterruptWhileWaiting(Node node) &#123; //中断请求在signal操作之前：THROW_IE //中断请求在signal操作之后：REINTERRUPT //期间没有收到任何中断请求：0 return Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0;&#125;//将取消条件等待的结点从条件队列转移到同步队列中final boolean transferAfterCancelledWait(Node node) &#123; //如果这步CAS操作成功的话就表明中断发生在signal方法之前 if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123; //状态修改成功后就将该结点放入同步队列尾部 enq(node); return true; &#125; //到这里表明CAS操作失败, 说明中断发生在signal方法之后 while (!isOnSyncQueue(node)) &#123; //如果sinal方法还没有将结点转移到同步队列, 就通过自旋等待一下 Thread.yield(); &#125; return false;&#125; 在以上两个操作完成了之后就会进入while循环，可以看到while循环里面首先调用LockSupport.park(this)将线程挂起了，所以线程就会一直在这里阻塞。在调用signal方法后仅仅只是将结点从条件队列转移到同步队列中去，至于会不会唤醒线程需要看情况。如果转移结点时发现同步队列中的前驱结点已取消，或者是更新前驱结点的状态为SIGNAL失败，这两种情况都会立即唤醒线程，否则的话在signal方法结束时就不会去唤醒已在同步队列中的线程，而是等到它的前驱结点来唤醒。当然，线程阻塞在这里除了可以调用signal方法唤醒之外，线程还可以响应中断，如果线程在这里收到中断请求就会继续往下执行。可以看到线程醒来后会马上检查是否是由于中断唤醒的还是通过signal方法唤醒的，如果是因为中断唤醒的同样会将这个结点转移到同步队列中去，只不过是通过调用transferAfterCancelledWait方法来实现的。最后执行完这一步之后就会返回中断情况并跳出while循环。 第四步：结点移出条件队列 1234567891011121314151617181920212223//线程醒来后就会以独占模式获取锁if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) &#123; interruptMode = REINTERRUPT;&#125;//这步操作主要为防止线程在signal之前中断而导致没与条件队列断绝联系if (node.nextWaiter != null) &#123; unlinkCancelledWaiters();&#125;//根据中断模式进行响应的中断处理if (interruptMode != 0) &#123; reportInterruptAfterWait(interruptMode);&#125;//结束条件等待后根据中断情况做出相应处理private void reportInterruptAfterWait(int interruptMode) throws InterruptedException &#123; //如果中断模式是THROW_IE就抛出异常 if (interruptMode == THROW_IE) &#123; throw new InterruptedException(); //如果中断模式是REINTERRUPT就自己挂起 &#125; else if (interruptMode == REINTERRUPT) &#123; selfInterrupt(); &#125;&#125; 当线程终止了while循环也就是条件等待后，就会回到同步队列中。不管是因为调用signal方法回去的还是因为线程中断导致的，结点最终都会在同步队列中。这时就会调用acquireQueued方法执行在同步队列中获取锁的操作。也就是说，结点从条件队列出来后又是乖乖的走独占模式下获取锁的那一套，等这个结点再次获得锁之后，就会调用reportInterruptAfterWait方法来根据这期间的中断情况做出相应的响应。如果中断发生在signal方法之前，interruptMode就为THROW_IE，再次获得锁后就抛出异常；如果中断发生在signal方法之后，interruptMode就为REINTERRUPT，再次获得锁后就重新中断。 不响应线程中断的条件等待1234567891011121314151617181920212223//不响应线程中断的条件等待public final void awaitUninterruptibly() &#123; //将当前线程添加到条件队列尾部 Node node = addConditionWaiter(); //完全释放锁并返回当前同步状态 int savedState = fullyRelease(node); boolean interrupted = false; //结点一直在while循环里进行条件等待 while (!isOnSyncQueue(node)) &#123; //条件队列中所有的线程都在这里被挂起 LockSupport.park(this); //线程醒来发现中断并不会马上去响应 if (Thread.interrupted()) &#123; interrupted = true; &#125; &#125; if (acquireQueued(node, savedState) || interrupted) &#123; //在这里响应所有中断请求, 满足以下两个条件之一就会将自己挂起 //1.线程在条件等待时收到中断请求 //2.线程在acquireQueued方法里收到中断请求 selfInterrupt(); &#125;&#125; 设置相对时间的条件等待(不进行自旋)123456789101112131415161718192021222324252627282930313233343536373839404142434445//设置定时条件等待(相对时间), 不进行自旋等待public final long awaitNanos(long nanosTimeout) throws InterruptedException &#123; //如果线程被中断则抛出异常 if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; //将当前线程添加到条件队列尾部 Node node = addConditionWaiter(); //在进入条件等待之前先完全释放锁 int savedState = fullyRelease(node); long lastTime = System.nanoTime(); int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; //判断超时时间是否用完了 if (nanosTimeout &lt;= 0L) &#123; //如果已超时就需要执行取消条件等待操作 transferAfterCancelledWait(node); break; &#125; //将当前线程挂起一段时间, 线程在这期间可能被唤醒, 也可能自己醒来 LockSupport.parkNanos(this, nanosTimeout); //线程醒来后先检查中断信息 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) &#123; break; &#125; long now = System.nanoTime(); //超时时间每次减去条件等待的时间 nanosTimeout -= now - lastTime; lastTime = now; &#125; //线程醒来后就会以独占模式获取锁 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) &#123; interruptMode = REINTERRUPT; &#125; //由于transferAfterCancelledWait方法没有把nextWaiter置空, 所有这里要再清理一遍 if (node.nextWaiter != null) &#123; unlinkCancelledWaiters(); &#125; //根据中断模式进行响应的中断处理 if (interruptMode != 0) &#123; reportInterruptAfterWait(interruptMode); &#125; //返回剩余时间 return nanosTimeout - (System.nanoTime() - lastTime);&#125; 设置相对时间的条件等待(进行自旋)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//设置定时条件等待(相对时间), 进行自旋等待public final boolean await(long time, TimeUnit unit) throws InterruptedException &#123; if (unit == null) &#123; throw new NullPointerException(); &#125; //获取超时时间的毫秒数 long nanosTimeout = unit.toNanos(time); //如果线程被中断则抛出异常 if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; //将当前线程添加条件队列尾部 Node node = addConditionWaiter(); //在进入条件等待之前先完全释放锁 int savedState = fullyRelease(node); //获取当前时间的毫秒数 long lastTime = System.nanoTime(); boolean timedout = false; int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; //如果超时就需要执行取消条件等待操作 if (nanosTimeout &lt;= 0L) &#123; timedout = transferAfterCancelledWait(node); break; &#125; //如果超时时间大于自旋时间, 就将线程挂起一段时间 if (nanosTimeout &gt;= spinForTimeoutThreshold) &#123; LockSupport.parkNanos(this, nanosTimeout); &#125; //线程醒来后先检查中断信息 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) &#123; break; &#125; long now = System.nanoTime(); //超时时间每次减去条件等待的时间 nanosTimeout -= now - lastTime; lastTime = now; &#125; //线程醒来后就会以独占模式获取锁 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) &#123; interruptMode = REINTERRUPT; &#125; //由于transferAfterCancelledWait方法没有把nextWaiter置空, 所有这里要再清理一遍 if (node.nextWaiter != null) &#123; unlinkCancelledWaiters(); &#125; //根据中断模式进行响应的中断处理 if (interruptMode != 0) &#123; reportInterruptAfterWait(interruptMode); &#125; //返回是否超时标志 return !timedout;&#125; 设置绝对时间的条件等待1234567891011121314151617181920212223242526272829303132333435363738394041//设置定时条件等待(绝对时间)public final boolean awaitUntil(Date deadline) throws InterruptedException &#123; if (deadline == null) &#123; throw new NullPointerException(); &#125; //获取绝对时间的毫秒数 long abstime = deadline.getTime(); //如果线程被中断则抛出异常 if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; //将当前线程添加到条件队列尾部 Node node = addConditionWaiter(); //在进入条件等待之前先完全释放锁 int savedState = fullyRelease(node); boolean timedout = false; int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; //如果超时就需要执行取消条件等待操作 if (System.currentTimeMillis() &gt; abstime) &#123; timedout = transferAfterCancelledWait(node); break; &#125; //将线程挂起一段时间, 期间线程可能被唤醒, 也可能到了点自己醒来 LockSupport.parkUntil(this, abstime); //线程醒来后先检查中断信息 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) &#123; break; &#125; &#125; //线程醒来后就会以独占模式获取锁 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) &#123; interruptMode = REINTERRUPT; &#125; //由于transferAfterCancelledWait方法没有把nextWaiter置空, 所有这里要再清理一遍 if (node.nextWaiter != null) &#123; unlinkCancelledWaiters(); &#125; //根据中断模式进行响应的中断处理 if (interruptMode != 0) &#123; reportInterruptAfterWait(interruptMode); &#125; //返回是否超时标志 return !timedout;&#125; 唤醒条件队列中的头结点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//唤醒条件队列中的下一个结点public final void signal() &#123; //判断当前线程是否独占模式持有锁，如果不是则抛出异常 if (!isHeldExclusively()) &#123; throw new IllegalMonitorStateException(); &#125; //获取条件队列中的第一个结点 Node first = firstWaiter; //如果条件队列中有排队者 if (first != null) &#123; //唤醒条件队列中的头结点 doSignal(first); &#125;&#125;//唤醒条件队列中的头结点private void doSignal(Node first) &#123; do &#123; //1.将firstWaiter引用向后移动一位 if ( (firstWaiter = first.nextWaiter) == null) &#123; lastWaiter = null; &#125; //2.将头结点的后继结点引用置空 first.nextWaiter = null; //3.将头结点转移到同步队列, 转移完成后有可能唤醒线程 //4.如果transferForSignal操作失败就去唤醒下一个结点 &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null);&#125;//将指定结点从条件队列转移到同步队列中final boolean transferForSignal(Node node) &#123; //将等待状态从CONDITION设置为0 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123; //如果更新状态的操作失败就直接返回false //可能是transferAfterCancelledWait方法先将状态改变了, 导致这步CAS操作失败 return false; &#125; //将该结点添加到同步队列尾部，返回前驱结点 Node p = enq(node); int ws = p.waitStatus; if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) &#123; //出现以下情况就会唤醒当前线程 //1.前驱结点是取消状态 //2.更新前驱结点的状态为SIGNAL操作失败 LockSupport.unpark(node.thread); &#125; return true;&#125; 可以看到signal方法最终的核心就是去调用transferForSignal方法，在transferForSignal方法中首先会用CAS操作将结点的状态从CONDITION设置为0，然后再调用enq方法将该结点添加到同步队列尾部。我们再看到接下来的if判断语句，这个判断语句主要是用来判断什么时候会去唤醒线程，出现这两种情况就会立即唤醒线程，一种是当发现前驱结点的状态是取消状态时，还有一种是更新前驱结点的状态失败时。这两种情况都会马上去唤醒线程，否则的话就仅仅只是将结点从条件队列中转移到同步队列中就完了，而不会立马去唤醒结点中的线程。signalAll方法也大致类似，只不过它是去循环遍历条件队列中的所有结点，并将它们转移到同步队列，转移结点的方法也还是调用transferForSignal方法。 唤醒条件队列的所有结点1234567891011121314151617181920212223242526272829//唤醒条件队列后面的全部结点public final void signalAll() &#123; //判断当前线程是否持有锁 if (!isHeldExclusively()) &#123; throw new IllegalMonitorStateException(); &#125; //获取条件队列头结点 Node first = firstWaiter; if (first != null) &#123; //唤醒条件队列的所有结点 doSignalAll(first); &#125;&#125;//唤醒条件队列的所有结点private void doSignalAll(Node first) &#123; //先把头结点和尾结点的引用置空 lastWaiter = firstWaiter = null; do &#123; //先获取后继结点的引用 Node next = first.nextWaiter; //把即将转移的结点的后继引用置空 first.nextWaiter = null; //将结点从条件队列转移到同步队列 transferForSignal(first); //将引用指向下一个结点 first = next; &#125; while (first != null);&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>J.U.C</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J.U.C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-AQS源码分析之共享模式]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91-AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[AQS为在共享模式下获取锁分别提供三种获取方式： 不响应线程中断获取; 响应线程中断获取; 设置超时时间获取。 这三种方式整体步骤大致是相同的，只有少部分不同的地方：第一种方式，如果当前线程在获取资源时被中断了，它会忽略这个中断，当获取资源返回后才对中断进行处理;第二种方式则不同，如果当前线程获取资源时被中断，它会抛出中断异常;第三种方式在中断的基础上添加了超时返回的功能。 不响应线程中断的获取12345678910111213141516//以不可中断模式获取锁(共享模式)public final void acquireShared(int arg) &#123; //1.尝试去获取锁，如果获取成功，则流程结束 if (tryAcquireShared(arg) &lt; 0) &#123; //2.如果获取失败就进入这个方法：将当前线程包装成Node结点放入到同步队列尾部并按照条件判断是否挂起，等待被唤醒 doAcquireShared(arg); &#125;&#125;//尝试去获取锁(共享模式，该方法需要子类去实现，返回值需要遵循以下三个定义)//负数：表示获取失败//零值：表示当前结点获取成功, 但是后继结点不能再获取了//正数：表示当前结点获取成功, 并且后继结点同样可以获取成功protected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException();&#125; 调用acquireShared方法是不响应线程中断获取锁的方式。在该方法中，首先调用tryAcquireShared去尝试获取锁，tryAcquireShared方法返回一个获取锁的状态，这里AQS规定了返回状态若是负数代表当前结点获取锁失败，若是0代表当前结点获取锁成功，但后继结点不能再获取了，若是正数则代表当前结点获取锁成功，并且这个锁后续结点也同样可以获取成功。子类在实现tryAcquireShared方法获取锁的逻辑时，返回值需要遵守这个约定。如果调用tryAcquireShared的返回值小于0，就代表这次尝试获取锁失败了，接下来就调用doAcquireShared方法将当前线程添加进同步队列。下面看下doAcquireShared方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//在同步队列中获取(共享模式)private void doAcquireShared(int arg) &#123; //将当前线程包装成SHARED共享模式的结点添加到同步队列中 final Node node = addWaiter(Node.SHARED); //是否获取失败 boolean failed = true; try &#123; //是否中断 boolean interrupted = false; //自旋，判断什么时候能够尝试获取资源，什么时候能够挂起 for (;;) &#123; //获取当前结点的前驱结点 final Node p = node.predecessor(); //如果前驱结点为head结点就再次尝试去获取锁 if (p == head) &#123; //再次尝试去获取锁并返回获取状态 //r &lt; 0, 表示获取失败 //r = 0, 表示当前结点获取成功, 但是后继结点不能再获取了 //r &gt; 0, 表示当前结点获取成功, 并且后继结点同样可以获取成功 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; //到这里说明当前结点已经获取锁成功了, 此时它会将锁的状态信息传播给后继结点 setHeadAndPropagate(node, r); //帮助垃圾回收 p.next = null; //如果在线程阻塞期间收到中断请求, 就在这一步响应该请求 if (interrupted) &#123; selfInterrupt(); &#125; failed = false; return; &#125; &#125; //每次获取锁失败后都会判断是否可以将线程挂起, 如果可以的话就会在parkAndCheckInterrupt方法里将线程挂起 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123; interrupted = true; &#125; &#125; &#125; finally &#123; if (failed) &#123; cancelAcquire(node); &#125; &#125;&#125; 进入doAcquireShared方法首先是调用addWaiter方法将当前线程包装成结点放到同步队列尾部。这个添加结点的过程跟独占模式是一样的。结点进入同步队列后，如果它发现在它前面的结点就是head结点，因为head结点的线程已经获取锁进入房间里面了，那么下一个获取锁的结点就轮到自己了，所以当前结点先不会将自己挂起，而是再一次去尝试获取锁，如果前面那人刚好释放锁离开了，那么当前结点就能成功获得锁，如果前面那人还没有释放锁，那么就会调用shouldParkAfterFailedAcquire方法，在这个方法里面会将head结点的状态改为SIGNAL，只有保证前面结点的状态为SIGNAL，当前结点才能放心的将自己挂起，所有线程都会在parkAndCheckInterrupt方法里面被挂起。如果当前结点恰巧成功的获取了锁，那么接下来就会调用setHeadAndPropagate方法将自己设置为head结点，并且唤醒后面同样是共享模式的结点。下面看下setHeadAndPropagate方法具体的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//设置head结点并传播锁的状态(共享模式)private void setHeadAndPropagate(Node node, int propagate) &#123; //获取当前的头结点 Node h = head; //将给定的成功获取资源的结点设置为head结点 setHead(node); //有5个条件： //第一个条件：propagate&gt;0:这个值是通过调用tryAcquireShared()获取的，表示剩余的资源，上面说了state&gt;0表示获取资源成功，且还有剩余的资源。 //第二个条件：h==null：表示老的头结点head的引用为null。 //第三个条件：h.waitStatus&lt;0：老的头结点head的节点状态，有两种取值可能：SIGNAL(-1)和PROPAGATE(-3)。 //第四个条件：(h=head)==null //第五个条件：h.waitStatus&lt;0：新设置的头结点head的节点状态，有两种取值可能：SIGNAL(-1)和PROPAGATE(-3)。 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; //获取给定结点的后继结点 Node s = node.next; //如果给定结点的后继结点为空, 或者它的状态是共享状态 if (s == null || s.isShared()) &#123; //唤醒后继结点 doReleaseShared(); &#125; &#125;&#125;//释放锁的操作(共享模式)private void doReleaseShared() &#123; for (;;) &#123; //获取同步队列的head结点 Node h = head; if (h != null &amp;&amp; h != tail) &#123; //获取head结点的等待状态 int ws = h.waitStatus; //如果head结点的状态为SIGNAL, 表明后面有人在排队 if (ws == Node.SIGNAL) &#123; //先把head结点的等待状态更新为0 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) &#123; continue; &#125; //再去唤醒后继结点 unparkSuccessor(h); //如果head结点的状态为0, 表明此时后面没人在排队, 就只是将head状态修改为PROPAGATE &#125;else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) &#123; continue; &#125; &#125; //只有保证期间head结点没被修改过才能跳出循环 if (h == head) &#123; break; &#125; &#125;&#125; 调用setHeadAndPropagate方法首先将自己设置成head结点，然后再根据传入的tryAcquireShared方法的返回值来决定是否要去唤醒后继结点。前面已经讲到当返回值大于0就表明当前结点成功获取了锁，并且后面的结点也可以成功获取锁。这时当前结点就需要去唤醒后面同样是共享模式的结点，注意，每次唤醒仅仅只是唤醒后一个结点，如果后一个结点不是共享模式的话，当前结点就直接进入房间而不会再去唤醒更后面的结点了。共享模式下唤醒后继结点的操作是在doReleaseShared方法进行的，共享模式和独占模式的唤醒操作基本也是相同的，都是去找到自己座位上的牌子(等待状态)，如果牌子上为SIGNAL表明后面有人需要让它帮忙唤醒，如果牌子上为0则表明队列此时并没有人在排队。在独占模式下是如果发现没人在排队就直接离开队列了，而在共享模式下如果发现队列后面没人在排队，当前结点在离开前仍然会留个小纸条(将等待状态设置为PROPAGATE)告诉后来的人这个锁的可获取状态。那么后面来的人在尝试获取锁的时候可以根据这个状态来判断是否直接获取锁。 响应线程中断获取锁123456789101112131415161718192021222324252627282930313233343536373839404142//以可中断模式获取锁(共享模式)public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; //首先判断线程是否中断, 如果是则抛出异常 if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; //1.尝试去获取锁 if (tryAcquireShared(arg) &lt; 0) &#123; //2. 如果获取失败则进人该方法 doAcquireSharedInterruptibly(arg); &#125;&#125;//以可中断模式获取(共享模式)private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; //将当前结点插入同步队列尾部 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; //获取当前结点的前驱结点 final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123; //如果线程在阻塞过程中收到过中断请求, 那么就会立马在这里抛出异常 throw new InterruptedException(); &#125; &#125; &#125; finally &#123; if (failed) &#123; cancelAcquire(node); &#125; &#125;&#125; 响应线程中断获取锁的方式和不响应线程中断获取锁的方式在流程上基本是相同的，唯一的区别就是在哪里响应线程的中断请求。在不响应线程中断获取锁时，线程从parkAndCheckInterrupt方法中被唤醒，唤醒后就立马返回是否收到中断请求，即使是收到了中断请求也会继续自旋直到获取锁后才响应中断请求将自己给挂起。而响应线程中断获取锁会在线程被唤醒后立马响应中断请求，如果在阻塞过程中收到了线程中断就会立马抛出InterruptedException异常。 设置超时时间获取锁1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//以限定超时时间获取锁(共享模式)public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; //1.调用tryAcquireShared尝试去获取锁 //2.如果获取失败就调用doAcquireSharedNanos return tryAcquireShared(arg) &gt;= 0 || doAcquireSharedNanos(arg, nanosTimeout);&#125;//以限定超时时间获取锁(共享模式)private boolean doAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException &#123; long lastTime = System.nanoTime(); final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; //获取当前结点的前驱结点 final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; failed = false; return true; &#125; &#125; //如果超时时间用完了就结束获取, 并返回失败信息 if (nanosTimeout &lt;= 0) &#123; return false; &#125; //1.检查是否满足将线程挂起要求(保证前驱结点状态为SIGNAL) //2.检查超时时间是否大于自旋时间 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) &#123; //若满足上面两个条件就将当前线程挂起一段时间 LockSupport.parkNanos(this, nanosTimeout); &#125; long now = System.nanoTime(); //超时时间每次减去获取锁的时间 nanosTimeout -= now - lastTime; lastTime = now; //如果在阻塞时收到中断请求就立马抛出异常 if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; &#125; &#125; finally &#123; if (failed) &#123; cancelAcquire(node); &#125; &#125;&#125; 流程同前面两种获取锁的方式，主要是理解超时的机制是怎样的。如果第一次获取锁失败会调用doAcquireSharedNanos方法并传入超时时间，进入方法后会根据情况再次去获取锁，如果再次获取失败就要考虑将线程挂起了。这时会判断超时时间是否大于自旋时间，如果是的话就会将线程挂起一段时间，否则就继续尝试获取，每次获取锁之后都会将超时时间减去获取锁的时间，一直这样循环直到超时时间用尽，如果还没有获取到锁的话就会结束获取并返回获取失败标识。在整个期间线程是响应线程中断的。 共享模式下释放锁1234567891011121314151617181920212223242526272829303132333435363738394041424344//释放锁的操作(共享模式)public final boolean releaseShared(int arg) &#123; //1.尝试去释放锁 if (tryReleaseShared(arg)) &#123; //2.如果释放成功就唤醒其他线程 doReleaseShared(); return true; &#125; return false;&#125;//尝试去释放锁(共享模式)protected boolean tryReleaseShared(int arg) &#123; throw new UnsupportedOperationException();&#125;//释放锁的操作(共享模式)private void doReleaseShared() &#123; for (;;) &#123; //获取同步队列的head结点 Node h = head; //判断队列中是否有结点 if (h != null &amp;&amp; h != tail) &#123; //获取head结点的等待状态 int ws = h.waitStatus; //如果head结点的状态为SIGNAL, 表明后面有人在排队 if (ws == Node.SIGNAL) &#123; //先把head结点的等待状态更新为0（有两个地方调用这个方法） if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) &#123; continue; &#125; //再去唤醒后继结点 unparkSuccessor(h); //如果head结点的状态为0, 表明此时后面没人在排队, 就只是将head状态修改为PROPAGATE &#125;else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) &#123; continue; &#125; &#125; //只有保证期间head结点没被修改过才能跳出循环 if (h == head) &#123; break; &#125; &#125;&#125; 线程在房间办完事之后就会调用releaseShared方法释放锁，首先调用tryReleaseShared方法尝试释放锁，该方法的判断逻辑由子类实现。如果释放成功就调用doReleaseShared方法去唤醒后继结点。走出房间后它会找到原先的座位(head结点)，看看座位上是否有人留了小纸条(状态为SIGNAL)，如果有就去唤醒后继结点。如果没有(状态为0)就代表队列没人在排队，那么在离开之前它还要做最后一件事情，就是在自己座位上留下小纸条(状态设置为PROPAGATE)，告诉后面的人锁的获取状态，整个释放锁的过程和独占模式唯一的区别就是在这最后一步操作。 PS：上面说了doReleaseShared()的代码流程，这个方法有两处地方调用： 第一处调用的地方：刚刚释放资源的老的head调用，在代码中就是releaseShared()方法中调用。 第二处调用的地方：刚刚设置新的头结点head调用，在代码中就是setHeadAndPropagate()方法中调用。 上面的方法看到head节点的状态要么是SIGNAL(SIGNAL——&gt;0),要么是0(0——&gt;PROPAGATE)，这些状态怎样来的？ 状态为SIGNAL的由来：头结点的后继节点被挂起了，挂起的同时会将它的前驱节点状态置为SIGNAL，以便于被唤醒。 状态为0的由来：这个状态是默认状态，后继节点没有被挂起就尝试获取资源成功了，此时并没有调用判断挂起的方法，所以头结点的状态没有变化。 第一个分析的重点：如果只有刚刚释放资源的老的head调用了此方法，这个时候没有竞争，如果头结点head的waitStatus等于SIGNAL，则首先将SIGNAL——&gt;0,如果成功则调用unparkSuccessor()方法唤醒下一个节点。如果头结点head的waitStatus等于0，则将0——&gt;PROPAGATE,不成功则继续循环。 第二个分析的重点：如果刚刚释放资源的老head，和刚获取资源设置新的头结点的head同时调用这个方法，那么两者获取的head可能有所不同，前者老head获取的h可能是自己，也可能是新的head，后者新head获取的h一定是自己。但是不管head获取的是老的，还是新的，都能够顺利的唤醒下一个节点，只不过可能多唤醒一次而已，这并不影响结果。 第三个分析的重点：最后为什么会判断h==head？如果头结点head发生变化，可能其他线程获取了资源把head改变了，为了使自己的唤醒动作传递，必须重试。 其实doReleaseShared()方法就是能够保证唤醒下面的节点，并且能够传递下去。]]></content>
      <categories>
        <category>Java</category>
        <category>J.U.C</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J.U.C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-AQS源码分析之独占模式]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91-AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[AQS为在独占模式下获取锁分别提供三种获取方式： 不响应线程中断获取; 响应线程中断获取; 设置超时时间获取。 这三种方式整体步骤大致是相同的，只有少部分不同的地方：第一种在获取时会忽略中断;而第二种则是获取时响应中断;第三种是获取时，如果超时则立即返回。 不响应线程中断获取锁123456//不响应中断方式获取(独占模式)public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123; selfInterrupt(); &#125;&#125; acquire方法是获取锁的基础，这个方法会忽略中断，意思是说如果节点对应的线程中断，则acquire()方法会忽略，只有从同步队列中返回true才最终调用selfInterrupt方法响应中断。代码很简单，但是它按照顺序执行了下图所示的4个步骤。 第一步：!tryAcquire(arg) 尝试获取资源state 1234//尝试获取锁（独占模式）protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; 这时候来了一个人，他首先尝试着去敲了敲门，如果发现门没锁(tryAcquire(arg)=true)，那就直接进去了。如果发现门锁了(tryAcquire(arg)=false)，就执行下一步。这个tryAcquire方法决定了什么时候锁是开着的，什么时候锁是关闭的。这个方法必须要让子类去覆盖，重写里面的判断逻辑。 第二步：addWaiter(Node.EXCLUSIVE) 获取资源失败，则封装成Node结点加入到同步队列中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//将当前线程包装成结点并添加到同步队列尾部private Node addWaiter(Node mode) &#123; //指定持有锁的模式 Node node = new Node(Thread.currentThread(), mode); //获取同步队列尾结点引用 Node pred = tail; //如果尾结点不为空, 表明同步队列已存在结点 if (pred != null) &#123; //1.指向当前尾结点 node.prev = pred; //2.设置当前结点为尾结点（由于是多线程，可能并发修改尾结点，所以通过CAS修改） if (compareAndSetTail(pred, node)) &#123; //3.将旧的尾结点的后继指向新的尾结点 pred.next = node; return node; &#125; &#125; //否则表明同步队列是空的，还没有进行初始化 enq(node); return node;&#125;//结点入队操作private Node enq(final Node node) &#123; for (;;) &#123; //获取同步队列尾结点引用 Node t = tail; //如果尾结点为空说明同步队列还没有初始化 if (t == null) &#123; //初始化同步队列（调用无参构造器创建一个结点，然后通过CAS设置head结点，如果成功则将头结点head赋值给tail结点） if (compareAndSetHead(new Node())) &#123; tail = head; &#125; &#125; else &#123; //1.指向当前尾结点 node.prev = t; //2.设置当前结点为尾结点 if (compareAndSetTail(t, node)) &#123; //3.将旧的尾结点的后继指向新的尾结点 t.next = node; return t; &#125; &#125; &#125;&#125; 执行到这一步表明第一次获取锁失败，那么这个人就给自己领了块号码牌进入排队区去排队了，在领号码牌的时候会声明自己想要以什么样的方式来占用房间(独占模式or共享模式)。注意，这时候他并没有坐下来休息(将自己挂起)。 第三步：acquireQueued(addWaiter(Node.EXCLUSIVE), arg) 在同步队列中获取资源。其实这个方法非常的好理解，前面已经尝试获取资源，但是失败了，并且加到了同步队列中，在等待中可以判断自己是否可以休息以下，如果可以休息，那就等待着其他线程唤醒自己，在继续获取资源，直到成功才返回。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//以不可中断方式获取锁(独占模式)final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; //判断是否中断的标记 boolean interrupted = false; //自旋 for (;;) &#123; //获取给定结点的前驱结点的引用 final Node p = node.predecessor(); //如果当前结点的前驱结点是头结点head，就尝试去获取锁 if (p == head &amp;&amp; tryAcquire(arg)) &#123; //说明获取成功，将给定结点设置为head结点 setHead(node); //为了帮助垃圾收集, 将上一个head结点的后继清空 p.next = null; //设置获取成功状态 failed = false; //返回中断的状态, 整个循环执行到这里才是出口 return interrupted; &#125; //否则说明锁的状态还是不可获取, 这时判断是否可以挂起当前线程 //第一个条件：如果获取锁失败，判断是否应该休息 //第二个条件：第一个条件为true，说明自己可以休息了则调用park方法休息 //如果判断结果为真则挂起当前线程, 否则继续循环, 在这期间线程不响应中断 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123; interrupted = true; &#125; &#125; &#125; finally &#123; //在最后确保如果获取失败就取消获取 if (failed) &#123; cancelAcquire(node); &#125; &#125;&#125;//判断是否可以将当前结点挂起private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; //获取前驱结点的等待状态 int ws = pred.waitStatus; //如果前驱结点状态为SIGNAL, 表明前驱结点会唤醒当前结点, 所以当前结点可以安心的挂起了 if (ws == Node.SIGNAL) &#123; return true; &#125; //节点状态只有CANCEL(-1)时才大于0，说明这个节点取消了。那就需要把取消的节点从同步队列中移除掉 if (ws &gt; 0) &#123; //下面的操作是清理同步队列中所有已取消的前驱结点 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; //到这里表示前驱结点状态不是SIGNAL也不是CANCEL, 很可能还是等于0, 这样的话前驱结点就不会去唤醒当前结点了 //所以当前结点必须要确保前驱结点的状态为SIGNAL才能安心的挂起自己 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125;//挂起当前线程private final boolean parkAndCheckInterrupt() &#123; //挂起当前线程 LockSupport.park(this); //返回当前线程是否被中断过 return Thread.interrupted();&#125; 领完号码牌进入排队区后就会立马执行这个方法，当一个结点首次进入排队区后有两种情况，一种是发现他前面的那个人已经离开座位进入房间了，那他就不坐下来休息了，会再次去敲一敲门看看那小子有没有完事。如果里面的人刚好完事出来了，都不用他叫自己就直接冲进去了。否则，就要考虑坐下来休息一会儿了，但是他还是不放心，如果他坐下来睡着后没人提醒他怎么办？他就在前面那人的座位上留一个小纸条，好让从里面出来的人看到纸条后能够唤醒他。还有一种情况是，当他进入排队区后发现前面还有好几个人在座位上排队呢，那他就可以安心的坐下来咪一会儿了，但在此之前他还是会在前面那人(此时已经睡着了)的座位上留一个纸条，好让这个人在走之前能够去唤醒自己。当一切事情办妥了之后，他就安安心心的睡觉了，注意，我们看到整个for循环就只有一个出口，那就是等线程成功的获取到锁之后才能出去，在没有获取到锁之前就一直是挂在for循环的parkAndCheckInterrupt()方法里头。线程被唤醒后也是从这个地方继续执行for循环。 第四步：selfInterrupt() 1234//当前线程将自己中断private static void selfInterrupt() &#123; Thread.currentThread().interrupt();&#125; 由于上面整个线程一直是挂在for循环的parkAndCheckInterrupt()方法里头，没有成功获取到锁之前不响应任何形式的线程中断，只有当线程成功获取到锁并从for循环出来后，他才会查看在这期间是否有人要求中断线程，如果是的话再去调用selfInterrupt()方法将自己挂起。 响应线程中断获取锁123456789 public final void acquireInterruptibly(int arg) throws InterruptedException &#123; //首先判断线程是否中断过，如果被中断则直接抛出异常 if (Thread.interrupted()) throw new InterruptedException(); //如果没有被中断过，则尝试获取资源 if (!tryAcquire(arg)) //说明获取资源失败，则需要加入到同步队列，在同步队列中获取资源 doAcquireInterruptibly(arg);&#125; 1234567891011121314151617181920212223242526272829//以可中断模式获取锁(独占模式)private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; //将当前线程包装成结点添加到同步队列中 final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; //获取当前结点的前驱结点 final Node p = node.predecessor(); //如果p是head结点, 那么当前线程就再次尝试获取锁 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; //获取锁成功后返回 return; &#125; //如果满足条件就挂起当前线程, 此时响应中断并抛出异常 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) &#123; //线程被唤醒后如果发现中断请求就抛出异常 throw new InterruptedException(); &#125; &#125; &#125; finally &#123; if (failed) &#123; cancelAcquire(node); &#125; &#125;&#125; 响应线程中断方式和不响应线程中断方式获取锁流程上大致上是相同的。唯一的一点区别就是线程从parkAndCheckInterrupt方法中醒来后会检查线程是否中断，如果是的话就抛出InterruptedException异常，而不响应线程中断获取锁是在收到中断请求后只是设置一下中断状态，并不会立马结束当前获取锁的方法，一直到结点成功获取到锁之后才会根据中断状态决定是否将自己挂起。 设置超时时间获取锁12345678public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; ////判断是否被中断过，如果中断过直接抛异常 if (Thread.interrupted()) throw new InterruptedException(); ////尝试获取资源，如果失败添加到同步队列中，从同步队列中获取资源 return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445//以限定超时时间获取锁(独占模式)private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; //获取系统当前时间 long lastTime = System.nanoTime(); //将当前线程包装成结点添加到同步队列中 final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; //获取当前结点的前驱结点 final Node p = node.predecessor(); //如果前驱是head结点, 那么当前线程就再次尝试获取锁 if (p == head &amp;&amp; tryAcquire(arg)) &#123; //更新head结点 setHead(node); p.next = null; failed = false; return true; &#125; //超时时间用完了就直接退出循环 if (nanosTimeout &lt;= 0) &#123; return false; &#125; //如果超时时间大于自旋时间, 那么等判断可以挂起线程之后就会将线程挂起一段时间 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) &#123; //将当前线程挂起一段时间, 之后再自己醒来 LockSupport.parkNanos(this, nanosTimeout); &#125; //获取系统当前时间 long now = System.nanoTime(); //超时时间每次都减去获取锁的时间间隔 nanosTimeout -= now - lastTime; //再次更新lastTime lastTime = now; //在获取锁的期间收到中断请求就抛出异常 if (Thread.interrupted()) &#123; throw new InterruptedException(); &#125; &#125; &#125; finally &#123; if (failed) &#123; cancelAcquire(node); &#125; &#125;&#125; 设置超时时间获取首先会去获取一下锁，第一次获取锁失败后会根据情况，如果传入的超时时间大于自旋时间那么就会将线程挂起一段时间，否则的话就会进行自旋，每次获取锁之后都会将超时时间减去获取一次锁所用的时间。一直到超时时间小于0也就说明超时时间用完了，那么这时就会结束获取锁的操作然后返回获取失败标志。注意在以超时时间获取锁的过程中是可以响应线程中断请求的。 独占模式下释放锁1234567891011121314151617181920212223242526272829303132333435363738394041//释放锁的操作(独占模式)public final boolean release(int arg) &#123; //尝试释放（该方法需要子类去实现） if (tryRelease(arg)) &#123; //尝试成功，获取head结点 Node h = head; //如果head结点不为空并且等待状态不等于0就去唤醒后继结点 if (h != null &amp;&amp; h.waitStatus != 0) &#123; //唤醒后继结点 unparkSuccessor(h); &#125; return true; &#125; return false;&#125;//唤醒后继结点private void unparkSuccessor(Node node) &#123; //获取给定结点的等待状态 int ws = node.waitStatus; //如果状态小于0，通过CAS将状态更新为0，因为此时给定的结点释放资源 if (ws &lt; 0) &#123; compareAndSetWaitStatus(node, ws, 0); &#125; //获取给定结点的后继结点，即下一个需要被唤醒的结点 Node s = node.next; //后继结点为空或者等待状态为取消状态 if (s == null || s.waitStatus &gt; 0) &#123; s = null; //从后向前遍历队列找到第一个不是取消状态的结点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) &#123; if (t.waitStatus &lt;= 0) &#123; s = t; &#125; &#125; &#125; //唤醒给定结点后面首个不是取消状态的结点 if (s != null) &#123; LockSupport.unpark(s.thread); &#125;&#125; 线程持有锁进入房间后就会去办自己的事情，等事情办完后它就会释放锁并离开房间。通过tryRelease方法可以拨动密码锁进行解锁，tryRelease方法是需要让子类去覆盖的，不同的子类实现的规则不一样，也就是说不同的子类设置的密码不一样。像在ReentrantLock当中，房间里面的人每调用tryRelease方法一次，state就减1，直到state减到0的时候密码锁就开了。这个过程就像在不停的转动密码锁的转轮，而每次转动转轮数字只是减少1。CountDownLatch和这个也有点类似，只不过它不是一个人在转，而是多个人每人都去转一下，集中大家的力量把锁给开了。线程出了房间后它会找到自己原先的座位，也就是找到head结点。看看座位上有没有人给它留了小纸条，如果有的话它就知道有人睡着了需要让它帮忙唤醒，那么它就会去唤醒那个线程。如果没有的话就表明同步队列中暂时还没有人在等待，也没有人需要它唤醒，所以它就可以安心的离去了。]]></content>
      <categories>
        <category>Java</category>
        <category>J.U.C</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J.U.C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发-AQS源码分析之概要分析]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91-AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%A6%82%E8%A6%81%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[AbstractQueuedSynchronizer是做什么的java.util.concurrent这个包下有很多类，比如ReentrantLock、CountDownLatch、CyclicBarrrier、Semaphore等，它们的实现中都有一个内部类Sync，这个类继承了AbstractQueuedSynchronizer（简称AQS），所有的锁机制的实现都依赖于Sync内部类，也可以说这些类的实现就是依赖于AQS。那么AQS内部到底实现了什么以至于这些类都要依赖于它呢？可以这样说，AQS为这些类提供了基础设施，也就是提供了一个密码锁，这些类拥有了密码锁之后可以自己来设置密码锁的密码。此外，AQS还提供了一个排队区，并且提供了一个线程训导员，我们知道线程就像一个原始的野蛮人，它不懂得讲礼貌，它只会横冲直撞，所以你得一步一步去教它，告诉它什么时候需要去排队了，要到哪里去排队，排队前要做些什么，排队后要做些什么。这些教化工作全部都由AQS帮你完成了，从它这里教化出来的线程都变的非常文明懂礼貌，不再是原始的野蛮人，所以以后我们只需要和这些文明的线程打交道就行了，千万不要和原始线程有过多的接触！ 为何说AQS提供了一把密码锁1234567891011121314151617181920212223//同步队列的头结点private transient volatile Node head; //同步队列的尾结点private transient volatile Node tail;//同步状态private volatile int state;//获取同步状态protected final int getState() &#123; return state;&#125;//设置同步状态protected final void setState(int newState) &#123; state = newState;&#125;//以CAS方式设置同步状态protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; 上面的代码列出了AQS的所有成员变量，可以看到AQS的成员变量只有三个，分别是同步队列头结点引用，同步队列尾结点引用以及同步状态。注意，这三个成员变量都使用了volatile关键字进行修饰，这就确保了多个线程对它的修改都是内存可见的。整个类的核心就是这个同步状态，可以看到同步状态其实就是一个int型的变量，大家可以把这个同步状态看成一个密码锁，而且还是从房间里面锁起来的密码锁，state具体的值就相当于密码控制着密码锁的开合。当然这个锁的密码是多少就由各个子类来规定了，例如在ReentrantLock中，state等于0表示锁是开的，state大于0表示锁是锁着的，而在Semaphore中，state大于0表示锁是开的，state等于0表示锁是锁着的。 AQS的排队区是怎样实现的 AQS内部其实有两个排队区，一个是同步队列，一个是条件队列。从上图可以看出，同步队列只有一条，而条件队列可以有多条。同步队列的结点分别持有前后结点的引用，而条件队列的结点只有一个指向后继结点的引用。图中T表示线程，每个结点包含一个线程，线程在获取锁失败后首先进入同步队列排队，而想要进入条件队列该线程必须持有锁才行。接下来看看队列中每个结点的结构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//同步队列的结点static final class Node &#123; static final Node SHARED = new Node(); //表示当前线程以共享模式持有锁 static final Node EXCLUSIVE = null; //表示当前线程以独占模式持有锁 static final int CANCELLED = 1; //表示当前结点已经取消获取锁 static final int SIGNAL = -1; //表示后继结点的线程需要运行 static final int CONDITION = -2; //表示当前结点在条件队列中排队 static final int PROPAGATE = -3; //表示后继结点可以直接获取锁(PROPAGATE为下一个acquireShared无条件传播的状态，用于共享模式) volatile int waitStatus; //表示当前结点的等待状态（默认值为0） volatile Node prev; //表示同步队列中的前驱结点 volatile Node next; //表示同步队列中的后继结点 volatile Thread thread; //当前结点持有的线程引用 Node nextWaiter; //表示条件队列中的后继结点 /** * 当前结点状态是否是共享模式 */ final boolean isShared() &#123; return nextWaiter == SHARED; &#125; /** * 返回当前结点的前驱结点 */ final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) &#123; throw new NullPointerException(); &#125; else &#123; return p; &#125; &#125; /** * 空构造函数：主要用于初始化头结点(head)或者创建共享模式 */ Node() &#123;&#125; /** * 默认用这个构造器（主要用于把节点添加到队列中） * * @param thread 当前线程 * @param mode 结点模式 */ Node(Thread thread, Node mode) &#123; //注意持有模式是赋值给nextWaiter this.nextWaiter = mode; this.thread = thread; &#125; /** * 只在条件队列中用到 * * @param thread 当前线程 * @param waitStatus 结点状态 */ Node(Thread thread, int waitStatus) &#123; this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; Node代表同步队列和条件队列中的一个结点，它是AQS的内部类。Node有很多属性，比如持有模式，等待状态，同步队列中的前驱和后继，以及条件队列中的后继引用等等。可以把同步队列和条件队列看成是排队区，每个结点看成是排队区的座位，将线程看成是排队的客人。客人刚来时会先去敲敲门，看看锁有没有开，如果锁没开它就会去排队区领取一个号码牌，声明自己想要以什么样的方式来持有锁，最后再到队列的末尾进行排队。 怎样理解独占模式和共享模式前面讲到每个客人在排队前会领取一个号码牌，声明自己想要以什么样的方式来占有锁，占有锁的方式分为独占模式和共享模式，那么怎样来理解独占模式和共享模式呢？打个比方，大家联想一下去食堂吃饭，正好有一个桌子空着，独占模式的人比较霸道，老子要么就不坐，坐下来就不允许别人坐，自己一个人独自占用整个桌子。共享模式的人就没那么讲究了，当它发现这个桌子可以用，自己坐下还不算，还得热心的问下后面的人介不介意一起，如果后面的人不介意一起那就不用再排队了， 当然如果后面的人介意那就只好留在队列里继续排队了。 怎样理解结点的等待状态每个结点都有一个等待状态，这个等待状态分为CANCELLED，SIGNAL，CONDITION，PROPAGATE四种状态。可以将这个等待状态看作是挂在座位旁边的牌子，标识当前座位上的人的等待状态。这个牌子的状态不仅自己可以修改，其他人也可以修改。例如当这个线程在排队过程中已经打算放弃了，它就会将自己座位上的牌子设置为CANCELLED，这样其他人看到了就可以将它清理出队列。还有一种情况是，当线程在座位上要睡着之前，它怕自己睡过了头，就会将前面位置上的牌子改为SIGNAL，因为每个人在离开队列前都会回到自己座位上看一眼，如果看到牌子上状态为SIGNAL，它就会去唤醒下一个人。只有保证前面位置上的牌子为SIGNAL，当前线程才会安心的睡去。CONDITION状态表示该线程在条件队列中排队，PROPAGATE状态提醒后面来的线程可以直接获取锁，这个状态只在共享模式用到。 结点进入同步队列时会进行哪些操作123456789101112131415161718192021222324//结点入队操作, 返回前一个结点private Node enq(final Node node) &#123; for (;;) &#123; //获取同步队列尾结点引用 Node t = tail; //如果尾结点为空说明同步队列还没有初始化 if (t == null) &#123; //初始化同步队列 if (compareAndSetHead(new Node())) &#123; tail = head; &#125; &#125; else &#123; //1.指向当前尾结点 node.prev = t; //2.设置当前结点为尾结点 if (compareAndSetTail(t, node)) &#123; //3.将旧的尾结点的后继指向新的尾结点 t.next = node; //for循环唯一的出口 return t; &#125; &#125; &#125;&#125; 注意，入队操作使用一个死循环，只有成功将结点添加到同步队列尾部才会返回，返回结果是同步队列原先的尾结点。下图演示了整个操作过程。 添加尾结点的顺序，分为三步：指向尾结点，CAS更改尾结点，将旧尾结点的后继指向当前结点。在并发环境中这三步操作不一定能保证完成，所以在清空同步队列所有已取消的结点这一操作中，为了寻找非取消状态的结点，不是从前向后遍历而是从后向前遍历的。还有就是每个结点进入队列中时它的等待状态是为0，只有后继结点的线程需要挂起时才会将前面结点的等待状态改为SIGNAL。]]></content>
      <categories>
        <category>Java</category>
        <category>J.U.C</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J.U.C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型-内容总结]]></title>
    <url>%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[处理器内存模型顺序一致性内存模型是一个理论参考模型，JMM 和处理器内存模型在设计时通常会把顺序一致性内存模型作为参照。JMM 和处理器内存模型在设计时会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和 JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。 根据对不同类型读 / 写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为下面几种类型： 放松程序中写 - 读操作的顺序，由此产生了 total store ordering 内存模型（简称为 TSO）。 在前面 1 的基础上，继续放松程序中写 - 写操作的顺序，由此产生了 partial store order 内存模型（简称为 PSO）。 在前面 1 和 2 的基础上，继续放松程序中读 - 写和读 - 读操作的顺序，由此产生了 relaxed memory order 内存模型（简称为 RMO）和 PowerPC 内存模型。 注意，这里处理器对读 / 写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守 as-if-serial 语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。 常见处理器内存模型的细节特征： 内存模型名称 对应的处理器 Store-Load重排序 Store-Store重排序 Load-Load和Load-Store重排序 可以更早读取到其他处理器的写 可以更早读取到当前处理器的写 TSO sparc-TSO X64 Y Y PSO sparc-PSO Y Y Y RMO ia64 Y Y Y Y PowerPC PowerPC Y Y Y Y Y 在这个表格中，可以看到所有处理器内存模型都允许写 - 读重排序，原因：它们都使用了写缓存区，写缓存区可能导致写 - 读操作重排序。同时，可以看到这些处理器内存模型都允许更早读到当前处理器的写，原因同样是因为写缓存区：由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己的写缓存区中的写。 上面表格中的各种处理器内存模型，从上到下，模型由强变弱。越是追求性能的处理器，内存模型设计的会越弱。因为这些处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。 由于常见的处理器内存模型比 JMM 要弱，java 编译器在生成字节码时，会在执行指令序列的适当位置插入内存屏障来限制处理器的重排序。同时，由于各种处理器内存模型的强弱并不相同，为了在不同的处理器平台向程序员展示一个一致的内存模型，JMM 在不同的处理器中需要插入的内存屏障的数量和种类也不相同。下图展示了 JMM 在不同处理器内存模型中需要插入的内存屏障的示意图： 如上图所示，JMM 屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为 java 程序员呈现了一个一致的内存模型。 JMM、处理器内存模型与顺序一致性内存模型之间的关系JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图： 从上图可以看出：常见的 4 种处理器内存模型比常用的 3 中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计的会越弱。 JMM的设计从 JMM 设计者的角度来说，在设计 JMM 时，需要考虑两个关键因素： 程序员对内存模型的使用。程序员希望内存模型易于理解，易于编程。程序员希望基于一个强内存模型来编写代码。 编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。 由于这两个因素互相矛盾，所以 JSR-133 专家组在设计 JMM 时的核心目标就是找到一个好的平衡点：一方面要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能的放松。 JSR-133 是如何实现这一目标的？答案是：happens-before规则。JMM 把 happens- before 要求禁止的重排序分为了下面两类： 会改变程序执行结果的重排序。不会改变程序执行结果的重排序。 JMM 对这两种不同性质的重排序，采取了不同的策略： 对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不作要求（JMM 允许这种重排序） 下面是 JMM 的设计示意图： 从上图可以看出两点： JMM 向程序员提供的 happens- before 规则能满足程序员的需求。JMM 的 happens- before 规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证。JMM 对编译器和处理器的束缚已经尽可能的少。JMM 其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再比如，如果编译器经过细致的分析后，认定一个 volatile 变量仅仅只会被单个线程访问，那么编译器可以把这个 volatile 变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。 JMM内存可见性保证Java 程序的内存可见性保证按程序类型可以分为下列三类： 单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。 正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，JMM 通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。 未同步 / 未正确同步的多线程程序。JMM 为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。 下图展示了这三类程序在 JMM 中与在顺序一致性内存模型中的执行结果的异同： 只要多线程程序是正确同步的，JMM 保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。]]></content>
      <categories>
        <category>Java</category>
        <category>JMM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型-理解final]]></title>
    <url>%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%90%86%E8%A7%A3final.html</url>
    <content type="text"><![CDATA[与锁和 volatile 相比较，对 final 域的读和写更像是普通的变量访问。对于 final 域，编译器和处理器要遵守两个重排序规则： 在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。 初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。 示例代码： 1234567891011121314151617181920public class FinalExample &#123; int i; // 普通变量 final int j; //final 变量 static FinalExample obj; public void FinalExample () &#123; // 构造函数 i = 1; // 写普通域 j = 2; // 写 final 域 &#125; public static void writer () &#123; // 写线程 A 执行 obj = new FinalExample (); &#125; public static void reader () &#123; // 读线程 B 执行 FinalExample object = obj; // 读对象引用 int a = object.i; // 读普通域 int b = object.j; // 读 final 域 &#125;&#125; 这里假设一个线程 A 执行 writer () 方法，随后另一个线程 B 执行 reader () 方法。 写final域的重排序规则写 final 域的重排序规则禁止把 final 域的写重排序到构造函数之外。这个规则的实现包含下面 2 个方面： JMM 禁止编译器把 final 域的写重排序到构造函数之外。 编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。 现在分析 writer () 方法：finalExample = new FinalExample ()。这行代码包含两个步骤： 构造一个 FinalExample 类型的对象； 把这个对象的引用赋值给引用变量 obj。 假设线程 B 读对象引用与读对象的成员域之间没有重排序，下图是一种可能的执行时序： 在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程 B 错误的读取了普通变量 i 初始化之前的值。而写 final 域的操作，被写 final 域的重排序规则“限定”在了构造函数之内，读线程 B 正确的读取了 final 变量初始化之后的值。 写 final 域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域不具有这个保障。以上图为例，在读线程 B“看到”对象引用 obj 时，很可能 obj 对象还没有构造完成（对普通域 i 的写操作被重排序到构造函数外，此时初始值 2 还没有写入普通域 i）。 读final域的重排序规则 在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。 初次读对象引用与初次读该对象包含的 final 域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，大多数处理器也不会重排序这两个操作。但有少数处理器允许对存在间接依赖关系的操作做重排序（比如 alpha 处理器），这个规则就是专门用来针对这种处理器。 reader() 方法包含三个操作： 初次读引用变量 obj; 初次读引用变量 obj 指向对象的普通域 j。 初次读引用变量 obj 指向对象的 final 域 i。 现在假设写线程 A 没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，下面是一种可能的执行时序： 在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程 A 写入，这是一个错误的读取操作。而读 final 域的重排序规则会把读对象 final 域的操作“限定”在读对象引用之后，此时该 final 域已经被 A 线程初始化过了，这是一个正确的读取操作。 读 final 域的重排序规则可以确保：在读一个对象的 final 域之前，一定会先读包含这个 final 域的对象的引用。在这个示例程序中，如果该引用不为 null，那么引用对象的 final 域一定已经被 A 线程初始化过了。 final域是引用类型1234567891011121314151617181920212223public class FinalReferenceExample &#123; final int[] intArray; //final 是引用类型 static FinalReferenceExample obj; public FinalReferenceExample () &#123; // 构造函数 intArray = new int[1]; //1 intArray[0] = 1; //2 &#125; public static void writerOne () &#123; // 写线程 A 执行 obj = new FinalReferenceExample (); //3 &#125; public static void writerTwo () &#123; // 写线程 B 执行 obj.intArray[0] = 2; //4 &#125; public static void reader () &#123; // 读线程 C 执行 if (obj != null) &#123; //5 int temp1 = obj.intArray[0]; //6 &#125; &#125;&#125; 这里 final 域为一个引用类型，它引用一个 int 型的数组对象。对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束： 在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。 对上面的示例程序，假设首先线程 A 执行 writerOne() 方法，执行完后线程 B 执行 writerTwo() 方法，执行完后线程 C 执行 reader () 方法。下面是一种可能的线程执行时序： 在上图中，1 是对 final 域的写入，2 是对这个 final 域引用的对象的成员域的写入，3 是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的 1 不能和 3 重排序外，2 和 3 也不能重排序。 JMM 可以确保读线程 C 至少能看到写线程 A 在构造函数中对 final 引用对象的成员域的写入。即 C 至少能看到数组下标 0 的值为 1。而写线程 B 对数组元素的写入，读线程 C 可能看的到，也可能看不到。JMM 不保证线程 B 的写入对读线程 C 可见，因为写线程 B 和读线程 C 之间存在数据竞争，此时的执行结果不可预知。 为什么final引用不能从构造函数内逸出写 final 域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的 final 域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。示例如下： 12345678910111213141516171819public class FinalReferenceEscapeExample &#123; final int i; static FinalReferenceEscapeExample obj; public FinalReferenceEscapeExample () &#123; i = 1; //1 写 final 域 obj = this; //2 this 引用在此“逸出” &#125; public static void writer() &#123; new FinalReferenceEscapeExample (); &#125; public static void reader &#123; if (obj != null) &#123; //3 int temp = obj.i; //4 &#125; &#125;&#125; 假设一个线程 A 执行 writer() 方法，另一个线程 B 执行 reader() 方法。这里的操作 2 使得对象还未完成构造前就为线程 B 可见。即使这里的操作 2 是构造函数的最后一步，且即使在程序中操作 2 排在操作 1 后面，执行 read() 方法的线程仍然可能无法看到 final 域被初始化后的值，因为这里的操作 1 和操作 2 之间可能被重排序。实际的执行时序可能如下图所示： 从上图可以看出：在构造函数返回前，被构造对象的引用不能为其他线程可见，因为此时的 final 域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到 final 域正确初始化之后的值。 JSR-133为什么要增强final语义在旧的 Java 内存模型中 ，最严重的一个缺陷就是线程可能看到 final 域的值会改变。比如，一个线程当前看到一个整形 final 域的值为 0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个 final 域的值时，却发现值变为了 1（被某个线程初始化之后的值）。最常见的例子就是在旧的 Java 内存模型中，String 的值可能会改变。 为了修补这个漏洞，JSR-133 专家组增强了 final 的语义。通过为 final 域增加写和读重排序规则，可以为 java 程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指 lock 和 volatile 的使用），就可以保证任意线程都能看到这个 final 域在构造函数中被初始化之后的值。]]></content>
      <categories>
        <category>Java</category>
        <category>JMM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型-理解锁]]></title>
    <url>%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%90%86%E8%A7%A3%E9%94%81.html</url>
    <content type="text"><![CDATA[锁的happens-before关系锁是 java 并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。 123456789101112class MonitorExample &#123; int a = 0; public synchronized void writer() &#123; //1 a++; //2 &#125; //3 public synchronized void reader() &#123; //4 int i = a; //5 …… &#125; //6&#125; 假设线程 A 执行 writer() 方法，随后线程 B 执行 reader() 方法。根据 happens before 规则，这个过程包含的 happens before 关系可以分为两类： 根据程序次序规则，1 happens before 2, 2 happens before 3; 4 happens before 5, 5 happens before 6。 根据监视器锁规则，3 happens before 4。 根据 happens before 的传递性，2 happens before 5。 上述 happens-before 关系图如下： 上图中，每一个箭头链接的两个节点，代表了一个 happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示监视器锁规则；蓝色箭头表示组合这些规则后提供的 happens before 保证。 上图表示在线程 A 释放了锁之后，随后线程 B 获取同一个锁。在上图中，2 happens before 5。因此，线程 A 在释放锁之前所有可见的共享变量，在线程 B 获取同一个锁之后，将立刻变得对 B 线程可见。 锁的内存语义 锁释放的内存语义 当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中。以上面的程序为例，A 线程释放锁后，共享数据的状态示意图如下： 锁获取的内存语义 当线程获取锁时，JMM 会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。下面是锁获取的状态示意图： 对比锁释放 - 获取的内存语义与 volatile 写 - 读的内存语义，可以看出：锁释放与 volatile 写有相同的内存语义；锁获取与 volatile 读有相同的内存语义。 锁内存语义的实现1234567891011121314151617181920212223class ReentrantLockExample &#123; int a = 0; ReentrantLock lock = new ReentrantLock(); public void writer() &#123; lock.lock(); // 获取锁 try &#123; a++; &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125; public void reader () &#123; lock.lock(); // 获取锁 try &#123; int i = a; …… &#125; finally &#123; lock.unlock(); // 释放锁 &#125; &#125;&#125; 在 ReentrantLock 中，调用 lock() 方法获取锁；调用 unlock() 方法释放锁。 ReentrantLock 的实现依赖于 java 同步器框架 AbstractQueuedSynchronizer（简称 AQS）。AQS 使用一个整型的 volatile 变量（命名为 state）来维护同步状态，马上我们会看到，这个 volatile 变量是 ReentrantLock 内存语义实现的关键。 下面是 ReentrantLock 的类图（仅部分）： ReentrantLock 分为公平锁和非公平锁，首先分析公平锁。 使用公平锁时，加锁方法 lock() 的方法调用轨迹如下： ReentrantLock : lock() FairSync : lock() AbstractQueuedSynchronizer : acquire(int arg) ReentrantLock : tryAcquire(int acquires) 在第 4 步真正开始加锁，下面是该方法的源代码： 12345678910111213141516171819protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); // 获取锁的开始，首先读 volatile 变量 state if (c == 0) &#123; if (isFirst(current) &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 从上面源代码中我们可以看出，加锁方法首先读 volatile 变量 state。 在使用公平锁时，解锁方法 unlock() 的方法调用轨迹如下： ReentrantLock : unlock() AbstractQueuedSynchronizer : release(int arg) Sync : tryRelease(int releases) 在第 3 步真正开始释放锁，下面是该方法的源代码： 123456789101112protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); // 释放锁的最后，写 volatile 变量 state return free;&#125; 从上面的源代码我们可以看出，在释放锁的最后写 volatile 变量 state。 公平锁在释放锁的最后写 volatile 变量 state；在获取锁时首先读这个 volatile 变量。根据 volatile 的 happens-before 规则，释放锁的线程在写 volatile 变量之前可见的共享变量，在获取锁的线程读取同一个 volatile 变量后将立即变的对获取锁的线程可见。 现在分析非公平锁的内存语义的实现。 非公平锁的释放和公平锁完全一样，所以这里仅仅分析非公平锁的获取。 使用公平锁时，加锁方法 lock() 的方法调用轨迹如下： ReentrantLock : lock() NonfairSync : lock() AbstractQueuedSynchronizer : compareAndSetState(int expect, int update) 在第 3 步真正开始加锁，下面是该方法的源代码： 123protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; 该方法以原子操作的方式更新 state 变量，JDK 文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有 volatile 读和写的内存语义。 前文说过，编译器不会对 volatile 读与 volatile 读后面的任意内存操作重排序；编译器不会对 volatile 写与 volatile 写前面的任意内存操作重排序。组合这两个条件，意味着为了同时实现 volatile 读和 volatile 写的内存语义，编译器不能对 CAS 与 CAS 前面和后面的任意内存操作重排序。 对公平锁和非公平锁的内存语义做个总结： 公平锁和非公平锁释放时，最后都要写一个 volatile 变量 state。 公平锁获取时，首先会去读这个 volatile 变量。 非公平锁获取时，首先会用 CAS 更新这个 volatile 变量, 这个操作同时具有 volatile 读和 volatile 写的内存语义。 从对 ReentrantLock 的分析可以看出，锁释放 - 获取的内存语义的实现至少有下面两种方式： 利用 volatile 变量的写 - 读所具有的内存语义。利用 CAS 所附带的 volatile 读和 volatile 写的内存语义。 J.U.C包的实现由于 java 的 CAS 同时具有 volatile 读和 volatile 写的内存语义，因此 Java 线程之间的通信现在有了下面四种方式： A 线程写 volatile 变量，随后 B 线程读这个 volatile 变量。 A 线程写 volatile 变量，随后 B 线程用 CAS 更新这个 volatile 变量。 A 线程用 CAS 更新一个 volatile 变量，随后 B 线程用 CAS 更新这个 volatile 变量。 A 线程用 CAS 更新一个 volatile 变量，随后 B 线程读这个 volatile 变量。 Java 的 CAS 会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读 - 改 - 写操作，这是在多处理器中实现同步的关键（从本质上来说，能够支持原子性读 - 改 - 写指令的计算机器，是顺序计算图灵机的异步等价机器，因此任何现代的多处理器都会去支持某种能对内存执行原子性读 - 改 - 写操作的原子指令）。同时，volatile 变量的读 / 写和 CAS 可以实现线程之间的通信。把这些特性整合在一起，就形成了整个 J.U.C 包得以实现的基石。如果仔细分析 J.U.C 包的源代码实现，会发现一个通用化的实现模式： 首先，声明共享变量为 volatile； 然后，使用 CAS 的原子条件更新来实现线程之间的同步； 同时，配合以 volatile 的读 / 写和 CAS 所具有的 volatile 读和写的内存语义来实现线程之间的通信。 AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic 包中的类），这些 J.U.C 包中的基础类都是使用这种模式来实现的，而 J.U.C 包中的高层类又是依赖于这些基础类来实现的。从整体来看，J.U.C 包的实现示意图如下：]]></content>
      <categories>
        <category>Java</category>
        <category>JMM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型-理解Volatile]]></title>
    <url>%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E7%90%86%E8%A7%A3Volatile.html</url>
    <content type="text"><![CDATA[volatile特性当声明共享变量为 volatile 后，对这个变量的读 / 写将会很特别。理解 volatile 特性的一个好方法是：把对 volatile 变量的单个读 / 写，看成是使用同一个监视器锁对这些单个读 / 写操作做了同步。如下示例代码： 12345678910111213141516class VolatileFeaturesExample &#123; volatile long vl = 0L; // 使用 volatile 声明 64 位的 long 型变量 public void set(long l) &#123; vl = l; // 单个 volatile 变量的写 &#125; public void getAndIncrement () &#123; vl++; // 复合（多个）volatile 变量的读 / 写 &#125; public long get() &#123; return vl; // 单个 volatile 变量的读 &#125;&#125; 假设有多个线程分别调用上面程序的三个方法，这个程序在语意上和下面程序等价： 1234567891011121314151617class VolatileFeaturesExample &#123; long vl = 0L; // 64 位的 long 型普通变量 public synchronized void set(long l) &#123; // 对单个的普通 变量的写用同一个监视器同步 vl = l; &#125; public void getAndIncrement () &#123; // 普通方法调用 long temp = get(); // 调用已同步的读方法 temp += 1L; // 普通写操作 set(temp); // 调用已同步的写方法 &#125; public synchronized long get() &#123; // 对单个的普通变量的读用同一个监视器同步 return vl; &#125;&#125; 如示例程序所示，对一个 volatile 变量的单个读 / 写操作，与对一个普通变量的读 / 写操作使用同一个监视器锁来同步，它们之间的执行效果相同。 监视器锁的 happens-before 规则保证释放监视器和获取监视器的两个线程之间的内存可见性，这意味着对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。 监视器锁的语义决定了临界区代码的执行具有原子性。这意味着即使是 64 位的 long 型和 double 型变量，只要它是 volatile 变量，对该变量的读写就将具有原子性。如果是多个 volatile 操作或类似于 volatile++ 这种复合操作，这些操作整体上不具有原子性。 简而言之，volatile 变量自身具有下列特性： 可见性。对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。 原子性：对任意单个 volatile 变量的读 / 写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。 volatile的happens-before关系从内存语义的角度来说，volatile 与监视器锁有相同的效果：volatile 写和监视器的释放有相同的内存语义；volatile 读与监视器的获取有相同的内存语义。 12345678910111213141516class VolatileExample &#123; int a = 0; volatile boolean flag = false; public void writer() &#123; a = 1; //1 flag = true; //2 &#125; public void reader() &#123; if (flag) &#123; //3 int i = a; //4 …… &#125; &#125;&#125; 假设线程 A 执行 writer() 方法之后，线程 B 执行 reader() 方法。根据 happens before 规则，这个过程建立的 happens before 关系可以分为两类： 根据程序次序规则，1 happens before 2; 3 happens before 4。 根据 volatile 规则，2 happens before 3。 根据 happens before 的传递性规则，1 happens before 4。 上述 happens before 关系的图形化表现形式如下： 在上图中，每一个箭头链接的两个节点，代表了一个 happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示 volatile 规则；蓝色箭头表示组合这些规则后提供的 happens before 保证。 这里 A 线程写一个 volatile 变量后，B 线程读同一个 volatile 变量。A 线程在写 volatile 变量之前所有可见的共享变量，在 B 线程读同一个 volatile 变量后，将立即变得对 B 线程可见。 volatile的内存语义 volatile 写的内存语义如下： 当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存。 以上面示例程序为例，假设线程 A 首先执行 writer() 方法，随后线程 B 执行 reader() 方法，初始时两个线程的本地内存中的 flag 和 a 都是初始状态。下图是线程 A 执行 volatile 写后，共享变量的状态示意图： 如上图所示，线程 A 在写 flag 变量后，本地内存 A 中被线程 A 更新过的两个共享变量的值被刷新到主内存中。此时，本地内存 A 和主内存中的共享变量的值是一致的。 volatile 读的内存语义如下： 当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。 下面是线程 B 读同一个 volatile 变量后，共享变量的状态示意图： 如上图所示，在读 flag 变量后，本地内存 B 已经被置为无效。此时，线程 B 必须从主内存中读取共享变量。线程 B 的读取操作将导致本地内存 B 与主内存中的共享变量的值也变成一致的了。 如果把 volatile 写和 volatile 读这两个步骤综合起来看的话，在读线程 B 读一个 volatile 变量后，写线程 A 在写这个 volatile 变量之前所有可见的共享变量的值都将立即变得对读线程 B 可见。 volatile内存语义实现重排序分为编译器重排序和处理器重排序。为了实现 volatile 内存语义，JMM 会分别限制这两种类型的重排序类型。下面是 JMM 针对编译器制定的 volatile 重排序规则表： 能否重排序 第二个操作 第一个操作 普通读 / 写 volatile 读 volatile 写 普通读 / 写 NO volatile 读 NO NO NO volatile 写 NO NO 从上表可以看出： 当第二个操作是 volatile 写时，不管第一个操作是什么，都不能重排序。这个规则确保 volatile 写之前的操作不会被编译器重排序到 volatile 写之后。 当第一个操作是 volatile 读时，不管第二个操作是什么，都不能重排序。这个规则确保 volatile 读之后的操作不会被编译器重排序到 volatile 读之前。 当第一个操作是 volatile 写，第二个操作是 volatile 读时，不能重排序。 为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM 采取保守策略。下面是基于保守策略的 JMM 内存屏障插入策略： 在每个 volatile 写操作的前面插入一个 StoreStore 屏障。 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。 在每个 volatile 读操作的后面插入一个 LoadStore 屏障。 上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的 volatile 内存语义。 下面是保守策略下，volatile 写插入内存屏障后生成的指令序列示意图： 上图中的 StoreStore 屏障可以保证在 volatile 写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为 StoreStore 屏障将保障上面所有的普通写在 volatile 写之前刷新到主内存。 这里比较有意思的是 volatile 写后面的 StoreLoad 屏障。这个屏障的作用是避免 volatile 写与后面可能有的 volatile 读 / 写操作重排序。因为编译器常常无法准确判断在一个 volatile 写的后面，是否需要插入一个 StoreLoad 屏障（比如，一个 volatile 写之后方法立即 return）。为了保证能正确实现 volatile 的内存语义，JMM 在这里采取了保守策略：在每个 volatile 写的后面或在每个 volatile 读的前面插入一个 StoreLoad 屏障。从整体执行效率的角度考虑，JMM 选择了在每个 volatile 写的后面插入一个 StoreLoad 屏障。因为 volatile 写 - 读内存语义的常见使用模式是：一个写线程写 volatile 变量，多个读线程读同一个 volatile 变量。当读线程的数量大大超过写线程时，选择在 volatile 写之后插入 StoreLoad 屏障将带来可观的执行效率的提升。从这里可以看到 JMM 在实现上的一个特点：首先确保正确性，然后再去追求执行效率。 下面是在保守策略下，volatile 读插入内存屏障后生成的指令序列示意图： 上图中的 LoadLoad 屏障用来禁止处理器把上面的 volatile 读与下面的普通读重排序。LoadStore 屏障用来禁止处理器把上面的 volatile 读与下面的普通写重排序。 上述 volatile 写和 volatile 读的内存屏障插入策略非常保守。在实际执行时，只要不改变 volatile 写 - 读的内存语义，编译器可以根据具体情况省略不必要的屏障。下面通过示例代码来说明： 123456789101112131415class VolatileBarrierExample &#123; int a; volatile int v1 = 1; volatile int v2 = 2; void readAndWrite() &#123; int i = v1; // 第一个 volatile 读 int j = v2; // 第二个 volatile 读 a = i + j; // 普通写 v1 = i + 1; // 第一个 volatile 写 v2 = j * 2; // 第二个 volatile 写 &#125; … // 其他方法 &#125; 针对 readAndWrite() 方法，编译器在生成字节码时可以做如下的优化： 注意，最后的 StoreLoad 屏障不能省略。因为第二个 volatile 写之后，方法立即 return。此时编译器可能无法准确断定后面是否会有 volatile 读或写，为了安全起见，编译器常常会在这里插入一个 StoreLoad 屏障。 上面的优化是针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内存模型，内存屏障的插入还可以根据具体的处理器内存模型继续优化。以 x86 处理器为例，上图中除最后的 StoreLoad 屏障外，其它的屏障都会被省略。 前面保守策略下的 volatile 读和写，在 x86 处理器平台可以优化成： 前面提到过，x86 处理器仅会对写 - 读操作做重排序。X86 不会对读 - 读，读 - 写和写 - 写操作做重排序，因此在 x86 处理器中会省略掉这三种操作类型对应的内存屏障。在 x86 中，JMM 仅需在 volatile 写后面插入一个 StoreLoad 屏障即可正确实现 volatile 写 - 读的内存语义。这意味着在 x86 处理器中，volatile 写的开销比 volatile 读的开销会大很多（因为执行 StoreLoad 屏障开销会比较大）。 JSR-133 为什么要增强 volatile 的内存语义在 JSR-133 之前的旧 Java 内存模型中，虽然不允许 volatile 变量之间重排序，但旧的 Java 内存模型允许 volatile 变量与普通变量之间重排序。 因此在旧的内存模型中 ，volatile 的写 - 读没有监视器的释放 - 获所具有的内存语义。为了提供一种比监视器锁更轻量级的线程之间通信的机制，JSR-133 专家组决定增强 volatile 的内存语义：严格限制编译器和处理器对 volatile 变量与普通变量的重排序，确保 volatile 的写 - 读和监视器的释放 - 获取一样，具有相同的内存语义。从编译器重排序规则和处理器内存屏障插入策略来看，只要 volatile 变量与普通变量之间的重排序可能会破坏 volatile 的内存语意，这种重排序就会被编译器重排序规则和处理器内存屏障插入策略禁止。 由于 volatile 仅仅保证对单个 volatile 变量的读 / 写具有原子性，而监视器锁的互斥执行的特性可以确保对整个临界区代码的执行具有原子性。在功能上，监视器锁比 volatile 更强大；在可伸缩性和执行性能上，volatile 更有优势。如果想在程序中用 volatile 代替监视器锁，请一定谨慎。]]></content>
      <categories>
        <category>Java</category>
        <category>JMM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型-顺序一致性模型]]></title>
    <url>%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B.html</url>
    <content type="text"><![CDATA[顺序一致性保证当程序未正确同步时，就会存在数据竞争。java 内存模型规范对数据竞争的定义如下： 在一个线程中写一个变量，在另一个线程读同一个变量，而且写和读没有通过同步来排序。 当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果。如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。 JMM 对正确同步的多线程程序的内存一致性做了如下保证： 如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）– 即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile 和 final）的正确使用。 顺序一致性内存模型顺序一致性内存模型是理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性： 一个线程中的所有操作必须按照程序的顺序来执行。 （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。顺序一致性内存模型为程序员提供的视图如下： 在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程。同时，每一个线程必须按程序的顺序来执行内存读 / 写操作。在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读 / 写操作串行化。 示例：假设有两个线程 A 和 B 并发执行。其中 A 线程有三个操作，它们在程序中的顺序是：A1-&gt;A2-&gt;A3。B 线程也有三个操作，它们在程序中的顺序是：B1-&gt;B2-&gt;B3。 假设这两个线程使用监视器来正确同步：A 线程的三个操作执行后释放监视器，随后 B 线程获取同一个监视器。那么程序在顺序一致性模型中的执行效果将如下图所示： 再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图： 未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程 A 和 B 看到的执行顺序都是：B1-&gt;A1-&gt;A2-&gt;B2-&gt;A3-&gt;B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。 但是，在 JMM 中就没有这个保证。未同步程序在 JMM 中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，且还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。 同步程序的顺序一致性12345678910111213141516class SynchronizedExample &#123; int a = 0; boolean flag = false; public synchronized void writer() &#123; a = 1; flag = true; &#125; public synchronized void reader() &#123; if (flag) &#123; int i = a; …… &#125; &#125;&#125; 示例代码中，假设 A 线程执行 writer() 方法后，B 线程执行 reader() 方法。这是一个正确同步的多线程程序。根据 JMM 规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。如下执行对比图：在顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在 JMM 中，临界区内的代码可以重排序（但 JMM 不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM 会在退出监视器和进入监视器这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图。虽然线程 A 在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程 B 根本无法“观察”到线程 A 在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。 从这里可以看到 JMM 在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。 未同步程序的执行特性对于未同步或未正确同步的多线程程序，JMM 只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false），JMM 保证线程读操作读取到的值不会无中生有（out of thin air）的冒出来。为了实现最小安全性，JVM 在堆上分配对象时，首先会清零内存空间，然后才会在上面分配对象（JVM 内部会同步这两个操作）。因此，在已清零的内存空间（pre-zeroed memory）分配对象时，域的默认初始化已经完成了。 JMM 不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致。因为未同步程序在顺序一致性模型中执行时，整体上是无序的，其执行结果无法预知。保证未同步程序在两个模型中的执行结果一致毫无意义。 和顺序一致性模型一样，未同步程序在 JMM 中的执行时，整体上也是无序的，其执行结果也无法预知。同时，未同步程序在这两个模型中的执行特性有下面几个差异： 顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM 不保证单线程内的操作会按程序的顺序执行述。 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。。 JMM 不保证对 64 位的 long 型和 double 型变量的读 / 写操作具有原子性，而顺序一致性模型保证对所有的内存读 / 写操作都具有原子性。]]></content>
      <categories>
        <category>Java</category>
        <category>JMM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型-指令重排序]]></title>
    <url>%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[数据依赖性如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型： 名称 代码示例 说明 写后读 a = 1;b = a; 写一个变量之后，再读这个变量。 写后写 a = 1;a = 2; 写一个变量后，再写这个变量。 读后写 a = b;b = 1; 读一个变量之后，再写这个变量。 上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。 编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。 注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。 as-if-serial语义as-if-serial 语义是指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。 为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。如下计算圆面积的代码示例： 123double pi = 3.14; //Adouble r = 1.0; //Bdouble area = pi * r * r; //C 上面三个操作的数据依赖关系如下图所示： 如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。下图是该程序的两种执行顺序： as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。 程序顺序规则根据 happens- before 的程序顺序规则，上面计算圆的面积的示例代码存在三个 happens- before 关系： A happens- before B； B happens- before C； A happens- before C；这里的第 3 个 happens- before 关系，是根据 happens- before 的传递性推导出来的。 这里 A happens- before B，但实际执行时 B 却可以排在 A 之前执行。根据happens-before规则，如果 A happens- before B，JMM 并不要求 A 一定要在 B 之前执行。JMM 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作 A 的执行结果不需要对操作 B 可见；而且重排序操作 A 和操作 B 后的执行结果，与操作 A 和操作 B 按 happens- before 顺序执行的结果一致。在这种情况下，JMM 会认为这种重排序并不非法（not illegal），JMM 允许这种重排序。 在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens- before 的定义我们可以看出，JMM 同样遵从这一目标。 重排序对多线程的影响12345678910111213141516class ReorderExample &#123; int a = 0; boolean flag = false; public void writer() &#123; a = 1; //1 flag = true; //2 &#125; Public void reader() &#123; if (flag) &#123; //3 int i = a * a; //4 …… &#125; &#125;&#125; flag 变量是个标记，用来标识变量 a 是否已被写入。这里假设有两个线程 A 和 B，A 首先执行 writer() 方法，随后 B 线程接着执行 reader() 方法。线程 B 在执行操作 4 时，能否看到线程 A 在操作 1 对共享变量 a 的写入？ 答案是：不一定能看到。 由于操作 1 和操作 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作 3 和操作 4 没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。下面来看看，当操作 1 和操作 2 重排序时，可能会产生什么效果？如下图： 操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！ ※注：红色的虚箭线表示错误的读操作，用绿色的虚箭线表示正确的读操作。 下面再看看，当操作 3 和操作 4 重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。如下图： 在程序中，操作 3 和操作 4 存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程 B 的处理器可以提前读取并计算 a*a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作 3 的条件判断为真时，就把该计算结果写入变量 i 中。 从图中我们可以看出，猜测执行实质上对操作 3 和 4 做了重排序。重排序在这里破坏了多线程程序的语义！ 在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是 as-if-serial 语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。]]></content>
      <categories>
        <category>Java</category>
        <category>JMM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型-基础学习]]></title>
    <url>%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[并发编程模型分类在并发编程中，需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。 在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写 - 读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。 同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。 Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。 Java内存模型的抽象Java 线程之间的通信由 Java 内存模型（简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java 内存模型的抽象示意图如下： 从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历2个步骤： 首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。 然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。 下面通过示意图来说明这两个步骤：如上图所示，本地内存 A 和 B 有主内存中共享变量 x 的副本。假设初始时，这三个内存中的 x 值都为 0。线程 A 在执行时，把更新后的 x 值（假设值为 1）临时存放在自己的本地内存 A 中。当线程 A 和线程 B 需要通信时，线程 A 首先会把自己本地内存中修改后的 x 值刷新到主内存中，此时主内存中的 x 值变为了 1。随后，线程 B 到主内存中去读取线程 A 更新后的 x 值，此时线程 B 的本地内存的 x 值也变为了 1。 从整体来看，这两个步骤实质上是线程 A 在向线程 B 发送消息，而且这个通信过程必须要经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证。 指令重排序在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型： 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 上述的1属于编译器重排序，2 和 3属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。 JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。 内存屏障指令现代的处理器使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读 / 写操作的执行顺序，不一定与内存实际发生的读 / 写操作顺序一致！如下示例： ProcessorA ProcessorB a = 1; //A1x = b; //A2 b = 2; //B1y = a; //B2 初始状态：a = b = 0处理器允许得到结果：x = y = 0 假设处理器 A 和处理器 B 按程序的顺序并行执行内存访问，最终却可能得到 x = y = 0 的结果。具体的原因如下图所示： 这里处理器 A 和处理器 B 可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。 从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器 A 的内存操作顺序被重排序了（处理器 B 的情况和处理器 A 一样）。 这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写 - 读操做重排序。 下面是常见处理器允许的重排序类型的列表： Load-Load Load-Store Store-Store Store-Load 数据依赖 sparc-TSO N N N Y N x86 N N N Y N ia64 N N N Y N PowerPC N N N Y N 上表单元格中的“N”表示处理器不允许两个操作重排序，“Y”表示允许重排序。常见的处理器都允许 Store-Load 重排序；常见的处理器都不允许对存在数据依赖的操作做重排序。sparc-TSO 和 x86 拥有相对较强的处理器内存模型，它们仅允许对写 - 读操作做重排序（因为它们都使用了写缓冲区）。 为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类： 屏障类型 指令示例 说明 LoadLoad Barriers Load1; LoadLoad; Load2 确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。 StoreStore Barriers Store1; StoreStore; Store2 确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。 LoadStore Barriers Load1; LoadStore; Store2 确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。 StoreLoad Barriers Store1; StoreLoad; Load2 确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。 StoreLoad Barriers 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。 happens-before从 JDK5 开始，java 使用新的 JSR -133 内存模型，JSR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的 happens-before 规则如下： 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。 volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。 传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。 注意：两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。 如上图所示，一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。]]></content>
      <categories>
        <category>Java</category>
        <category>JMM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式学习-Session丢失及解决]]></title>
    <url>%2F%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%A6%E4%B9%A0-Session%E4%B8%A2%E5%A4%B1%E5%8F%8A%E8%A7%A3%E5%86%B3.html</url>
    <content type="text"><![CDATA[什么是Session丢失Session是为了将同一个用户的多次访问在系统中被识别为“同一个用户”而产生的概念。除此之外，还可以基于它来减少重复往DB或者远程服务处获取与该用户相关的信息，以起到提升性能的作用。 在做了负载均衡的场景中，如果选择的负载策略是hash策略，那么会使得Session产生一个副作用：用户一旦由于某种原因从原先访问服务器A变成访问服务器B，就会出现“登陆状态丢失”、“缓存穿透”等问题。 为什么hash策略会出现这个问题呢？首先有必要先了解一下hash是如何进行的。hash策略就是下图这样的一个散列函数。在函数不变的情况下，A永远对应01，B对应04，C对应08。 以nginx中的ip_hash策略来举个例子。正常情况下用户的ip不会在短时间内发生变化，所以当使用ip_hash策略进行负载均衡时，意味着期望同一个用户能够一直访问到同一台服务器上，就像下图这样。 如此一来，我们只需要在这一台服务器上将这个用户相关的信息缓存在进程内，这时，客户端与服务端之间的相当于建立了一个信任，相互认识。这个信任就是「Session」。但是，当我们加了一台服务器之后，事情就发生变化了。 这个时候原先的预期就被破坏了。因为用户与序号0节点的链接变成了与序号3的链接，所以产生了Session丢失问题。与此同时，在序号0节点上做的进程内缓存都无效了，而在序号3节点上又没有用户相关的任何缓存，导致大量数据需要从下游的DB或者远程服务处获取。要知道，一旦涉及到网络通信，性能必然明显下降，I/O、序列化都是耗时的工作。更重要的是，一旦同时有大量用户产生这个情况，由于后端的DB和远程服务瞬时无法承载激增的高密度请求，可能会导致它挂起。这还没完，如果当前程序没有一些故障隔离或者降级策略，还会进一步产生蝴蝶效应，导致整个大系统响应缓慢。 nginx是如何解决的通过在nginx中引入nginx-sticky-module模块可以来解决这个问题。解决的整个过程如下。可以看到，当client第一次进入到nginx匹配节点的时候，在给它分配一个节点的同时，会将这个节点的唯一标识进行md5后写入到cookie中一并返回，如果下次再发起请求的时候发现带有这个cookie值，就直接转发到该值所对应的节点上去。这个机制被专业的称之为「Session保持」。 虽然可以利用cookie来解决这个问题，但是cookie也有一个潜在的问题，如果客户端未开启cookie功能，这个机制就失效了。不过好在目前主流浏览器都是默认打开cookie的。 其他解决方案Session复制这是最简单粗暴的方式。根据上面的案例来看，导致问题的原因是节点3没有用户的Session。那么很容易想到，在节点3运行之前把Session相关的Cache数据复制过去，并且在多个节点之间持续保证数据的同步，也就是说，每一台节点上都存在每个用户的Session数据。 实现的方案有很多，特别是不同的宿主程序都或多或少提供了一些切入点，甚至是拿来即用的方案，如Tomcat的Delta Manager和Backup Manager、Tomcat和IIS的Filter机制等等。此类方案的特点是 优点：天然高可用，一部分节点宕机没事。因为每一个节点上存放着所有已连接用户的会话信息。 缺点：因为每台计算机的内存是有上限的，仅适用于会话相关的数据大小较小的场景。并且，由于多个节点之间需要同步数据，需要额外解决数据一致性问题。与此同时，随着节点越多，损耗越大（延迟、带宽等），有广播风暴风险。 Session共享通过将session信息存放到全局共享的存储介质中来达到一样的效果，如数据库、远程缓存等，这是一种中心化思想的解决方案。 此类方案的特点是： 优点：不管节点怎么增加和减少，100%不会产生会话丢失。 缺点：每次读写请求都需要增加额外共享储存调用，增加了网络I/O、序列化等操作，性能明显下降。另外，用作共享的存储介质除了增加了额外的维护成本外，还需要解决单点问题，以免产生系统性风险。 三种方案对比 分别用一句话概括一下这3个方案： Session 保持：原来在哪还是去哪。Session 复制：不管在哪都有一样的数据。Session 共享：所有节点共用一份数据。]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式学习-负载均衡]]></title>
    <url>%2F%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html</url>
    <content type="text"><![CDATA[概述分布式系统的关键是做冗余，让这些冗余能发挥高可用作用的就是负载均衡。负载均衡的作用是一个“连接者”，让上下游之间以期望的方式“连接”起来。所以，有必要先了解一下这些上下游的全貌，并且从中找到做负载均衡的地方。 分布式系统有各式各样的架构方式，不过本质上都是上图这样的一个分层架构。图中红点标记出的地方就是需要做负载均衡的地方，可以看到，就是每两层之间的连接处。这些连接处在实际做负载均衡的时候，需要结合所处的网络层次。因为在不同的网络层次有不同的做法。如下图。 一般主流的四层负载均衡和七层负载均衡，前者指的就是传输层，主要涉及的协议是TCP、UDP等，后者指的应用层，主要涉及的协议是Http、Https和FTP等。用来实现负载均衡的解决方案有很多，分为基于硬件或者基于软件的，比较成熟的诸如：F5（支持四层、七层）、LVS（支持四层）、Nginx（支持七层）等等。 常用负载均衡策略轮询这是最常用也最简单策略，平均分配，人人都有、一人一次。大致的代码如下。 1234567891011int globalIndex = 0; try&#123; return servers[globalIndex];&#125;finally&#123; globalIndex++; if (globalIndex == 3) globalIndex = 0;&#125; 加权轮询 在轮询的基础上，增加了一个权重的概念。权重是一个泛化后的概念，可以用任意方式来体现，本质上是一个能者多劳思想。比如，可以根据宿主的性能差异配置不同的权重。大致的代码如下。 1234567891011121314151617int matchedIndex = -1;int total = 0;for (int i = 0; i &lt; servers.Length; i++)&#123; //每次循环的时候做自增（步长=权重值） servers[i].cur_weight += servers[i].weight; //将每个节点的权重值累加到汇总值中 total += servers[i].weight; //如果 当前节点的自增数 &gt; 当前待返回节点的自增数，则覆盖。 if (matchedIndex == -1 || servers[matchedIndex].cur_weight &lt; servers[i].cur_weight) &#123; matchedIndex = i; &#125;&#125;servers[matchedIndex].cur_weight -= total;//④被选取的节点减去②的汇总值，以降低下一次被选举时的初始权重值。return servers[matchedIndex]; 这段代码的过程如下图的表格。”()”中的数字就是自增数，代码中的cur_weight。 值得注意的是，加权轮询本身还有不同的实现方式，虽说最终的比例都是2：1：2。但是在请求送达的先后顺序上可以所有不同。比如「5-4，3，2-1」和上面的案例相比，最终比例是一样的，但是效果不同。「5-4，3，2-1」更容易产生并发问题，导致服务端拥塞，且这个问题随着权重数字越大越严重。例子：10：5：3的结果是「18-17-16-15-14-13-12-11-10-9，8-7-6-5-4，3-2-1」 最少连接数 这是一种根据实时的负载情况，进行动态负载均衡的方式。维护好活动中的连接数量，然后取最小的返回即可。大致的代码如下。 1234var matchedServer = servers.orderBy(e =&gt; e.active_conns).first();matchedServer.active_conns += 1;return matchedServer;//在连接关闭时还需对active_conns做减1的动作。 最快响应这也是一种动态负载均衡策略，它的本质是根据每个节点对过去一段时间内的响应情况来分配，响应越快分配的越多。具体的运作方式也有很多，上图的这种可以理解为，将最近一段时间的请求耗时的平均值记录下来，结合前面的「加权轮询」来处理，所以等价于2：1：3的加权轮询。 Hash法hash法的负载均衡与之前的几种不同在于，它的结果是由客户端决定的。通过客户端带来的某个标识经过一个标准化的散列函数进行打散分摊。 常用负载均衡策略优缺点和适用场景 健康探测保障高可用不管是什么样的策略，难免会遇到机器故障或者程序故障的情况。所以要确保负载均衡能更好的起到效果，还需要结合一些「健康探测」机制。定时的去探测服务端是不是还能连上，响应是不是超出预期的慢。如果节点属于“不可用”的状态的话，需要将这个节点临时从待选取列表中移除，以提高可用性。一般常用的「健康探测」方式有3种。 HTTP探测使用Get/Post的方式请求服务端的某个固定的URL，判断返回的内容是否符合预期。一般使用Http状态码、response中的内容来判断。 TCP探测基于Tcp的三次握手机制来探测指定的IP + 端口。最佳实践可以借鉴阿里云的SLB机制，如下图。 UDP探测可能有部分应用使用的UDP协议。在此协议下可以通过报文来进行探测指定的IP + 端口。最佳实践同样可以借鉴阿里云的SLB机制，如下图。 结果的判定方式是：在服务端没有返回任何信息的情况下，默认正常状态。否则会返回一个ICMP的报错信息。 实施负载均衡硬件负载均衡硬件这块名气最大的还属F5。此类硬件负载均衡器的特点是“壕”，毕竟是纯商业化的东西，投入的资源和精力自然是众多开源软件负载均衡所无法比拟的，所以功能非常强大。包含访问加速、压缩、安全等等负载均衡之外的许多附加功能。 如果用F5组网的话，有两种结构，串行结构和并行结构，也称为直连模式和旁路模式。前者的优势在对硬件产生压力较小、且天然安全性高，而后者对原网络架构的改动较小、且扩展性较好。大家在实际的使用中结合自身情况来部署。 软件负载均衡（L7） 针对Web应用的L7负载均衡，比较主流的产品是2个Nginx、HAProxy。在L7做负载均衡，最大的特点就是灵活，请求的URL、Header都是可以去掌控的，所以可以利用其中的任何信息为负载均衡策略所用。实际操作中主要做2步： 在公网的域名解析中，配置解析到「反向代理」。记录类型是「A」，记录值是「反向代理」的IP。 配置真实提供服务的Web应用IP和端口，和负载均衡均衡策略。上图中的配置是Nginx中的示例，负载均衡策略的缺省值是轮询。 软件负载均衡（L4） 当Web应用所依赖的TCP协议的服务需要横向扩展，或者需要做数据库、分布式缓存的多主、主从集群时，那么就需要一个支持L4的负载均衡软件。这里最知名的就属LVS了，它是内核态的程序，所以相比用Nginx、HAProxy来做L4的负载均衡，在性能、资源的消耗上会更优一些。实际运用中的操作步骤主要也是2步： 在LVS中添加一个IP虚拟服务（IPVS），并指定它的IP、端口和负载均衡策略。 将IP虚拟服务关联到真实的服务上，并指定模式和权重的信息。（做L4的负载均衡可以使用NAT或者FULLNAT模式） LVS的模式一共有四种，除了NAT和FULLNAT（NAT的增强版）模式外，它的TUN模式可以在L3做负载均衡，DR模式可以在L2做负载均衡，到这个层面其实就和做硬件同处于一个层次了。并且，随着层次的深入，虽然对功能性上有所弱化，但是如果不考虑端口的话，单从IP层面的负载均衡来说，用DR模式做，则对数据包的加工介入度会降到最低，因此也是通过软件做负载均衡能够达到的性能极致。另外，LVS中运用的虚拟IP概念，本质上和Nginx中的“server”概念一样，定义了一个统一入口，作用上并没有差别。将Nginx中的upstream关联到server，就如LVS操作步骤第2点中的关联一般。 优缺点不同的解决方案有不同的侧重点。因此在单个解决方案已经无法满足的情况下，可以组合使用，各尽所长。 推荐方案负载均衡这个领域还是以高可用和性能为2个最重要因素，下面是推荐的一种组合方式，也是在系统量级达到每小时上亿PV之后最被广泛使用的一种。理论上，利用第一步DNS的域名解析所带的负载均衡效果，只要复制多套LVS主备出来，绑上多个不同的虚IP，可以做到无限横向扩展，以支撑不断增长的流量。用到的3个软件目前都是开源产品，LVS+Keepalived负责做Nginx的负载均衡，而Nginx负责分发到实际的请求到Http和Tcp协议的应用上。关于LVS的模式选择，如果在同网段内的话优先使用DR模式进行L2转发，性能最好。否则使用TUN模式进行L3分发。与此同时，在L4、L7的分发上使用Nginx来做，可以发挥其灵活易扩展的特点以及其它的一些额外特性如缓存等。]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>高可用</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL规范]]></title>
    <url>%2FMySQL%E8%A7%84%E8%8C%83.html</url>
    <content type="text"><![CDATA[数据库命名规范 所有数据库对象名称必须使用小写字母并用下划线分割。 所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）。 数据库对象的命名要能做到见名识意，并且最后不要超过32 个字符。 临时库表必须以 tmp_ 为前缀并以日期为后缀，备份表必须以 bak_ 为前缀并以日期 ( 时间戳 ) 为后缀。 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。 数据库基本设计规范 没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）InnoDB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。 数据库和表的字符集统一使用 UTF8，兼容性更好。统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效。 所有表和字段都需要添加注释，使用 comment 从句添加表和列的备注 从一开始就进行数据字典的维护。 尽量控制单表数据量的大小，建议控制在500万以内，500万并不是 MySQL 数据库的限制，过大会造成修改表结构、备份、恢复都会有很大的问题，可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小。 谨慎使用 MySQL 分区表。分区表在物理上表现为多个文件，在逻辑上表现为一个表。谨慎选择分区键，跨分区查询效率可能更低，建议采用物理分表的方式管理大数据。 尽量做到冷热数据分离，减小表的宽度。MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。减少磁盘 IO，保证热数据的内存缓存命中率（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO） 更有效的利用缓存，避免读入无用的冷数据；经常一起使用的列放到一个表中（避免更多的关联操作） 禁止在数据库中存储图片，文件等大的二进制数据。通常文件很大，会短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机 IO 操作，文件很大时，IO 操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。 禁止在线上做数据库压力测试。 禁止从开发环境，测试环境直接连接生产环境数据库。 数据库字段设计规范 优先选择符合存储需要的最小的数据类型 列的字段越大，建立索引时所需要的空间也就越大，这样一页中所能存储的索引节点的数量也就越少，在遍历时所需要的IO次数也就越多，索引的性能也就越差。 将字符串转换成数字类型存储，如：将IP地址转换成整形数据。MySQL 提供了两个方法来处理 IP 地址inet_aton 把ip转为无符号整型(4-8位)inet_ntoa 把整型的ip转为地址 插入数据前，先用 inet_aton 把 IP 地址转为整型，可以节省空间。显示数据时，使用 inet_ntoa 把整型的 IP 地址转为地址显示即可。 对于非负型的数据（如自增 ID、整型 IP）来说，要优先使用无符号整型来存储,因为无符号相对于有符号可以多出一倍的存储空间。SIGNED INT -21474836482147483647UNSIGNED INT 04294967295 VARCHAR(N) 中的 N 代表的是字符数，而不是字节数。使用 UTF8 存储 255 个汉字 Varchar(255)=765 个字节。过大的长度会消耗更多的内存。 避免使用 TEXT、BLOB 数据类型 最常见的TEXT类型可以存储64k的数据，建议把 BLOB 或是TEXT列分离到单独的扩展表中。MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 SQL 性能变得很差，但是不是说一定不能使用这样的数据类型。如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select * 而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。 TEXT 或 BLOB 类型只能使用前缀索引,因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的。 避免使用 ENUM 类型 修改 ENUM 值需要使用 ALTER 语句 ENUM 类型的 ORDER BY 操作效率低，需要额外操作 禁止使用数值作为 ENUM 的枚举值 尽可能把所有列定义为 NOT NULL 索引 NULL 列需要额外的空间来保存，所以要占用更多的空间。进行比较和计算时要对 NULL 值做特别的处理。 使用 TIMESTAMP（4 个字节）或 DATETIME 类型（8 个字节）存储时间 TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。 TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高，超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储。 经常会有人用字符串存储日期型的数据（不正确的做法）： 缺点 1：无法用日期函数进行计算和比较。缺点 2：用字符串存储日期要占用更多的空间。 同财务相关的金额类数据必须使用 decimal 类型 非精准浮点：float，double精准浮点：decimalDecimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。可用于存储比 bigint 更大的整型数据。 索引设计规范 限制每张表上的索引数量，建议单张表索引不超过 5 个 索引并不是越多越好！索引可以提高效率同样也可以降低效率；索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。 禁止给表中的每一列都建立单独的索引 5.6版本之前，一个 SQL 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好 每个 InnoDB 表必须有个主键 InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种 InnoDB是按照主键索引的顺序来组织表的。 不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用 UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。主键建议使用自增 ID 值。 如何选择索引列的顺序建立索引的目的是希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。 区分度最高的放在联合索引的最左侧（区分度 = 列中不同值的数量 / 列的总行数）。 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）。 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。 避免建立冗余索引和重复索引因为这样会增加查询优化器生成执行计划的时间。 重复索引示例：primary key(id)、index(id)、unique index(id)冗余索引示例：index(a,b,c)、index(a,b)、index(a) 优先考虑覆盖索引对于频繁的查询优先考虑使用覆盖索引。 覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by包含的字段)的索引 覆盖索引的好处： 避免 InnoDB 表进行索引的二次查询。InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。 可以把随机 IO 变成顺序 IO 加快查询效率。由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。 数据库 SQL 开发规范 建议使用预编译语句进行数据库操作 预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题， 只传参数，比传递 SQL 语句更高效 相同语句可以一次解析，多次使用，提高处理效率。 避免数据类型的隐式转换 隐式转换会导致索引失效。如：select name,phone from customer where id = &#39;111&#39;; 充分利用表上已经存在的索引 避免使用双 % 号的查询条件。如a like &#39;%123%&#39;，（如果无前置 %，只有后置 %，是可以用到列上的索引的） 使用 left join 或 not exists 来优化 not in 操作,因为 not in 也通常会使用索引失效。 数据库设计时，应该要对以后扩展进行考虑 程序连接不同的数据库使用不同的账号，进制跨库查询 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询 消耗更多的 CPU 和 IO 以网络带宽资源 无法使用覆盖索引 可减少表结构变更带来的影响 禁止使用不含字段列表的 INSERT 语句 如：insert into values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);应使用：insert into t(c1,c2,c3) values (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;); 避免使用子查询，可以把子查询优化为 JOIN 操作 通常子查询在 in 子句中，且子查询中为简单 SQL ( 不包含 union、group by、order by、limit 从句 ) 时，才可以把子查询转化为关联查询进行优化。 子查询性能差的原因： 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。 避免使用 JOIN 关联太多的表 对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。 在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。 如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。 同时对于关联操作来说，会产生临时表操作，影响查询效率 MySQL 最多允许关联 61 个表，建议不超过 5 个。 减少同数据库的交互次数 数据库更适合处理批量操作 合并多个相同的操作到一起，可以提高处理效率 对应同一列进行 or 判断时，使用 in 代替 or In 的值不要超过 500 个， in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。 禁止使用 order by rand() 进行随机排序 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。 推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。 WHERE从句中禁止对列进行函数转换和计算 对列进行函数转换或计算时会导致无法使用索引。 在明显不会有重复值时使用 UNION ALL 而不是 UNION UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作。UNION ALL 不会再对结果集进行去重操作。 拆分复杂的大 SQL 为多个小 SQL 大 SQL：逻辑上比较复杂，需要占用大量 CPU 进行计算的SQL 。MySQL：一个 SQL 只能使用一个 CPU 进行计算。SQL 拆分后可以通过并行执行来提高处理效率。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java - 锁机制]]></title>
    <url>%2FJava-%E9%94%81%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[公平锁/非公平锁公平锁是指多个线程按照申请锁的顺序来获取锁。 非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。 对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。 对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。 可重入锁/不可重入锁可重入锁广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。ReentrantLock和synchronized都是可重入锁。 1234567synchronized void setA() throws Exception&#123; Thread.sleep(1000); setB();&#125;synchronized void setB() throws Exception&#123; Thread.sleep(1000);&#125; 不可重入锁不可重入锁，与可重入锁相反，不可递归调用，递归调用就发生死锁。下面看一个使用自旋锁模拟不可重入锁的例子： 123456789101112131415161718192021222324252627282930313233package main.java.com.study.lock;import java.util.concurrent.atomic.AtomicReference;/** * @author: whb * @description: 自旋锁模拟不可重入锁 */public class UnReentrantLock &#123; private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;(); /** * 加锁 */ public void lock() &#123; Thread current = Thread.currentThread(); //经典的自旋语法 for (; ; ) &#123; if (!owner.compareAndSet(null, current)) &#123; return; &#125; &#125; &#125; /** * 解锁 */ public void unlock() &#123; Thread current = Thread.currentThread(); owner.compareAndSet(current, null); &#125;&#125; 代码也比较简单，使用原子引用来存放线程，同一线程两次调用lock()方法，如果不执行unlock()释放锁的话，第二次调用自旋的时候就会产生死锁，这个锁就不是可重入的，而实际上同一个线程不必每次都去释放锁再来获取锁，这样的调度切换是很耗资源的。把它变成可重入锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344package main.java.com.study.lock;import java.util.concurrent.atomic.AtomicReference;/** * @author: whb * @description: 自旋锁模拟可重入锁 */public class ReentrantLock &#123; private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;(); //记录重入次数 private volatile int state = 0; /** * 加锁 */ public void lock() &#123; Thread current = Thread.currentThread(); if (current == owner.get()) &#123; state++; return; &#125; for (; ; ) &#123; if (!owner.compareAndSet(null, current)) &#123; return; &#125; &#125; &#125; /** * 释放锁 */ public void unlock() &#123; Thread current = Thread.currentThread(); if (current == owner.get()) &#123; if (state != 0) &#123; state--; &#125; else &#123; owner.compareAndSet(current, null); &#125; &#125; &#125;&#125; 在执行每次操作之前，判断当前锁持有者是否是当前对象，采用state计数，不用每次去释放锁。 J.U.C包中ReentrantLock中可重入锁实现，看下非公平锁的锁获取实现： 123456789101112131415161718final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 在AQS中维护了一个private volatile int state来计数重入次数，避免了频繁的持有释放操作，这样既提升了效率，又避免了死锁。 独占锁/共享锁独占锁该锁每一次只能被一个线程所持有。 共享锁该锁可被多个线程共有，典型的就是ReentrantReadWriteLock里的读锁，它的读锁是可以被共享的，但是它的写锁确每次只能被独占。 另外读锁的共享可保证并发读是非常高效的，但是读写和写写，写读都是互斥的。 独占锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独占或者共享。对于Synchronized而言，当然是独占锁。 互斥锁/读写锁互斥锁在访问共享资源之前进行加锁操作，在访问完成之后进行解锁操作。加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。如果解锁时有一个以上的线程阻塞，那么所有该锁上的线程都被变成就绪状态， 第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待。在这种方式下，只有一个线程能够访问被互斥锁保护的资源。 读写锁读写锁既是互斥锁，又是共享锁，read模式是共享，write是互斥(排它锁)的。读写锁在Java中的具体实现就是ReadWriteLock。 读写锁有三种状态：读加锁状态、写加锁状态和不加锁状态。 一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。 只有一个线程可以占有写状态的锁，但可以有多个线程同时占有读状态锁，这也是它可以实现高并发的原因。当其处于写状态锁下，任何想要尝试获得锁的线程都会被阻塞，直到写状态锁被释放；如果是处于读状态锁下，允许其它线程获得它的读状态锁，但是不允许获得它的写状态锁，直到所有线程的读状态锁被释放；为了避免想要尝试写操作的线程一直得不到写状态锁，当读写锁感知到有线程想要获得写状态锁时，便会阻塞其后所有想要获得读状态锁的线程。所以读写锁非常适合资源的读操作远多于写操作的情况。 悲观锁/乐观锁悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。 乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。 分段锁分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。 并发容器类的加锁机制是基于粒度更小的分段锁，分段锁也是提升多并发程序性能的重要手段之一。 在并发程序中，串行操作是会降低可伸缩性，并且上下文切换也会减低性能。在锁上发生竞争时将导致这两种问题，使用独占锁时保护受限资源的时候，基本上是采用串行方式—-每次只能有一个线程能访问它。所以对于可伸缩性来说最大的威胁就是独占锁。 三种方式降低锁的竞争程度：1、减少锁的持有时间 2、降低锁的请求频率 3、使用带有协调机制的独占锁，这些机制允许更高的并 无锁/偏向锁/轻量级锁/重量级锁锁的四种状态 无锁状态； 偏向锁状态； 轻量级锁状态； 重量级锁状态； 这四种状态都不是Java语言中的锁，而是Jvm为了提高锁的获取与释放效率而做的优化(使用synchronized时)。锁的状态是通过对象监视器在对象头中的字段来表明的。四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。 Java对象头以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。 Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。 Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 MonitorMonitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。 synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。下面给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点： 无锁无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。 偏向锁偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。 轻量级锁是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。 重量级锁升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。 自旋锁CAS算法我们知道CAS算法是乐观锁的一种实现方式，CAS算法中又涉及到自旋锁，先回顾下CAS算法：CAS是英文单词Compare and Swap（比较并交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数 需要读写的内存值 V 进行比较的值 A 拟写入的新值 B 更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B，否则不会执行任何操作。一般情况下是一个自旋操作，即不断的重试。 CAS存在的问题 ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。 循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。 只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。 Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。 自旋锁在介绍自旋锁前，我们需要介绍一些前提知识来帮助大家明白自旋锁的概念。阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。 1234567891011121314public class SpinLock &#123; private AtomicReference&lt;Thread&gt; cas = new AtomicReference&lt;Thread&gt;(); public void lock() &#123; Thread current = Thread.currentThread(); // 利用CAS while (!cas.compareAndSet(null, current)) &#123; // DO nothing &#125; &#125; public void unlock() &#123; Thread current = Thread.currentThread(); cas.compareAndSet(current, null); &#125;&#125; lock（)方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用unlock方法释放了该锁。 自旋锁的缺陷 如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。 上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。 自旋锁的优点 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快 非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能） 适应性自旋锁自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis - 常用数据类型及命令]]></title>
    <url>%2FRedis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[概述Redis中存储数据是通过key-value格式存储数据的，其中value可以定义五种数据类型： String（字符类型） Hash（散列类型） List（列表类型） Set（集合类型） SortedSet（有序集合类型，简称zset） 注意：在redis中的命令语句中，命令是忽略大小写的，而key是不忽略大小写的。 String类型赋值语法：set key value 12127.0.0.1:6379&gt; set k1 v1OK 取值语法：get key 12127.0.0.1:6379&gt; get k1&quot;v1&quot; 取值并赋值语法：getset key value 1234127.0.0.1:6379&gt; getset k1 v2&quot;v1&quot;127.0.0.1:6379&gt; get k1&quot;v2&quot; 递增数字语法：INCR key 123456127.0.0.1:6379&gt; incr num(integer) 1127.0.0.1:6379&gt; incr num(integer) 2127.0.0.1:6379&gt; incr num(integer) 3 增加指定的整数语法：INCRBY key increment 123456127.0.0.1:6379&gt; incrby num 2(integer) 5127.0.0.1:6379&gt; incrby num 2(integer) 7127.0.0.1:6379&gt; incrby num 2(integer) 9 递减数值语法：DECR key 1234 127.0.0.1:6379&gt; decr num(integer) 9127.0.0.1:6379&gt; decr num(integer) 8 减少指定的整数语法：DECRBY key decrement 12345678127.0.0.1:6379&gt; decr num(integer) 6127.0.0.1:6379&gt; decr num(integer) 5127.0.0.1:6379&gt; decrby num 3(integer) 2127.0.0.1:6379&gt; decrby num 3(integer) -1 仅当不存在时赋值语法：setnx key value 12345678redis&gt; EXISTS k1 # k1 不存在(integer) 0redis&gt; SETNX k1 &quot;v1&quot; # k1设置成功(integer) 1redis&gt; SETNX k1 &quot;v2&quot; # 尝试覆盖 k1，失败(integer) 0redis&gt; GET k1 # 没有被覆盖&quot;v1&quot; 向尾部追加值APPEND命令，向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度。 语法：APPEND key value 123456127.0.0.1:6379&gt; set str helloOK127.0.0.1:6379&gt; append str &quot; world!&quot;(integer) 12127.0.0.1:6379&gt; get str &quot;hello world!&quot; 获取字符串长度STRLEN命令，返回键值的长度，如果键不存在则返回0。 语法：STRLEN key 123456127.0.0.1:6379&gt; strlen str (integer) 0127.0.0.1:6379&gt; set str helloOK127.0.0.1:6379&gt; strlen str (integer) 5 同时设置/获取多个键值语法：MSET key value [key value …]MGET key [key …] 1234567127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3OK127.0.0.1:6379&gt; get k1&quot;v1&quot;127.0.0.1:6379&gt; mget k1 k31) &quot;v1&quot;2) &quot;v3&quot; Hash类型hash叫散列类型，它提供了字段和字段值的映射。字段值只能是字符串类型，不支持散列类型、集合类型等其它类型。如下： 赋值HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时0。 一次只能设置一个字段值 语法：HSET key field value 12127.0.0.1:6379&gt; hset user username zhangsan (integer) 1 一次可以设置多个字段值 语法：HMSET key field value [field value ...] 12127.0.0.1:6379&gt; hmset user age 20 username lisi OK 当值不存在才赋值当字段不存在时赋值，类似HSET，区别在于如果字段存在，该命令不执行任何操作语法：HSETNX key field value12127.0.0.1:6379&gt; hsetnx user age 30 (integer) 0 如果user中没有age字段则设置age值为30，否则不做任何操作 取值 一次只能获取一个字段值 语法：HGET key field 12127.0.0.1:6379&gt; hget user username&quot;lisi“ 一次可以获取多个字段值 语法：HMGET key field [field ...] 123127.0.0.1:6379&gt; hmget user age username1) &quot;20&quot;2) &quot;lisi&quot; 获取所有字段值 语法：HGETALL key 12345127.0.0.1:6379&gt; hgetall user1) &quot;age&quot;2) &quot;20&quot;3) &quot;username&quot;4) &quot;lisi&quot; 删除字段 可以删除一个或多个字段，返回值是被删除的字段个数 语法：HDEL key field [field ...] 123456127.0.0.1:6379&gt; hdel user age(integer) 1127.0.0.1:6379&gt; hdel user age name(integer) 0127.0.0.1:6379&gt; hdel user age username(integer) 1 增加数字语法：HINCRBY key field increment 123456#将用户的年龄加2127.0.0.1:6379&gt; hincrby user age 2 (integer) 22#获取用户的年龄127.0.0.1:6379&gt; hget user age &quot;22&quot; 判断字段是否存在语法：HEXISTS key field 123456#查看user中是否有age字段127.0.0.1:6379&gt; hexists user age (integer) 1#查看user中是否有name字段127.0.0.1:6379&gt; hexists user name (integer) 0 只获取字段名或字段值语法： 12HKEYS keyHVALS key 12345678127.0.0.1:6379&gt; hmset user age 20 name lisi OK127.0.0.1:6379&gt; hkeys user1) &quot;age&quot;2) &quot;name&quot;127.0.0.1:6379&gt; hvals user1) &quot;20&quot;2) &quot;lisi&quot; 获取字段数量语法：HLEN key 12127.0.0.1:6379&gt; hlen user(integer) 2 获取所有字段作用：获得hash的所有信息，包括key和value 语法：hgetall key List类型Redis的列表类型（list）可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。 列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为O(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。 向列表左边增加元素语法：LPUSH key value [value ...] 12127.0.0.1:6379&gt; lpush list:1 1 2 3(integer) 3 向列表右边增加元素语法：RPUSH key value [value ...] 12127.0.0.1:6379&gt; rpush list:1 4 5 6(integer) 6 查看列表语法：LRANGE key start stop LRANGE命令是列表类型最常用的命令之一，获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素。 1234127.0.0.1:6379&gt; lrange list:1 0 21) &quot;3&quot;2) &quot;2&quot;3) &quot;1&quot; 从列表两端弹出元素LPOP命令从列表左边弹出一个元素，会分两步完成： 第一步是将列表左边的元素从列表中移除 第二步是返回被移除的元素值。语法：123LPOP keyRPOP key 1234127.0.0.1:6379&gt; lpop list:1&quot;3&quot;127.0.0.1:6379&gt; rpop list:1&quot;6&quot; 获取列表中元素的个数语法：LLEN key 12127.0.0.1:6379&gt; llen list:1(integer) 4 删除列表中指定个数的值LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，该命令的执行方式会有所不同： 当count&gt;0时， LREM会从列表左边开始删除。 当count&lt;0时， LREM会从列表后边开始删除。 当count=0时， LREM删除所有值为value的元素。 语法：LREM key count value 获得指定索引的元素值语法：LINDEX key index 12127.0.0.1:6379&gt; lindex list:1 2&quot;4&quot; 设置指定索引的元素值语法：LSET key index value 1234567127.0.0.1:6379&gt; lset list:1 2 2OK127.0.0.1:6379&gt; lrange list:1 0 -11) &quot;2&quot;2) &quot;1&quot;3) &quot;2&quot;4) &quot;5&quot; 只保留列表指定片段, 指定范围和LRANGE一致语法：LTRIM key start stop 1234567891011127.0.0.1:6379&gt; lrange list:1 0 -11) &quot;2&quot;2) &quot;1&quot;3) &quot;2&quot;4) &quot;5&quot;127.0.0.1:6379&gt; ltrim list:1 0 2OK127.0.0.1:6379&gt; lrange list:1 0 -11) &quot;2&quot;2) &quot;1&quot;3) &quot;2&quot; 向列表中插入元素该命令首先会在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。 语法：LINSERT key BEFORE|AFTER pivot value 1234567891011127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;2&quot;3) &quot;1&quot;127.0.0.1:6379&gt; linsert list after 3 4(integer) 4127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;4&quot;3) &quot;2&quot;4) &quot;1&quot; 将元素从一个列表转移到另一个列表中语法：RPOPLPUSH source destination 12345678127.0.0.1:6379&gt; rpoplpush list newlist &quot;1&quot;127.0.0.1:6379&gt; lrange newlist 0 -11) &quot;1&quot;127.0.0.1:6379&gt; lrange list 0 -11) &quot;3&quot;2) &quot;4&quot;3) &quot;2&quot; Set类型set类型即集合类型，其中的数据是不重复且没有顺序。 集合类型和列表类型的对比： 集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为0(1)。Redis还提供了多个集合之间的交集、并集、差集的运算。 增加/删除元素语法：SADD key member [member ...] 1234127.0.0.1:6379&gt; sadd set a b c(integer) 3127.0.0.1:6379&gt; sadd set a(integer) 0 语法：SREM key member [member ...] 12127.0.0.1:6379&gt; srem set c d(integer) 1 获得集合中的所有元素语法：SMEMBERS key 123127.0.0.1:6379&gt; smembers set1) &quot;b&quot;2) &quot;a” 判断元素是否在集合中语法：SISMEMBER key member 1234127.0.0.1:6379&gt; sismember set a(integer) 1127.0.0.1:6379&gt; sismember set h(integer) 0 集合运算命令 集合的差集运算 A-B : 属于A并且不属于B的元素构成的集合。 语法：SDIFF key [key ...] 12345678127.0.0.1:6379&gt; sadd setA 1 2 3(integer) 3127.0.0.1:6379&gt; sadd setB 2 3 4(integer) 3127.0.0.1:6379&gt; sdiff setA setB 1) &quot;1&quot;127.0.0.1:6379&gt; sdiff setB setA 1) &quot;4&quot; 集合的交集运算 A ∩ B : 属于A且属于B的元素构成的集合。 语法：SINTER key [key ...] 123127.0.0.1:6379&gt; sinter setA setB 1) &quot;2&quot;2) &quot;3&quot; 集合的并集运算 A ∪ B : 属于A或者属于B的元素构成的集合 语法：SUNION key [key ...] 12345127.0.0.1:6379&gt; sunion setA setB1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;4&quot; 获得集合中元素的个数语法：SCARD key 123456127.0.0.1:6379&gt; smembers setA 1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;127.0.0.1:6379&gt; scard setA (integer) 3 从集合中弹出一个元素注意：由于集合是无序的，所有SPOP命令会从集合中随机选择一个元素弹出 语法：SPOP key 12127.0.0.1:6379&gt; spop setA &quot;1&quot; ZSet类型在集合类型的基础上，有序集合类型为集合中的每个元素都关联一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。 在某些方面有序集合和列表类型有些相似： 二者都是有序的。 二者都可以获得某一范围的元素。 但是，二者有着很大区别： 列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。 有序集合类型使用散列表实现，所以即使读取位于中间部分的数据也很快。 列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现） 有序集合要比列表类型更耗内存。 增加元素向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。 语法：ZADD key score member [score member ...] 1234127.0.0.1:6379&gt; zadd scoreboard 80 zhangsan 89 lisi 94 wangwu (integer) 3127.0.0.1:6379&gt; zadd scoreboard 97 lisi (integer) 0 获得排名在某个范围的元素列表按照元素分数从小到大的顺序返回索引从start到stop之间的所有元素（包含两端的元素） 语法：ZRANGE key start stop [WITHSCORES] 1234127.0.0.1:6379&gt; zrange scoreboard 0 21) &quot;zhangsan&quot;2) &quot;wangwu&quot;3) &quot;lisi“ 按照元素分数从大到小的顺序返回索引从start到stop之间的所有元素（包含两端的元素）语法：ZREVRANGE key start stop [WITHSCORES] 1234127.0.0.1:6379&gt; zrevrange scoreboard 0 21) &quot;lisi&quot;2) &quot;wangwu&quot;3) &quot;zhangsan&quot; 如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数 12345127.0.0.1:6379&gt; zrange scoreboard 0 1 WITHSCORES1) &quot;zhangsan&quot;2) &quot;80&quot;3) &quot;wangwu&quot;4) &quot;94&quot; 获取元素的分数语法：ZSCORE key member 12127.0.0.1:6379&gt; zscore scoreboard lisi &quot;97&quot; 删除元素移除有序集key中的一个或多个成员，不存在的成员将被忽略。当key存在但不是有序集类型时，返回一个错误。 语法：ZREM key member [member ...] 12127.0.0.1:6379&gt; zrem scoreboard lisi(integer) 1 获得指定分数范围的元素语法：ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 12345127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 90 97 WITHSCORES1) &quot;wangwu&quot;2) &quot;94&quot;127.0.0.1:6379&gt; ZRANGEBYSCORE scoreboard 70 100 limit 1 21) &quot;wangwu&quot; 增加某个元素的分数返回值是更改后的分数 语法：ZINCRBY key increment member 12127.0.0.1:6379&gt; ZINCRBY scoreboard 4 lisi &quot;101&quot; 获得集合中元素的数量语法：ZCARD key 12127.0.0.1:6379&gt; ZCARD scoreboard(integer) 3 获得指定分数范围内的元素个数语法：ZCOUNT key min max 12127.0.0.1:6379&gt; ZCOUNT scoreboard 80 90(integer) 1 按照排名范围删除元素语法：ZREMRANGEBYRANK key start stop 1234127.0.0.1:6379&gt; ZREMRANGEBYRANK scoreboard 0 1(integer) 2 127.0.0.1:6379&gt; ZRANGE scoreboard 0 -11) &quot;lisi&quot; 按照分数范围删除元素语法：ZREMRANGEBYSCORE key min max 1234127.0.0.1:6379&gt; zadd scoreboard 84 zhangsan (integer) 1127.0.0.1:6379&gt; ZREMRANGEBYSCORE scoreboard 80 100(integer) 1 获取元素的排名 从小到大 语法：ZRANK key member 12127.0.0.1:6379&gt; ZRANK scoreboard lisi (integer) 0 从大到小 语法：ZREVRANK key member 12127.0.0.1:6379&gt; ZREVRANK scoreboard zhangsan (nil) 通用命令keys作用：返回满足给定pattern 的所有key 语法：keys pattern 123456127.0.0.1:6379&gt; keys mylist*1) &quot;mylist&quot;2) &quot;mylist5&quot;3) &quot;mylist6&quot;4) &quot;mylist7&quot;5) &quot;mylist8&quot; del作用：删除指定的key 语法：DEL key 12127.0.0.1:6379&gt; del test(integer) 1 exists作用：确认一个key 是否存在 语法：exists key 示例：从结果来看，数据库中不存在HongWan 这个key，但是age 这个key 是存在的 1234127.0.0.1:6379&gt; exists HongWan(integer) 0127.0.0.1:6379&gt; exists age(integer) 1 expire作用：设置生存时间，到期后数据销毁。 EXPIRE key seconds 设置key的生存时间（单位：秒）key在多少秒后会自动删除 TTL key 查看key生于的生存时间 PERSIST key 清除生存时间 PEXPIRE key milliseconds 生存时间设置单位为：毫秒 123456789101112127.0.0.1:6379&gt; set test 1 设置test的值为1OK127.0.0.1:6379&gt; get test 获取test的值&quot;1&quot;127.0.0.1:6379&gt; EXPIRE test 5 设置test的生存时间为5秒(integer) 1127.0.0.1:6379&gt; TTL test 查看test的生于生成时间还有1秒删除(integer) 1127.0.0.1:6379&gt; TTL test(integer) -2127.0.0.1:6379&gt; get test 获取test的值，已经删除(nil) rename作用：重命名key 语法：rename oldkey newkey 123456127.0.0.1:6379&gt; keys *1) &quot;age&quot;127.0.0.1:6379&gt; rename age age_newOK127.0.0.1:6379&gt; keys *1) &quot;age_new&quot; type作用：显示指定key的数据类型 语法：type key 123456127.0.0.1:6379&gt; type addrstring127.0.0.1:6379&gt; type myzset2zset127.0.0.1:6379&gt; type mylistlist]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux - 常用命令]]></title>
    <url>%2FLinux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[命令的基本格式[root@localhost~] root为用户名（#超级用户 $普通用户） localhost主机名命令的基本格式： 1命令[选项][参数] 查询目录的内容命令格式： 1ls [选项][文件或目录] 选项： -a 所有文件 -l 查看详情 -d 查看目录属性 -h 显示文件大小 文件处理 建立目录 mkdir -p[目录名]-p表示递归创建文件夹 切换目录 cd [目录]简化操作： 1234cd ~ 进入当前用户目录cd - 上次目录cd .. 进入上一级目录pwd 查看当前目录所在位置 删除目录 12rmdir [目录] 删除所有文件rm -rf [目录] 删除目录所有文件 复制目录 cp [选项] [原文件目录] [目标目录] 选项： -r复制目录 -p连文件属性一起复制 -a 相当于-pdr 剪切、改名 mv [原文件目录] [目标文件目录] 常见目录作用 123456789101112131415/ 根目录/bin 命令保存目录/boot 启动目录/dev 设备文件命令/etc 配置文件保存目录/home 家目录/lib 系统库保存命令/mnt 系统挂载目录 文件搜索 locate locate [文件名] 在系统数据库中查找文件。新建的文件，要执行updatedb操作之后才能搜到。 命令搜索 whereis [选项] [命令名] 或者 which [选项][命令名] 选项： -b 只查找可执行文件 -m 只查找帮助文件 文件搜索 find [搜索范围][选项][条件] 举例： 在根目录下查找名为install.log文件find / -name install.log 忽略大小写查找文件find /root -inname install.log find /var/log -mtime +10 其中-mtime 文件修改时间 -atime 文件访问时间 -ctime 改变文件属性时间 +10 10天前 10 10天 -10 10天内 查找文件大于20M的文件find /etc -size +20M 压缩与解压缩常见压缩格式：.zip 、 .gz 、 .bz2、 .tar.gz 、 .tar.bz2 zip格式 压缩文件 zip [压缩文件名][原文件] 压缩目录 zip -r [压缩文件名][原文件] 举例： 12345touch jp/canglstouch jp/longlszip -r jp.zip jp 解压： unzip [压缩文件名] 压缩为gz格式，原文件不保留 gzip [原文件] gz格式 压缩.gz格式，原文件保留 gzip -c 原文件 &gt; 压缩文件 压缩目录： gzip -r 目录 解压： guzip [文件] guzip -r [目录] tar 打包 tar -cvf 打包文件名 原文件 解压 tar -xvf jp.tar tar.gz 打包 tar -zcvf 压缩包名.tar.gz 原文件 解压tar -zxvf 压缩包名.tar.gz 关机、重启shutdown [选项][时间] 选项： -c 取消前一个关机命令 -h 关机 -r 重启 init 6 重启 init 0 关机 logout 退出登陆 查看用户信息w、who、last、lastlog 输出重定向命令&gt;文件 以覆盖的方式，把正确的命令输出到指定文件 命令&gt;&gt;文件 以追加的方式，把正确的命令输出到指定文件、 错误命令 2&gt; 文件 以覆盖的方式把错误的命令覆盖到指定文件 错误命令 2&gt;&gt; 文件 以追击的方式把错误的命令覆盖到指定文件 命令&gt;&gt;文件 2&gt;&amp;1 同时追加正确命令和错误命令到 指定文件 命令 &gt;&gt;文件1 2&gt;&gt;文件2 把正确的命令输出到文件1错误的文件2 网络相关 ifconfig查看ip 举个例子： 123ifconfig&gt;&gt; ip.logcat ip.log 查看网络状态 netstat [选项] 选项： -t: 列出tcp 协议端口 -u: 列出upd协议端口 -n ip地址个端口号 -l 列出监听状态的 -a 所有 查看路由列表 netstat -rn 或者 route -n 查看某域名与自己的电脑的网络状态 ping www.baidu.com vi编辑器vi的升级版是vim vim的操作模式 commond mode 命令模式 inser tmode 编辑模式 lastline mode 底行模式 模式切换 i 进入编辑模式 esc 进入命令行模式 命令模式 vim [文件] 进入文件或者创建文件（文件不存在的情况下） vim + [文件名] 进入文件尾部 vim +/[字符串] [文件名] 光标定位到文件第一次出现该字符串的位置 底行模式 :w 保存 :q退出 :! 强制 :15 定位的第15行 /[字符串] 光标位置向后搜索该字符串 ?[字符串] 光标位置向前搜索该字符串 dd删除光标所在行 ctr+f 向下翻页 ctr+b 向上翻页 常用操作快捷键ctr+c 终止当前命令 ctr+l 清屏 相当于 clear ctr+a 光标移到行首 ctr+e 光标移到行尾 ctr+u 把光标所在位置删除到行首 ctr+z 把命令放入后台 ctr+r 在历史命令中搜索]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~常用命令]]></title>
    <url>%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[git config –global user.name “你的名字” 让你全部的Git仓库绑定你的名字 git config –global user.email “你的邮箱” 让你全部的Git仓库绑定你的邮箱 git init 初始化你的仓库 git add . 把工作区的文件全部提交到暂存区 git add .// 把工作区的文件提交到暂存区 git commit -m “xxx” 把暂存区的所有文件提交到仓库区，暂存区空空荡荡 git remote add origin https://github.com/name/name_cangku.git 把本地仓库与远程仓库连接起来 git push -u origin master 把仓库区的主分支master提交到远程仓库里 git push -u origin &lt;其他分支&gt; 把其他分支提交到远程仓库 git status查看当前仓库的状态 git diff 查看文件修改的具体内容 git log 显示从最近到最远的提交历史 git clone + 仓库地址下载克隆文件 git reset –hard + 版本号 回溯版本，版本号在commit的时候与master跟随在一起 git reflog 显示命令历史 git checkout – 撤销命令，用版本库里的文件替换掉工作区的文件。我觉得就像是Git世界的ctrl + z git rm 删除版本库的文件 git branch 查看当前所有分支 git branch &lt;分支名字&gt; 创建分支 git checkout &lt;分支名字&gt; 切换到分支 git merge &lt;分支名字&gt; 合并分支 git branch -d &lt;分支名字&gt; 删除分支,有可能会删除失败，因为Git会保护没有被合并的分支 git branch -D + &lt;分支名字&gt; 强行删除，丢弃没被合并的分支 git log –graph 查看分支合并图 git merge –no-ff &lt;分支名字&gt; 合并分支的时候禁用Fast forward模式,因为这个模式会丢失分支历史信息 git stash 当有其他任务插进来时，把当前工作现场“存储”起来,以后恢复后继续工作 git stash list 查看你刚刚“存放”起来的工作去哪里了 git stash apply 恢复却不删除stash内容 git stash drop 删除stash内容 git stash pop 恢复的同时把stash内容也删了 git remote 查看远程库的信息，会显示origin，远程仓库默认名称为origin git remote -v 显示更详细的信息 git pull 把最新的提交从远程仓库中抓取下来，在本地合并,和git push相反 git rebase 把分叉的提交历史“整理”成一条直线，看上去更直观 git tag 查看所有标签，可以知道历史版本的tag git tag 打标签，默认为HEAD。比如git tag v1.0 git tag &lt;版本号&gt; 把版本号打上标签，版本号就是commit时，跟在旁边的一串字母数字 git show 查看标签信息 git tag -a -m “&lt;说明&gt;” 创建带说明的标签。-a指定标签名，-m指定说明文字 git tag -d 删除标签 git push origin 推送某个标签到远程 git push origin –tags 一次性推送全部尚未推送到远程的本地标签 git push origin :refs/tags/ 删除远程标签 git config –global color.ui true 让Git显示颜色，会让命令输出看起来更醒目 git add -f 强制提交已忽略的的文件 git check-ignore -v 检查为什么Git会忽略该文件]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java - CompletableFuture]]></title>
    <url>%2FJava-CompletableFuture.html</url>
    <content type="text"><![CDATA[CompletableFuture是Java8中对Future的增强。实现CompletionStage接口(40余个方法)，大多数方法多数应用在函数式编程中，并且支持流式调用。 简单实现： 123456789101112131415161718192021222324252627282930public class CompletableFutureTest implements Runnable &#123; CompletableFuture&lt;Integer&gt; completableFuture = null; public CompletableFutureTest(CompletableFuture&lt;Integer&gt; completableFuture) &#123; this.completableFuture = completableFuture; &#125; @Override public void run() &#123; int result = 0; try &#123; result = completableFuture.get() * completableFuture.get(); &#125; catch (Exception e) &#123; &#125; System.out.println(result); &#125; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; final CompletableFuture&lt;Integer&gt; future = new CompletableFuture&lt;&gt;(); new Thread(new CompletableFutureTest(future)).start(); //模拟长时间的计算过程 Thread.sleep(1000); //告知完成结果 future.complete(60); &#125;&#125; Future最令人诟病的就是要等待，要自己去检查任务是否完成了，在Future中，任务完成的时间是不可控的。而CompletableFuture的最大改进在于，任务完成的时间也开放了出来。 CompletableFuture的异步执行： 12345678910111213141516public static Integer calc(Integer param) &#123; try &#123; //模拟长时间的执行 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; return param * param;&#125;public static void main(String[] args) throws InterruptedException, ExecutionException &#123; //异步调用 final CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; calc(50)); System.out.println(future2.get());&#125; CompletableFuture的流式调用： 1234567891011121314151617181920public static Integer calc(Integer param) &#123; try &#123; //模拟长时间的执行 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; return param * param;&#125;public static void main(String[] args) throws InterruptedException, ExecutionException &#123; //流式调用 CompletableFuture&lt;Void&gt; future3 = CompletableFuture.supplyAsync(() -&gt; calc(40)) .thenApply((i) -&gt; Integer.toString(i)) .thenApply((str) -&gt; "\"" + str + "\"") .thenAccept(System.out::println); future3.get();&#125; 组合多个CompletableFuture： 123456789101112public static Integer calc2(Integer param) &#123; return param / 2;&#125;public static void main(String[] args) throws InterruptedException, ExecutionException &#123; //组合多个CompletableFuture CompletableFuture&lt;Void&gt; future4 = CompletableFuture.supplyAsync(() -&gt; calc2(100)) .thenCompose((i) -&gt; CompletableFuture.supplyAsync(() -&gt; calc2(i))) .thenApply((str) -&gt; "\"" + str + "\"") .thenAccept(System.out::println); future4.get();&#125; CompletableFuture跟性能上关系不大，更多的是为了支持函数式编程，在功能上的增强。当然开放了完成时间的设置是一大亮点。 演示的完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package main.java.com.study.completableFuture;import java.util.concurrent.CompletableFuture;import java.util.concurrent.ExecutionException;/** * @author: whb * @description: 增强版Future测试类 */public class CompletableFutureTest implements Runnable &#123; CompletableFuture&lt;Integer&gt; completableFuture = null; public CompletableFutureTest(CompletableFuture&lt;Integer&gt; completableFuture) &#123; this.completableFuture = completableFuture; &#125; @Override public void run() &#123; int result = 0; try &#123; result = completableFuture.get() * completableFuture.get(); &#125; catch (Exception e) &#123; &#125; System.out.println(result); &#125; public static Integer calc(Integer param) &#123; try &#123; //模拟长时间的执行 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; return param * param; &#125; public static Integer calc2(Integer param) &#123; return param / 2; &#125; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; final CompletableFuture&lt;Integer&gt; future = new CompletableFuture&lt;&gt;(); new Thread(new CompletableFutureTest(future)).start(); //模拟长时间的计算过程 Thread.sleep(1000); //告知完成结果 future.complete(60); //异步调用 final CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; calc(50)); System.out.println(future2.get()); //流式调用 CompletableFuture&lt;Void&gt; future3 = CompletableFuture.supplyAsync(() -&gt; calc(40)) .thenApply((i) -&gt; Integer.toString(i)) .thenApply((str) -&gt; "\"" + str + "\"") .thenAccept(System.out::println); future3.get(); //组合多个CompletableFuture CompletableFuture&lt;Void&gt; future4 = CompletableFuture.supplyAsync(() -&gt; calc2(100)) .thenCompose((i) -&gt; CompletableFuture.supplyAsync(() -&gt; calc2(i))) .thenApply((str) -&gt; "\"" + str + "\"") .thenAccept(System.out::println); future4.get(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java - LongAdder]]></title>
    <url>%2FJava-LongAdder.html</url>
    <content type="text"><![CDATA[CAS有没有问题呢？肯定是有的。比如说大量的线程同时并发修改一个AtomicLong，可能有很多线程会不停的自旋，进入一个无限重复的循环中。这些线程不停地获取值，然后发起CAS操作，但是发现这个值被别人改过了，于是再次进入下一个循环，获取值，发起CAS操作又失败了，再次进入下一个循环。在大量线程高并发更新AtomicLong的时候，这种问题可能会比较明显，导致大量线程空循环，自旋转，性能和效率都不是特别好。于是，Java 8推出了一个新的类，LongAdder，在AtomicLong的基础上进行了热点分离，热点分离类似于有锁操作中的减小锁粒度，尝试使用分段CAS以及自动分段迁移的方式来大幅度提升多线程高并发执行CAS操作的性能！在无锁中，也可以用类似的方式来增加CAS的成功率，从而提高性能。LongAdder原理如下图： AtomicLong的实现方式是内部有个value 变量，当多线程并发自增，自减时，均通过CAS 指令从机器指令级别操作保证并发的原子性。唯一会制约AtomicLong高效的原因是高并发，高并发意味着CAS的失败几率更高， 重试次数更多，越多线程重试，CAS失败几率又越高，变成恶性循环，AtomicLong效率降低。 在LongAdder的底层实现中，首先有一个base值，刚开始多线程来不停的累加数值，都是对base进行累加的，比如刚开始累加成了base = 5。接着如果发现并发更新的线程数量过多，就会开始施行分段CAS的机制，也就是内部会搞一个Cell数组，每个数组是一个数值分段。这时，让大量的线程分别去对不同Cell内部的value值进行CAS累加操作，这样就把CAS计算压力分散到了不同的Cell分段数值中了！这样就可以大幅度的降低多线程并发更新同一个数值时出现的无限循环的问题，大幅度提升了多线程并发更新数值的性能和效率！而且他内部实现了自动分段迁移的机制，也就是如果某个Cell的value执行CAS失败了，那么就会自动去找另外一个Cell分段内的value值进行CAS操作。这样也解决了线程空旋转、自旋不停等待执行CAS操作的问题，让一个线程过来执行CAS时可以尽快的完成这个操作。最后，如果你要从LongAdder中获取当前累加的总值，就会把base值和所有Cell分段数值加起来返回给你。LongAdder是一种以空间换时间的策略。]]></content>
      <categories>
        <category>Java</category>
        <category>J.U.C</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J.U.C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由剔除Intellij中Mybatis的Mapper自动注入警告引入对注解的学习]]></title>
    <url>%2F%E7%94%B1%E5%89%94%E9%99%A4Intellij%E4%B8%ADMybatis%E7%9A%84Mapper%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E8%AD%A6%E5%91%8A%E5%BC%95%E5%85%A5%E5%AF%B9%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[起源相信使用Mybatis的小伙们一定经常编写类似如下的代码： 可以看到 userMapper 下有个红色警告。虽然代码本身并没有问题，能正常运行，但有个警告总归有点恶心。先看下警告信息： Spring team recommends: “Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies.” 原因众所周知，IDEA是非常智能的，它可以理解Spring的上下文。然而 UserMapper 这个接口是Mybatis的，IDEA理解不了。 而 @Autowired 注解，默认情况下要求依赖对象（也就是 userMapper ）必须存在。而IDEA认为这个对象的实例/代理是个null，所以就友好地给个提示。按照提示修改如下： 123456private final UserMapper userMapper;@Autowiredpublic UserServiceImpl(UserMapper userMapper) &#123; this.userMapper = userMapper;&#125; 此时仍然存在一个问题： 1Could not autowire. 自动注入 bean， spring帮助我们完成了，但是同时Spring提供了一些注解来显式的注明bean之间的引用关系，其中最为熟知的自然是@Controller,@Service,@Repository,@Component等。这里其实给UserMapper接口加上@Repository,@Component就可以解决，那么他们之间有什么区别？ 区别Spring不但支持自己定义的@Autowired注解，还支持几个由JSR-250规范定义的注解，它们分别是@Resource、@PostConstruct以及@PreDestroy。 @Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 @Resource装配顺序 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； @Autowired 与@Resource的区别 1、@Autowired与@Resource都可以用来装配bean. 都可以写在字段上,或写在setter方法上。 2、@Autowired默认按类型装配（这个注解是属于spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用，如下： 12@Autowired()@Qualifier("baseDao")privateBaseDao baseDao; 3、@Resource（这个注解属于J2EE的），默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行装配查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 12@Resource(name="baseDao")privateBaseDao baseDao; 推荐使用：@Resource注解在字段上，这样就不用写setter方法了，并且这个注解是属于J2EE的，减少了与spring的耦合。这样代码看起就比较优雅。 Spring @Qualifier注解@Autowired是根据类型进行自动装配的。如果当Spring上下文中存在不止一个UserDao类型的bean时，就会抛出BeanCreationException异常;如果Spring上下文中不存在UserDao类型的bean，也会抛出BeanCreationException异常。我们可以使用@Qualifier配合@Autowired来解决这些问题。如下： 可能存在多个UserDao实例 123@Autowired @Qualifier("userServiceImpl") public IUserService userService; 或者 1234@Autowired public void setUserDao(@Qualifier("userDao") UserDao userDao) &#123; this.userDao = userDao; &#125; 这样Spring会找到id为userServiceImpl和userDao的bean进行装配。 可能不存在UserDao实例 12@Autowired(required = false) public IUserService userService 总结@Autowired 默认按type注入@Qualifier(“baseDao”) 一般作为@Autowired()的修饰用@Resource(name=”baseDao”) 默认按name注入，可以通过name和type属性进行选择性注入 一般@Autowired和@Qualifier一起用，@Resource单独用。当然没有冲突的话@Autowired也可以单独用。 常用注解声明Bean的注解1234//定义控制层Bean,如Action@Controller@Controller("Bean的名称") 1234//定义业务逻辑层Bean@Service @Service("Bean的名称") 1234//定义DAO层/数据访问层Bean@Repository @Repository("Bean的名称") 12//定义Bean, 不好归类时使用.@Component 自动装配Bean12//默认按类型匹配,自动装配(Srping提供的)，可以写在成员属性上,或写在setter方法上@Autowired 12//一定要找到匹配的Bean，否则抛异常。 默认值就是true@Autowired(required=true) 123//按名称装配Bean,与@Autowired组合使用，解决按类型匹配找到多个Bean问题。@Autowired@Qualifier("bean的名字") 123456//JSR-250提供的,默认按名称装配,当找不到名称匹配的bean再按类型装配.可以写在成员属性上,或写在setter方法上@Resource //可以通过@Resource(name="beanName") 指定被注入的bean的名称, 要是未指定name属性, 默认使用成员属性的变量名,一般不用写name属性.@Resource(name="beanName") 12//是JSR-330提供的,按类型装配，功能比@Autowired少，没有使用的必要。@Inject Java配置类 @Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上） @Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上） @Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean（类上） @ComponentScan 用于对Component进行扫描，相当于xml中的（类上） @WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解 切面（AOP）Spring支持AspectJ的注解式切面编程。 @Aspect 声明一个切面（类上） 使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。 @After 在方法执行之后执行（方法上） @Before 在方法执行之前执行（方法上） @Around 在方法执行之前与之后执行（方法上） @PointCut 声明切点 在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上） 定义Bean的作用域和生命过程1234567891011121314//设置Spring容器如何新建Bean实例（方法上，得有@Bean）@Scope("prototype")其设置类型包括：Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）,Protetype （每次调用新建一个bean）,Request （web项目中，给每个http request新建一个bean）,Session （web项目中，给每个http session新建一个bean）,GlobalSession（给每一个 global http session新建一个Bean实例） 12//相当于init-method,使用在方法上，当Bean初始化时执行。@PostConstruct 12//相当于destory-method，使用在方法上，当Bean销毁时执行。@PreDestroy 声明式事务1@Transactional @Value@Value 为属性注入值（属性上）支持如下方式的注入： 注入普通字符 12@Value("Tom")String name; 注入操作系统属性 12@Value("#&#123;systemProperties['os.name']&#125;")String osName; 注入表达式结果 12@Value("#&#123;T(java.lang.Math).random() * 100&#125;")String randomNumber; 注入其他bean属性 12@Value("#&#123;demoClass.name&#125;")String name; 注入文件资源 12@Value("classpath:com/springboot/study/hello/test.txt")String resourceFile; 注入网站资源 12@Value("http://www.baiduc.om")Resource url; 注入配置文件 12@Value("$&#123;book.name&#125;")String bookName; 环境切换 @Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上） @Conditional Spring4中可以使用此注解定义条件化的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上） 异步 @EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上） @Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上所有的方法都将异步，需要@EnableAsync开启异步任务） 定时任务 @EnableScheduling 在配置类上使用，开启计划任务的支持（类上） @Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持） @Enable*这些注解主要用来开启对xxx的支持。 @EnableAspectJAutoProxy 开启对AspectJ自动代理的支持 @EnableAsync 开启异步方法的支持 @EnableScheduling 开启计划任务的支持 @EnableWebMvc 开启Web MVC的配置支持 @EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持 @EnableJpaRepositories 开启对SpringData JPA Repository的支持 @EnableTransactionManagement 开启注解式事务的支持 @EnableCaching 开启注解式的缓存支持 测试@RunWith 运行器，Spring中通常用于对JUnit的支持 1@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类 1@ContextConfiguration(classes=&#123;Test.class&#125;) SpringMVC @EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。 @Controller 声明该类为SpringMVC中的Controller @RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上） @ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上） @RequestBody 允许request的参数在request体中，而不是直接连接在地址后面。（放在参数前） @PathVariable 用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数前，即可获取该值，通常作为Restful的接口实现方法。 @RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。 @ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上，这对所有注解了 @RequestMapping的控制器内的方法有效。 @ExceptionHandler 用于全局处理控制器里的异常 @InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。 @ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。 为什么建议构造器注入构造器注入与域注入 热门文章 Why field injection is evil 给出总结：Field injection: less code to write; unsafe code; more complicated to test; Constructor injection: safe code; more code to write (see the hint to Lombok); easy to test; Spring 的博客上指出 Setter injection versus constructor injection and the use of @Required 解决方案书归正传，说下如何剔除Intellij中Mybatis的Mapper自动注入警告。 方法1：为 @Autowired 注解设置required = false 使用 @Autowired 注解时，若希望允许null值，可设置required = false，像这样： 12@Autowired(required = false)private UserMapper userMapper; 这样就不会有警告了。原因很好理解：IDEA认为userMapper是个null，给了警告；加上required = false后，使用 @Autowired 注解不再去校验userMapper是否存在了。也就不会有警告了。 方法2：用 @Resource 替换 @Autowired 12@Resourceprivate UserMapper userMapper; 方法3：在Mapper接口上加上@Repository注解 123@Repositorypublic interface UserMapper extends Mapper&lt;User&gt; &#123;&#125; 这样也能让你的 12@Autowiredprivate UserMapper userMapper; 不再报错。当然，如果你用@Component替换@Repository也是可以的。原理大致：IDEA不是认为 userMapper 是个null嘛…加个@Repository注解骗一下IDEA就OK了…… 方法4：用Lombok 123456@Service@RequiredArgsConstructor(onConstructor = @__(@Autowired))public class TestService &#123; private final UserMapper userMapper; ...&#125; Lombok生成的代码是这样的： 123456789@Servicepublic class TestService &#123; private final UserMapper userMapper; @Autowired public TestService(final UserMapper userMapper) &#123; this.userMapper = userMapper; &#125; ...&#125; 但如果自己手写成Lombok生成的代码，IDEA依然会给你报警告 。我猜，应该是IDEA的Lombok插件把IDEA搞懵逼了…所以不提示了… 方法5：把IDEA的警告关闭掉个人没试过。 方法6：安装mybatis plugin据说安装mybatis plugin可以解决该问题。]]></content>
      <categories>
        <category>Spring</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写RPC-升级版]]></title>
    <url>%2F%E6%89%8B%E5%86%99RPC-%E5%8D%87%E7%BA%A7%E7%89%88.html</url>
    <content type="text"><![CDATA[概述手写RPC-简易版 ，实现了一个很简单的RPC调用示例，其中还存在很多问题及可优化的点，这次做个升级，完全重写之前的代码，使得代码逻辑更加规范，同时引入Zookeeper辅助完成服务治理。在代码展示前，先介绍下Zookeeper、服务治理等概念。 ZookeeperZooKeeper（简称zk）是一个分布式、开源的应用协调服务，利用和Paxos类似的ZAB选举算法实现分布式一致性服务。有类似于Unix文件目录的节点信息，同时可以针对节点的变更添加watcher监听以能够及时感知到节点信息变更。可提供的功能例如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。如下图就是DUBBO存储在ZooKeeper的节点数据情况： 在本地启动服务后通过zk客户端连接后也可通过命令查看节点信息，如下图所示。 ZooKeeper包含了4种不同含义的功能节点，在每次创建节点之前都需要明确声明节点类型: 类型 定义 描述 PERSISTENT 持久化目录节点 客户端与zookeeper断开连接后，该节点依旧存在 PERSISTENT_SEQUENTIAL 持久化顺序编号目录节点 客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号 EPHEMERAL 临时目录节点 客户端与zookeeper断开连接后，该节点被删除 EPHEMERAL_SEQUENTIAL 临时顺序编号目录节点 客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号 ZooKeeper使用之前需要先进行安装，后开启服务端的服务， 我们的服务作为客户端连接ZooKeeper以便于后续的操作。具体可参考官网文档Zookeeper3.5.5 官方文档，在实际的java项目开发中也是可以通过maven引入ZkClient或者Curator开源的客户端，在本文学习笔记中是使用的Curator，因为其已经封装了原始的节点注册、数据获取、添加watcher等功能。具体maven引入的版本如下： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;4.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;4.2.0&lt;/version&gt;&lt;/dependency&gt; 服务治理服务治理也就是针对服务进行管理的措施，例如 服务发现、 服务暴露、 负载均衡、 快速上下线等都是服务治理的具体体现。 服务发现：从服务管理中心获取到需要的服务相关信息，例如可以从zk中获取相关服务的机器信息，然后就可以和具体机器直连完成相关功能。 服务暴露：服务提供方可以提供什么样子的功能，经过服务暴露暴露出去，其他使用方就可以通过服务发现发现具体的服务提供方信息。 负载均衡：一般针对的是服务提供方，避免大量请求同时打到一台机器上，采用随机、轮询等措施让请求均分到各个机器上，提供服务效率， 限流， 灰度等也都是类似的操作，通过动态路由、软负载的形式处理分发请求。 快速上线下：以往需要上下线可能需要杀掉机器上的进程，现在只需要让该服务停止暴露即可，实现服务的灵活上下线。 数据处理流程服务端：服务的提供方，接受网络传输的请求数据、通过网络把应答数据发送给客户端; 客户端：服务的调用方，使用本地代理，通过网络把请求数据发送出去，接受服务端返回的应答数据. 所有的数据传输都是按照上面图片说的流程来的，如果需要添加自定义的序列化工具，则需要在把数据提交到socket的输出流缓冲区之前按照序列化工具完成序列化操作，反序列化则进行反向操作即可。 RPC V2版本文件夹目录如下图所示： balance文件夹：负载均衡有关； config文件夹：网络套接字传输的数据模型以及服务暴露、服务发现的数据模型； core文件夹：核心文件夹，包含了服务端和客户端的请求处理、代理生成等； demo文件夹：测试使用； domain文件夹：模型、枚举常量； io.protocol文件夹：目前是只有具体的请求对象和网络io的封装； register文件夹：服务注册使用，实现了使用zk进行服务注册和服务发现的操作； serialize文件夹：序列化、反序列化，实现了Java和Hessian两种。 服务注册&amp;服务发现ServiceRegister：123456789101112131415161718192021222324252627282930package com.springboot.whb.study.rpc.rpc_v2.register;import com.springboot.whb.study.rpc.rpc_v2.config.BasicConfig;import com.springboot.whb.study.rpc.rpc_v2.core.RpcRequest;import com.springboot.whb.study.rpc.rpc_v2.domain.ServiceType;import java.net.InetSocketAddress;/** * @author: whb * @description: 服务注册 */public interface ServiceRegister &#123; /** * 服务注册 * * @param config */ void register(BasicConfig config); /** * 服务发现，从注册中心获取可用的服务提供方信息 * * @param request * @param nodeType * @return */ InetSocketAddress discovery(RpcRequest request, ServiceType nodeType);&#125; ZkServiceRegister默认使用了CuratorFramework客户端完成zk数据的操作. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package com.springboot.whb.study.rpc.rpc_v2.register;import com.springboot.whb.study.rpc.rpc_v2.balance.DefaultLoadBalance;import com.springboot.whb.study.rpc.rpc_v2.balance.LoadBalance;import com.springboot.whb.study.rpc.rpc_v2.config.BasicConfig;import com.springboot.whb.study.rpc.rpc_v2.core.RpcRequest;import com.springboot.whb.study.rpc.rpc_v2.domain.ServiceType;import lombok.extern.slf4j.Slf4j;import org.apache.curator.RetryPolicy;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.retry.ExponentialBackoffRetry;import org.apache.zookeeper.CreateMode;import java.net.InetSocketAddress;import java.util.List;/** * @author: whb * @description: Zookeeper服务注册实现类 */@Slf4jpublic class ZkServiceRegister implements ServiceRegister &#123; private CuratorFramework client; private static final String ROOT_PATH = "whb/demo-rpc"; private LoadBalance loadBalance = new DefaultLoadBalance(); public ZkServiceRegister() &#123; //重试策略 RetryPolicy policy = new ExponentialBackoffRetry(1000, 3); this.client = CuratorFrameworkFactory .builder() .connectString("127.0.0.1:2181") .sessionTimeoutMs(50000) .retryPolicy(policy) .namespace(ROOT_PATH) .build(); // 业务的根路径是 /whb/demo-rpc ,其他的都会默认挂载在这里 this.client.start(); System.out.println("zk启动正常"); &#125; /** * 服务注册 * * @param config */ @Override public void register(BasicConfig config) &#123; String interfacePath = "/" + config.getInterfaceName(); try &#123; if (this.client.checkExists().forPath(interfacePath) == null) &#123; // 创建 服务的永久节点 this.client.create() .creatingParentsIfNeeded() .withMode(CreateMode.PERSISTENT) .forPath(interfacePath); &#125; config.getMethods().forEach(method -&gt; &#123; String methodPath = null; try &#123; ServiceType serviceType = config.getType(); if (serviceType == ServiceType.PROVIDER) &#123; // 服务提供方，需要暴露自身的ip、port信息，而消费端则不需要 String address = getServiceAddress(config); methodPath = String.format("%s/%s/%s/%s", interfacePath, serviceType.getType(), method.getMethodName(), address); &#125; else &#123; methodPath = String.format("%s/%s/%s", interfacePath, serviceType.getType(), method.getMethodName()); &#125; log.info("zk path: [" + ROOT_PATH + methodPath + "]"); // 创建临时节点，节点包含了服务提供段的信息 this.client.create() .creatingParentsIfNeeded() .withMode(CreateMode.EPHEMERAL) .forPath(methodPath, "0".getBytes()); &#125; catch (Exception e) &#123; log.error("创建临时节点[" + methodPath + "]失败，error:&#123;&#125;", e); &#125; &#125;); &#125; catch (Exception e) &#123; log.error("创建服务节点失败，error:&#123;&#125;", e); &#125; &#125; /** * 服务发现 * * @param request * @param nodeType * @return */ @Override public InetSocketAddress discovery(RpcRequest request, ServiceType nodeType) &#123; String path = String.format("/%s/%s/%s", request.getClassName(), nodeType.getType(), request.getMethodName()); try &#123; List&lt;String&gt; addressList = this.client.getChildren().forPath(path); // 采用负载均衡的方式获取服务提供方信息,不过并没有添加watcher监听模式 String address = loadBalance.balance(addressList); if (address == null) &#123; return null; &#125; return parseAddress(address); &#125; catch (Exception e) &#123; log.error("服务发现接口异常，error:&#123;&#125;", e); &#125; return null; &#125; /** * 获取服务地址 * * @param config * @return */ private String getServiceAddress(BasicConfig config) &#123; String hostInfo = new StringBuilder() .append(config.getHost()) .append(":") .append(config.getPort()) .toString(); return hostInfo; &#125; /** * 封装端口 * * @param address * @return */ private InetSocketAddress parseAddress(String address) &#123; String[] result = address.split(":"); return new InetSocketAddress(result[0], Integer.valueOf(result[1])); &#125; /** * 设置负载均衡策略 * * @param loadBalance */ public void setLoadBalance(LoadBalance loadBalance) &#123; this.loadBalance = loadBalance; &#125;&#125; 负载均衡LoadBalance123456789101112131415161718package com.springboot.whb.study.rpc.rpc_v2.balance;import java.util.List;/** * @author: whb * @description: 负载均衡接口定义 */public interface LoadBalance &#123; /** * 负载均衡 * * @param addressList * @return */ String balance(List&lt;String&gt; addressList);&#125; AbstractLoadBalance1234567891011121314151617181920212223242526272829package com.springboot.whb.study.rpc.rpc_v2.balance;import java.util.List;/** * @author: whb * @description: 抽象负载均衡 */public abstract class AbstractLoadBalance implements LoadBalance &#123; @Override public String balance(List&lt;String&gt; addressList) &#123; if (addressList == null || addressList.isEmpty()) &#123; return null; &#125; if (addressList.size() == 1) &#123; return addressList.get(0); &#125; return doLoad(addressList); &#125; /** * 抽象接口，让子类去实现 * * @param addressList * @return */ abstract String doLoad(List&lt;String&gt; addressList);&#125; DefaultLoadBalance123456789101112131415161718package com.springboot.whb.study.rpc.rpc_v2.balance;import java.util.List;import java.util.Random;/** * @author: whb * @description: 默认负载均衡--随机负载均衡 */public class DefaultLoadBalance extends AbstractLoadBalance &#123; @Override String doLoad(List&lt;String&gt; addressList) &#123; //随机 Random random = new Random(); return addressList.get(random.nextInt(addressList.size())); &#125;&#125; 消息协议MessageProtocol12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.springboot.whb.study.rpc.rpc_v2.io.protocol;import com.springboot.whb.study.rpc.rpc_v2.core.RpcRequest;import com.springboot.whb.study.rpc.rpc_v2.core.RpcResponse;import java.io.InputStream;import java.io.OutputStream;/** * @author: whb * @description: 请求、应答 解析和反解析，包含了序列化以及反序列化操作 */public interface MessageProtocol &#123; /** * 服务端解析从网络传输的数据，转变成request对象 * * @param inputStream * @return */ RpcRequest serviceToRequest(InputStream inputStream); /** * 服务端把计算的结果包装好，通过输出流返回给客户端 * * @param response * @param outputStream * @param &lt;T&gt; */ &lt;T&gt; void serviceGetResponse(RpcResponse&lt;T&gt; response, OutputStream outputStream); /** * 客户端把请求拼接好，通过输出流发送到服务端 * * @param request * @param outputStream */ void clientToRequest(RpcRequest request, OutputStream outputStream); /** * 客户端接收到服务端响应的结果，转变成response对象 * * @param inputStream */ &lt;T&gt; RpcResponse&lt;T&gt; clientGetResponse(InputStream inputStream);&#125; DefaultMessageProtocol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188package com.springboot.whb.study.rpc.rpc_v2.io.protocol;import com.springboot.whb.study.rpc.rpc_v2.core.RpcRequest;import com.springboot.whb.study.rpc.rpc_v2.core.RpcResponse;import com.springboot.whb.study.rpc.rpc_v2.serialize.HessianSerialize;import com.springboot.whb.study.rpc.rpc_v2.serialize.SerializeProtocol;import lombok.extern.slf4j.Slf4j;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.Arrays;/** * @author: whb * @description: 套接字的io流和服务端、客户端的数据传输 */@Slf4jpublic class DefaultMessageProtocol implements MessageProtocol &#123; /** * 序列化协议 */ private SerializeProtocol serializeProtocol; public DefaultMessageProtocol() &#123; this.serializeProtocol = new HessianSerialize(); //this.serializeProtocol = new JavaInnerSerialize(); &#125; public void setSerializeProtocol(SerializeProtocol serializeProtocol) &#123; // 可替换序列化协议 this.serializeProtocol = serializeProtocol; &#125; /** * 服务端解析从网络传输的数据，转变成request对象 * * @param inputStream * @return */ @Override public RpcRequest serviceToRequest(InputStream inputStream) &#123; try &#123; // 2、bytes -&gt; request 反序列化 byte[] bytes = readBytes(inputStream); System.out.println("[2]服务端反序列化出obj:[" + new String(bytes) + "], length:" + bytes.length); //System.out.println("[2]服务端反序列化出obj length:" + bytes.length); RpcRequest request = serializeProtocol.deserialize(RpcRequest.class, bytes); return request; &#125; catch (Exception e) &#123; log.error("[2]服务端反序列化从网络传输的数据转变成request对象失败，error:&#123;&#125;", e); &#125; return null; &#125; /** * 服务端把计算的结果包装好，通过输出流返回给客户端 * * @param response * @param outputStream * @param &lt;T&gt; */ @Override public &lt;T&gt; void serviceGetResponse(RpcResponse&lt;T&gt; response, OutputStream outputStream) &#123; try &#123; // 3、把response 序列化成bytes 传给客户端 byte[] bytes = serializeProtocol.serialize(RpcResponse.class, response); System.out.println("[3]服务端序列化出bytes:[" + new String(bytes) + "], length:" + bytes.length); //System.out.println("[3]服务端序列化出bytes length:" + bytes.length); outputStream.write(bytes); &#125; catch (Exception e) &#123; log.error("[3]服务端序列化计算的结果出输给客户端失败，error:&#123;&#125;", e); &#125; &#125; /** * 客户端把请求拼接好，通过输出流发送到服务端 * * @param request * @param outputStream */ @Override public void clientToRequest(RpcRequest request, OutputStream outputStream) &#123; try &#123; // 1、先把这个request -&gt; bytes 序列化掉 byte[] bytes = serializeProtocol.serialize(RpcRequest.class, request); System.out.println("[1]客户端序列化出bytes:[" + new String(bytes) + "], length:" + bytes.length); //System.out.println("[1]客户端序列化出bytes length:" + bytes.length); outputStream.write(bytes); &#125; catch (IOException e) &#123; log.error("[1]客户端序列化请求参数失败，error:&#123;&#125;", e); &#125; &#125; /** * 客户端接收到服务端响应的结果，转变成response对象 * * @param inputStream */ @Override public &lt;T&gt; RpcResponse&lt;T&gt; clientGetResponse(InputStream inputStream) &#123; try &#123; // 4、bytes 反序列化成response byte[] bytes = readBytes(inputStream); System.out.println("[4]客户端反序列化出bytes:[" + new String(bytes) + "], length:" + bytes.length); //System.out.println("[4]客户端反序列化出bytes length:" + bytes.length); RpcResponse response = serializeProtocol.deserialize(RpcResponse.class, bytes); return response; &#125; catch (Exception e) &#123; log.error("[4]客户端反序列化计算结果失败，error:&#123;&#125;", e); &#125; return null; &#125; /** * 流转二进制数组 * * @param inputStream * @return * @throws IOException */ private byte[] readBytes(InputStream inputStream) throws IOException &#123; if (inputStream == null) &#123; throw new RuntimeException("输入流为空"); &#125; return inputStreamToByteArr2(inputStream); &#125; /** * 流转二进制数组方法1 * * @param inputStream * @return * @throws IOException */ private byte[] inputStreamToByteArr1(InputStream inputStream) throws IOException &#123; // 有个前提是数据最大是1024，并没有迭代读取数据 byte[] bytes = new byte[1024]; int count = inputStream.read(bytes, 0, 1024); return Arrays.copyOf(bytes, count); &#125; /** * 流转二进制数组方法2 * * @param inputStream * @return * @throws IOException */ private byte[] inputStreamToByteArr2(InputStream inputStream) throws IOException &#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); int bufesize = 1024; while (true) &#123; byte[] data = new byte[bufesize]; int count = inputStream.read(data, 0, bufesize); byteArrayOutputStream.write(data, 0, count); if (count &lt; bufesize) &#123; break; &#125; &#125; return byteArrayOutputStream.toByteArray(); &#125; /** * 流转二进制数组方法3，调用该方法之后会阻塞在read，可通过jstack查看相关信息 * * @param inputStream * @return * @throws IOException */ private byte[] inputStreamToByteArr3(InputStream inputStream) throws IOException &#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); int bufesize = 1024; byte[] buff = new byte[bufesize]; int rc = 0; while ((rc = inputStream.read(buff, 0, bufesize)) &gt; 0) &#123; byteArrayOutputStream.write(buff, 0, rc); buff = new byte[bufesize]; &#125; byte[] bytes = byteArrayOutputStream.toByteArray(); return bytes; &#125;&#125; 数据传输模型ArgumentConfig12345678910111213141516171819202122232425package com.springboot.whb.study.rpc.rpc_v2.config;import lombok.Data;import java.io.Serializable;/** * @author: whb * @description: 参数配置 */@Datapublic class ArgumentConfig implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 第几个参数 */ private int index; /** * 参数类型 */ private String type;&#125; BasicConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.springboot.whb.study.rpc.rpc_v2.config;import com.springboot.whb.study.rpc.rpc_v2.domain.ServiceType;import lombok.Data;import java.util.List;/** * @author: whb * @description: 基础配置 */@Datapublic class BasicConfig &#123; /** * 地址 */ private String host; /** * 端口号 */ private int port; /** * 服务提供方还是服务消费方 */ private ServiceType type; /** * 接口名 */ private String interfaceName; /** * 接口类 */ private Class&lt;?&gt; interfaceClass; /** * 方法集合 */ private List&lt;MethodConfig&gt; methods; /** * 分组 */ private String group; /** * 默认版本号是default */ private String version = "default";&#125; ClientConfig1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.springboot.whb.study.rpc.rpc_v2.config;import com.springboot.whb.study.rpc.rpc_v2.core.ProxyInstance;import com.springboot.whb.study.rpc.rpc_v2.domain.ServiceType;import lombok.Data;import java.io.Serializable;import java.lang.reflect.Proxy;/** * @author: whb * @description: 客户端配置 */@Datapublic class ClientConfig&lt;T&gt; extends BasicConfig implements Serializable &#123; private static final long serialVersionUID = 1L; private T proxy; /** * 反射包装成客户端参数配置对象 * * @param interfaceClass * @param invocationHandler * @param &lt;T&gt; * @return */ public static &lt;T&gt; ClientConfig&lt;T&gt; convert(Class&lt;T&gt; interfaceClass, ProxyInstance invocationHandler) &#123; ClientConfig&lt;T&gt; config = new ClientConfig&lt;&gt;(); config.setVersion("default"); config.setInterfaceClass(interfaceClass); config.setInterfaceName(interfaceClass.getName()); config.setMethods(MethodConfig.convert(interfaceClass.getMethods())); config.setType(ServiceType.CONSUMER); Object proxy = Proxy.newProxyInstance(ClientConfig.class.getClassLoader(), new Class&lt;?&gt;[]&#123;interfaceClass&#125;, invocationHandler); config.setProxy((T) proxy); return config; &#125;&#125; MethodConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.springboot.whb.study.rpc.rpc_v2.config;import lombok.Data;import java.io.Serializable;import java.lang.reflect.Method;import java.lang.reflect.Parameter;import java.util.ArrayList;import java.util.List;/** * @author: whb * @description: 方法配置 */@Datapublic class MethodConfig implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 方法名 */ private String methodName; /** * 参数 */ private List&lt;ArgumentConfig&gt; argumentConfigs; /** * 是否需要返回 */ private Boolean isReturn; /** * 返回值类型 */ private Class&lt;?&gt; returnType; /** * 方法数组转方法配置集合 * * @param methods * @return */ public static List&lt;MethodConfig&gt; convert(Method[] methods) &#123; List&lt;MethodConfig&gt; methodConfigList = new ArrayList&lt;&gt;(methods.length); MethodConfig methodConfig = null; for (Method method : methods) &#123; methodConfig = new MethodConfig(); methodConfig.setMethodName(method.getName()); Class&lt;?&gt; returnType = method.getReturnType(); String returnName = returnType.getName(); if ("void".equals(returnName)) &#123; methodConfig.setIsReturn(false); &#125; else &#123; methodConfig.setIsReturn(true); &#125; methodConfig.setReturnType(returnType); methodConfig.setArgumentConfigs(convert(method.getParameters())); methodConfigList.add(methodConfig); &#125; return methodConfigList; &#125; /** * 参数数组转参数配置集合 * * @param parameters * @return */ private static List&lt;ArgumentConfig&gt; convert(Parameter[] parameters) &#123; List&lt;ArgumentConfig&gt; argumentConfigs = new ArrayList&lt;&gt;(parameters.length); int start = 0; ArgumentConfig argumentConfig = null; for (Parameter parameter : parameters) &#123; argumentConfig = new ArgumentConfig(); argumentConfig.setIndex(start); argumentConfig.setType(parameter.getType().getName()); argumentConfigs.add(argumentConfig); start += 1; &#125; return argumentConfigs; &#125;&#125; ServiceConfig1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.springboot.whb.study.rpc.rpc_v2.config;import com.alibaba.fastjson.JSON;import com.springboot.whb.study.rpc.rpc_v2.core.RpcService;import com.springboot.whb.study.rpc.rpc_v2.domain.ServiceType;import lombok.Data;import lombok.extern.slf4j.Slf4j;import java.io.Serializable;import java.net.InetAddress;import java.net.UnknownHostException;/** * @author: whb * @description: 服务方配置 */@Data@Slf4jpublic class ServiceConfig&lt;T&gt; extends BasicConfig implements Serializable &#123; private static final long serialVersionUID = 1L; private T ref; /** * 统计调用次数使用 */ private int count; @Override public String toString() &#123; return JSON.toJSONString(this); &#125; public static &lt;T&gt; ServiceConfig&lt;T&gt; convert(String interfaceName, Class&lt;T&gt; interfaceClass, T ref, RpcService rpcService) &#123; ServiceConfig&lt;T&gt; serviceConfig = new ServiceConfig&lt;&gt;(); serviceConfig.setRef(ref); serviceConfig.setInterfaceName(interfaceName); serviceConfig.setInterfaceClass(interfaceClass); serviceConfig.setCount(0); serviceConfig.setMethods(MethodConfig.convert(interfaceClass.getMethods())); serviceConfig.setPort(rpcService.getPort()); serviceConfig.setType(ServiceType.PROVIDER); try &#123; InetAddress addr = InetAddress.getLocalHost(); serviceConfig.setHost(addr.getHostAddress()); &#125; catch (UnknownHostException e) &#123; log.error("服务方获取本机地址失败，error:&#123;&#125;", e); &#125; return serviceConfig; &#125;&#125; 枚举常量ServiceType123456789101112131415161718192021222324252627package com.springboot.whb.study.rpc.rpc_v2.domain;/** * @author: whb * @description: 服务类型枚举常量 */public enum ServiceType &#123; /** * 服务提供者 */ PROVIDER("provider"), /** * 服务消费者 */ CONSUMER("consumer"); private String type; ServiceType(String type) &#123; this.type = type; &#125; public String getType() &#123; return type; &#125;&#125; 序列化、反序列化SerializeProtocol123456789101112131415161718package com.springboot.whb.study.rpc.rpc_v2.serialize;/** * @author: whb * @description: 序列化协议接口 */public interface SerializeProtocol &#123; /** * 序列化 */ &lt;T&gt; byte[] serialize(Class&lt;T&gt; clazz, T t); /** * 反序列化 */ &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);&#125; JavaInnerSerialize1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.springboot.whb.study.rpc.rpc_v2.serialize;import lombok.extern.slf4j.Slf4j;import java.io.*;/** * @author: whb * @description: Java序列化 */@Slf4jpublic class JavaInnerSerialize implements SerializeProtocol &#123; /** * 序列化 * * @param clazz * @param t * @param &lt;T&gt; * @return */ @Override public &lt;T&gt; byte[] serialize(Class&lt;T&gt; clazz, T t) &#123; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = null; try &#123; objectOutputStream = new ObjectOutputStream(outputStream); objectOutputStream.writeObject(t); objectOutputStream.flush(); byte[] bytes = outputStream.toByteArray(); return bytes; &#125; catch (Exception e) &#123; log.error("Java 序列化失败，error:&#123;&#125;", e); &#125; finally &#123; if (outputStream != null) &#123; try &#123; outputStream.close(); &#125; catch (IOException e) &#123; log.error("Java 序列化关闭二进制输出流失败,error:&#123;&#125;", e); &#125; &#125; if (objectOutputStream != null) &#123; try &#123; objectOutputStream.close(); &#125; catch (IOException e) &#123; log.error("Java 序列化关闭对象流失败，error:&#123;&#125;", e); &#125; &#125; &#125; return null; &#125; /** * 反序列化 * * @param clazz * @param bytes * @param &lt;T&gt; * @return */ @Override public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123; ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes); ObjectInputStream objectInputStream = null; try &#123; objectInputStream = new ObjectInputStream(inputStream); T obj = (T) objectInputStream.readObject(); return obj; &#125; catch (Exception e) &#123; log.error("Java 反序列化失败，error:&#123;&#125;", e); &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; log.error("Java 反序列化关闭二进制输入流失败，error:&#123;&#125;", e); &#125; &#125; if (objectInputStream != null) &#123; try &#123; objectInputStream.close(); &#125; catch (IOException e) &#123; log.error("Java 反序列化关闭对象输入流失败，error:&#123;&#125;", e); &#125; &#125; &#125; return null; &#125;&#125; HessianSerialize123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.springboot.whb.study.rpc.rpc_v2.serialize;import com.alibaba.com.caucho.hessian.io.Hessian2Input;import com.alibaba.com.caucho.hessian.io.Hessian2Output;import lombok.extern.slf4j.Slf4j;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;/** * @author: whb * @description: Hessian二进制序列化 */@Slf4jpublic class HessianSerialize implements SerializeProtocol &#123; /** * 序列化 * * @param clazz * @param t * @param &lt;T&gt; * @return */ @Override public &lt;T&gt; byte[] serialize(Class&lt;T&gt; clazz, T t) &#123; ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); Hessian2Output hessian2Output = new Hessian2Output(outputStream); try &#123; //验证过，一定需要在flush之前关闭掉hessian2Output，否则获取的bytes字段信息为空 hessian2Output.writeObject(t); &#125; catch (IOException e) &#123; throw new RuntimeException(e.getMessage()); &#125; finally &#123; try &#123; hessian2Output.close(); &#125; catch (IOException e) &#123; log.error("Hessian 二进制序列化，关闭流失败，error:&#123;&#125;", e); &#125; &#125; try &#123; outputStream.flush(); byte[] bytes = outputStream.toByteArray(); return bytes; &#125; catch (IOException e) &#123; throw new RuntimeException(e.getMessage()); &#125; finally &#123; try &#123; outputStream.close(); &#125; catch (IOException e) &#123; log.error("Hessian 二进制序列化，关闭输出流失败，error:&#123;&#125;", e); &#125; &#125; &#125; /** * 反序列化 * * @param clazz * @param bytes * @param &lt;T&gt; * @return */ @Override public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123; ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes); Hessian2Input hessian2Input = new Hessian2Input(inputStream); try &#123; T t = (T) hessian2Input.readObject(); return t; &#125; catch (IOException e) &#123; throw new RuntimeException(e.getMessage()); &#125; finally &#123; try &#123; hessian2Input.close(); &#125; catch (IOException e) &#123; log.error("Hessian 反序列化，流关闭失败，error:&#123;&#125;", e); &#125; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; log.error("Hessian 反序列化，输入流关闭失败，error:&#123;&#125;", e); &#125; &#125; &#125;&#125; 请求、响应对象RpcRequest1234567891011121314151617181920212223242526272829303132333435363738394041package com.springboot.whb.study.rpc.rpc_v2.core;import com.alibaba.fastjson.JSON;import lombok.Data;import java.io.Serializable;/** * @author: whb * @description: RPC请求对象 */@Datapublic class RpcRequest implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 类名 */ private String className; /** * 方法名 */ private String methodName; /** * 参数 */ private Object[] arguments; /** * 参数类型 */ private Class&lt;?&gt;[] parameterTypes; @Override public String toString() &#123; return JSON.toJSONString(this); &#125;&#125; RpcResponse123456789101112131415161718192021222324252627282930313233343536package com.springboot.whb.study.rpc.rpc_v2.core;import com.alibaba.fastjson.JSON;import lombok.Data;import java.io.Serializable;/** * @author: whb * @description: RPC响应对象 */@Datapublic class RpcResponse&lt;T&gt; implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 响应结果 */ private T result; /** * 是否出错 */ private Boolean isError; /** * 错误信息 */ private String errorMsg; @Override public String toString() &#123; return JSON.toJSONString(this); &#125;&#125; 服务端处理ServiceConnection123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.springboot.whb.study.rpc.rpc_v2.core;import lombok.Data;import lombok.extern.slf4j.Slf4j;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author: whb * @description: 服务连接 */@Slf4j@Datapublic class ServiceConnection implements Runnable &#123; /** * 端口号 */ private int port; /** * 服务关闭标记位 */ private volatile boolean flag = true; /** * 服务端套接字 */ private ServerSocket serverSocket; /** * 服务处理器 */ private ServiceHandler serviceHandler; /** * 初始化 * * @param port * @param serviceHandler */ public void init(int port, ServiceHandler serviceHandler) &#123; try &#123; this.port = port; this.serverSocket = new ServerSocket(this.port); &#125; catch (IOException e) &#123; throw new RuntimeException("启动失败：" + e.getMessage()); &#125; this.serviceHandler = serviceHandler; log.info("服务启动了..."); &#125; @Override public void run() &#123; while (flag) &#123; try &#123; Socket socket = serverSocket.accept(); serviceHandler.handler(socket); &#125; catch (IOException e) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e1) &#123; log.error("服务处理异常，error:&#123;&#125;", e); &#125; &#125; &#125; &#125; /** * 关闭连接 */ public void destory() &#123; log.info("服务端套接字关闭..."); this.flag = false; &#125;&#125; ServiceHandler123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package com.springboot.whb.study.rpc.rpc_v2.core;import com.google.common.util.concurrent.ThreadFactoryBuilder;import com.springboot.whb.study.rpc.rpc_v2.io.protocol.MessageProtocol;import lombok.Data;import lombok.extern.slf4j.Slf4j;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadFactory;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author: whb * @description: 服务端处理器 */@Slf4j@Datapublic class ServiceHandler &#123; /** * 线程池 */ private ThreadPoolExecutor executor = null; /** * 服务接口 */ private RpcService rpcService; /** * 消息协议 */ private MessageProtocol messageProtocol; public ServiceHandler(RpcService rpcService) &#123; this.rpcService = rpcService; //创建线程的线程工厂 ThreadFactory commonThreadName = new ThreadFactoryBuilder() .setNameFormat("Parse-Task-%d") .build(); //构造线程池 this.executor = new ThreadPoolExecutor( 10, 10, 2, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(200), commonThreadName, (Runnable r, ThreadPoolExecutor executor) -&gt; &#123; SocketTask socketTask = (SocketTask) r; Socket socket = socketTask.getSocket(); if (socket != null) &#123; try &#123; //无法及时处理和响应就快速拒绝掉 socket.close(); log.info("reject socket:" + socketTask + ", and closed."); &#125; catch (IOException e) &#123; log.error("socket关闭失败，error:&#123;&#125;", e); &#125; &#125; &#125; ); &#125; /** * 服务处理：接收到新的套接字，包装成为一个runnable提交给线程去执行 * * @param socket */ public void handler(Socket socket) &#123; this.executor.execute(new SocketTask(socket)); &#125; class SocketTask implements Runnable &#123; private Socket socket; public SocketTask(Socket socket) &#123; this.socket = socket; &#125; public Socket getSocket() &#123; return socket; &#125; @Override public void run() &#123; try &#123; InputStream inputStream = socket.getInputStream(); OutputStream outputStream = socket.getOutputStream(); // 获取客户端请求数据，统一包装成RpcRequest RpcRequest request = messageProtocol.serviceToRequest(inputStream); RpcResponse response = rpcService.invoke(request); log.info("request:[" + request + "],response:[" + response + "]"); // 反射调用，得到具体的返回值 messageProtocol.serviceGetResponse(response, outputStream); &#125; catch (Exception e) &#123; log.error("服务端处理出现异常，error:&#123;&#125;", e); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; log.error("socket关闭失败，error:&#123;&#125;", e); &#125; &#125; &#125; &#125; &#125;&#125; RpcService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158package com.springboot.whb.study.rpc.rpc_v2.core;import com.google.common.base.Joiner;import com.springboot.whb.study.rpc.rpc_v2.config.ServiceConfig;import com.springboot.whb.study.rpc.rpc_v2.io.protocol.DefaultMessageProtocol;import com.springboot.whb.study.rpc.rpc_v2.io.protocol.MessageProtocol;import com.springboot.whb.study.rpc.rpc_v2.register.ServiceRegister;import com.springboot.whb.study.rpc.rpc_v2.register.ZkServiceRegister;import lombok.Data;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.concurrent.BasicThreadFactory;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author: whb * @description: RPC服务 */@Slf4j@Datapublic class RpcService &#123; /** * k 是接口全名称 * v 是对应的对象包含的详细信息 */ private Map&lt;String, ServiceConfig&gt; serviceConfigMap = new HashMap&lt;&gt;(); /** * 端口号 */ private int port; /** * 服务注册 */ private ServiceRegister serviceRegister; /** * 连接器还未抽象处理，使用的还是BIO模型 */ private ServiceConnection serviceConnection; /** * 服务处理器 */ private ServiceHandler serviceHandler; /** * 线程池 */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 100, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(1000), new BasicThreadFactory.Builder().namingPattern(Joiner.on("-").join("service-thread-pool-", "%s")).build()); public RpcService(int port) &#123; this.port = port; this.serviceHandler = new ServiceHandler(this); this.serviceHandler.setMessageProtocol(new DefaultMessageProtocol()); this.serviceRegister = new ZkServiceRegister(); &#125; /** * 设置消息协议 * * @param messageProtocol */ public void setMessageProtocol(MessageProtocol messageProtocol) &#123; if (this.serviceHandler == null) &#123; throw new RuntimeException("套接字处理器无效"); &#125; this.serviceHandler.setMessageProtocol(messageProtocol); &#125; /** * 添加服务接口 * * @param interfaceClass * @param ref * @param &lt;T&gt; */ public &lt;T&gt; void addService(Class&lt;T&gt; interfaceClass, T ref) &#123; String interfaceName = interfaceClass.getName(); ServiceConfig&lt;T&gt; serviceConfig = ServiceConfig.convert(interfaceName, interfaceClass, ref, this); serviceConfigMap.put(interfaceName, serviceConfig); &#125; /** * 注册服务 */ private void register() &#123; //服务注册，在网络监听启动之前就需要完成 serviceConfigMap.values().forEach(serviceRegister::register); &#125; /** * 服务启动 */ public void start() &#123; this.register(); log.info("服务注册完成"); this.serviceConnection = new ServiceConnection(); this.serviceConnection.init(port, serviceHandler); threadPoolExecutor.execute(serviceConnection); //优雅关闭 Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123; RpcService.this.destroy(); &#125;)); &#125; /** * 通过反射执行，执行结果封装RpcResponse * * @param request * @param &lt;K&gt; * @param &lt;V&gt; * @return */ public &lt;K, V&gt; RpcResponse invoke(RpcRequest request) &#123; if (request == null) &#123; RpcResponse&lt;V&gt; response = new RpcResponse&lt;&gt;(); response.setResult(null); response.setIsError(true); response.setErrorMsg("未知异常"); return response; &#125; String className = request.getClassName(); //暂时不考虑没有对应的serviceConfig的情况 ServiceConfig&lt;K&gt; serviceConfig = serviceConfigMap.get(className); K ref = serviceConfig.getRef(); try &#123; Method method = ref.getClass().getMethod(request.getMethodName(), request.getParameterTypes()); V result = (V) method.invoke(ref, request.getArguments()); RpcResponse&lt;V&gt; response = new RpcResponse&lt;&gt;(); response.setResult(result); response.setIsError(false); response.setErrorMsg(""); return response; &#125; catch (Exception e) &#123; &#125; return null; &#125; /** * 关闭服务 */ public void destroy() &#123; this.serviceConnection.destory(); log.info("服务端关闭了"); &#125;&#125; 客户端处理代理对象ProxyInstance1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.springboot.whb.study.rpc.rpc_v2.core;import lombok.extern.slf4j.Slf4j;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.net.InetSocketAddress;/** * @author: whb * @description: 客户端代理对象 */@Slf4jpublic class ProxyInstance implements InvocationHandler &#123; /** * RPC调用方 */ private RpcClient rpcClient; private Class clazz; public ProxyInstance(RpcClient client, Class clazz) &#123; this.rpcClient = client; this.clazz = clazz; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; RpcRequest request = new RpcRequest(); request.setClassName(clazz.getName()); request.setMethodName(method.getName()); request.setArguments(args); request.setParameterTypes(method.getParameterTypes()); //获取服务提供方信息 InetSocketAddress address = rpcClient.discovery(request); log.info("[" + Thread.currentThread().getName() + "] discovery service: " + address); //发起网络请求，得到请求数据 RpcResponse response = rpcClient.invoke(request, address); return response.getResult(); &#125;&#125; ClientHandler1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.springboot.whb.study.rpc.rpc_v2.core;import com.springboot.whb.study.rpc.rpc_v2.io.protocol.MessageProtocol;import lombok.extern.slf4j.Slf4j;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.InetSocketAddress;import java.net.Socket;/** * @author: whb * @description: 客户端处理器 */@Slf4jpublic class ClientHandler &#123; private RpcClient rpcClient; private MessageProtocol messageProtocol; public ClientHandler(RpcClient rpcClient) &#123; this.rpcClient = rpcClient; &#125; public void setMessageProtocol(MessageProtocol messageProtocol) &#123; this.messageProtocol = messageProtocol; &#125; public &lt;T&gt; RpcResponse&lt;T&gt; invoke(RpcRequest request, InetSocketAddress address) &#123; RpcResponse&lt;T&gt; response = new RpcResponse&lt;&gt;(); Socket socket = getSocketInstance(address); if (socket == null) &#123; // 套接字链接失败 response.setIsError(true); response.setErrorMsg("套接字链接失败"); return response; &#125; try &#123; InputStream inputStream = socket.getInputStream(); OutputStream outputStream = socket.getOutputStream(); messageProtocol.clientToRequest(request, outputStream); response = messageProtocol.clientGetResponse(inputStream); &#125; catch (IOException e) &#123; log.error("客户端处理异常，error:&#123;&#125;", e); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; log.error("客户端关闭套接字失败，error:&#123;&#125;", e); &#125; &#125; &#125; return response; &#125; /** * 获取对象实例 * * @param address * @return */ private Socket getSocketInstance(InetSocketAddress address) &#123; try &#123; return new Socket(address.getHostString(), address.getPort()); &#125; catch (IOException e) &#123; log.error("客户端获取套接字失败，error:&#123;&#125;", e); &#125; return null; &#125;&#125; RpcClient123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.springboot.whb.study.rpc.rpc_v2.core;import com.springboot.whb.study.rpc.rpc_v2.config.ClientConfig;import com.springboot.whb.study.rpc.rpc_v2.domain.ServiceType;import com.springboot.whb.study.rpc.rpc_v2.io.protocol.DefaultMessageProtocol;import com.springboot.whb.study.rpc.rpc_v2.register.ServiceRegister;import com.springboot.whb.study.rpc.rpc_v2.register.ZkServiceRegister;import java.net.InetSocketAddress;import java.util.HashMap;import java.util.Map;/** * @author: whb * @description: RPC客户端 */public class RpcClient &#123; /** * k 是接口的全名称 * v 是对应的对象包含的详细信息 */ private Map&lt;String, ClientConfig&gt; clientConfigMap = new HashMap&lt;&gt;(); /** * 服务注册 */ private ServiceRegister serviceRegister; /** * 客户端处理器 */ private ClientHandler clientHandler; public RpcClient() &#123; this.serviceRegister = new ZkServiceRegister(); this.clientHandler = new ClientHandler(this); // 设置默认的消息处理协议 this.clientHandler.setMessageProtocol(new DefaultMessageProtocol()); &#125; /** * 订阅服务 * * @param clazz * @param &lt;T&gt; */ public &lt;T&gt; void subscribe(Class&lt;T&gt; clazz) &#123; String interfaceName = clazz.getName(); ProxyInstance invocationHandler = new ProxyInstance(this, clazz); ClientConfig&lt;T&gt; clientConfig = ClientConfig.convert(clazz, invocationHandler); clientConfigMap.put(interfaceName, clientConfig); &#125; /** * 服务注册 */ private void register() &#123; // 服务注册，在网络监听启动之前就需要完成 clientConfigMap.values().forEach(serviceRegister::register); &#125; /** * 服务启动 */ public void start() &#123; this.register(); &#125; /** * 服务发现 * * @param request * @return */ public InetSocketAddress discovery(RpcRequest request) &#123; return serviceRegister.discovery(request, ServiceType.PROVIDER); &#125; /** * 反射调用 * * @param request * @param address * @return */ public RpcResponse invoke(RpcRequest request, InetSocketAddress address) &#123; return this.clientHandler.invoke(request, address); &#125; /** * 获取对象实例 * * @param clazz * @param &lt;T&gt; * @return */ public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz) &#123; return (T) (clientConfigMap.get(clazz.getName()).getProxy()); &#125;&#125; 测试测试接口定义Calculate1234567891011121314151617181920212223242526package com.springboot.whb.study.rpc.rpc_v2.demo;/** * @author: whb * @description: 测试接口定义 */public interface Calculate&lt;T&gt; &#123; /** * 求和 * * @param a * @param b * @return */ T add(T a, T b); /** * 求差 * * @param a * @param b * @return */ T sub(T a, T b);&#125; 测试接口实现类SimpleCalculate12345678910111213141516171819202122232425262728package com.springboot.whb.study.rpc.rpc_v2.demo;import java.util.Random;/** * @author: whb * @description: 测试接口实现类 */public class SimpleCalculate implements Calculate&lt;Integer&gt; &#123; @Override public Integer add(Integer a, Integer b) &#123; long start = System.currentTimeMillis(); try &#123; Thread.sleep(new Random().nextInt(1000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int c = a + b; System.out.println(Thread.currentThread().getName() + " 耗时:" + (System.currentTimeMillis() - start)); return c; &#125; @Override public Integer sub(Integer a, Integer b) &#123; return a - b; &#125;&#125; 测试-服务端Service12345678910111213141516package com.springboot.whb.study.rpc.rpc_v2.demo;import com.springboot.whb.study.rpc.rpc_v2.core.RpcService;/** * @author: whb * @description: 测试服务端 */public class Service &#123; public static void main(String[] args) &#123; RpcService rpcService = new RpcService(10001); rpcService.addService(Calculate.class, new SimpleCalculate()); rpcService.start(); &#125;&#125; 测试-客户端Client1234567891011121314151617181920212223242526272829303132333435363738package com.springboot.whb.study.rpc.rpc_v2.demo;import com.google.common.base.Joiner;import com.springboot.whb.study.rpc.rpc_v2.core.RpcClient;import org.apache.commons.lang3.concurrent.BasicThreadFactory;import java.util.Random;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author: whb * @description: 测试客户端 */public class Client &#123; public static final ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 100, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(1000), new BasicThreadFactory.Builder().namingPattern(Joiner.on("-").join("client-thread-pool-", "%s")).build()); public static void main(String[] args) &#123; RpcClient rpcClient = new RpcClient(); rpcClient.subscribe(Calculate.class); rpcClient.start(); Calculate&lt;Integer&gt; calculateProxy = rpcClient.getInstance(Calculate.class); for (int i = 0; i &lt; 200; i++) &#123; threadPoolExecutor.execute(() -&gt; &#123; long start = System.currentTimeMillis(); int s1 = new Random().nextInt(100); int s2 = new Random().nextInt(100); int s3 = calculateProxy.add(s1, s2); System.out.println("[" + Thread.currentThread().getName() + "]a: " + s1 + ", b:" + s2 + ", c=" + s3 + ", 耗时:" + (System.currentTimeMillis() - start)); &#125;); &#125; &#125;&#125; 测试结果zookeeper 服务端 客户端 总结v2版本相比v1版本修改了整个代码结构，使得结构能够更加明确，引入zookeeper作为服务治理功能，大致介绍了zookeeper的特点以及功能，给服务注册、服务发现、序列化协议等均留下了口子，以便实现自定义的协议，v1的io模型是BIO，v2并没有变化，只是由单线程改造成多线程。 整体而言符合一个简单的rpc框架，依旧还是有很多点可以完善、优化的点，如： io模型还是没有替换，后面考虑直接整体接入netty； 不应该每次实时从zk获取节点信息，应该先设置一个本地缓存，再利用zookeeper的watcher功能，开启一个异步线程去监听更新本地缓存，降低和zk交互带来的性能损耗； 没有快速失败、重试的功能，客观情况下存在网络抖动的问题，重试就可以了。 整体的各种协议约定并没有明确规范，比较混乱。]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写RPC-NIO学习]]></title>
    <url>%2F%E6%89%8B%E5%86%99RPC-NIO%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[概述NIO是Java1.4推出的一种全新的IO模型，全称是java non-blocking IO，提供ByteBuffer等缓存的容器，达到非阻塞式的高伸缩性网络。 IO模型IO模型是机器进行IO具体操作方法的一种抽象，每种IO模型都有各自的优缺点，需要注意的是要完成各模型的实际开发需要操作系统的支持，在没有poll、epoll出来之前，java进行非阻塞式的读写操作很复杂，而当上述功能出现之后，java才在基于该功能上添加了nio模块，包名是java.nio，现在在类Linux是基于epoll实现的，类Unix（包含Mac）是基于kqueue 实现的。 Buffer是一种缓冲数据的容器，可以存储各种基本类型的数据。线程不安全，数据结构如下图所示：类似于一个数组，其中capacity为缓冲数组的长度，为固定的值；postion表示下一个需要操作的位置；limit为下一个不可操作的位置；各种数据的大小关系是0&lt;=position&lt;=limit&lt;=capacity put 写入数据，每次写入数据的地方都是postion，就会使得postion的值变大，当直到填充的数据长度超过了数组的长度，会抛出BufferOverflowException异常； get 读取数据 每次也会进行postion+1操作,这里需要注意到每次读取数据之前必须进行clear操作要不然会出现数据错误的问题，如下使用例子： 错误示例 正确示例 clear() 清空缓冲区的数据，实际上是假清除，只是将postion置位0，limit置位capacity；源码如下： 123456public final Buffer clear() &#123; position = 0; limit = capacity; mark = -1; return this;&#125; allocate(int n) 申请缓冲区，大小由参数决定; wrap(byte[] byets) 同样是申请缓冲区，传入的参数却是byte[],相当于设置的缓冲区大小是byte数组的长度，然后初始化设置了该缓冲容器的值; flip() 切换到读模式，修改limit为postion，position为0; hasRemaining() 查看是否还有数据可读 return position &lt; limit; 一般的使用套路都是: 12345678ByteBuffer byteBuffer = ByteBuffer.allocate(10);byteBuffer.clear(); // 清空byteBuffer.put("hello".getBytes()); // 写入数据byteBuffer.flip(); // 读数据之前的必备操作while (byteBuffer.hasRemaining())&#123; // 数据是否读取完毕 System.out.print(byteBuffer.get() + "\t" ); // 读取数据&#125;System.out.println(); ChannelChannel通道，和pipeline一个意思，类似于IO的Stream，只是stream是单向，要么是Input要么是Output，而Channel是双向的，也就意味着可以通过一个channel进行读写操作了。不过需要注意可以读写操作和能不能读写操作这是两回事。 Nio的channel具体实现主要为FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel四种，分别对应的是文件、UDP和TCP的客户端和服务端。重点介绍SocketChannle和ServerSocketChannel。 SocketChannelSocketchannel 是客户端，连接一个创建好的TCP网络套接字的通道，可有两种创建方式 新建一个socketchannel，并连接到服务器上; 123SocketChannel socketChannel = SocketChannel.open();// 连接到本地的8081端口的服务器上socketChannel.connect(new InetSocketAddress(8081)); 服务器接收到来自客户端的请求接收到的 12345// 服务端接收到客户端发送的信息，通过accpet即可获取对应的socketChannelSocketChannel socketChannel = serverSocketChannel.accept();// 关闭socketChannel，由于其会抛出异常，最好是放在finally里面，并且做好空判断以及异常捕获socketChannel.close(); 由上图所示，需要从channel读数据，以及向外发送数据都需要使用buffer作为缓冲容器 12345678910111213141516171819// 读数据ByteBuffer byteBuffer = ByteBuffer.allocate(1024);// read 方法会返回读取了多少数据到buffer中，返回-1表示数据以及读取完毕，可以关闭通道了int count = socketChannel.read(byteBuffer);// 写数据String message = "Hello World!";// 直接调用write方法写入相关的bytebuffer数组socketChannel.write(message.getBytes());// 写数据方法2String message = "Hello World!";ByteBuffer byteBuffer = ByteBuffer.allocate(1024);byteBuffer.clear();byetBuffer.put(message.getBytes());byetBuffer.flip();while(byteBuffer.hasRemaing())&#123; socketChannel.write(byetBuffer);&#125; 由于其为异步模式，在其调用connect()方法的时候是立即返回结果，连接成功返回true，连接不成功返回false，并继续进行连接（服务自主操作），存在还未建立连接就返回了，所以在使用服务端数据的时候再调用finishConnect()确保链接的建立: 12345678SocketChannel socketChannel = SocketChannel.open();socketChannel.configureBlocking (false); // 一定要设置该内容socketChannel.connect(new InetSocketAddress(8081)); while(!socketChannel.finishConnect())&#123; ..... // 日志打印等操作，直到连接成功&#125;// 这是阻塞模式的// 连接成功，可以进行读写操作了 可以通过方法isConnectionPending()的返回值确认是否处于连接中。 ServerSocketChannelServerSocketChannel 是应用在服务端的，和Socketchannel相对应，主要是用来监听新来的TCP请求的一个通道。绑定的本地端口，IP是本机IP。创建方式如下： 123456789101112131415161718192021222324252627282930313233343536373839404142ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.socket().bind(new InetSocketAddress(8081));// 通过对该channel持有的socket进行绑定端口操作// 之前很奇怪一个问题，这个直接调用socket().bind不会有空指针么？肯定不会有这个错误的// 在调用socket()，如果发现其内置的socket为null，就会生成一个socket的适配参数替换nullclass ServerSocketChannelImpl extends ServerSocketChannel implements SelChImpl &#123; private static NativeDispatcher nd; private final FileDescriptor fd; private int fdVal; private volatile long thread = 0L; private final Object lock = new Object(); private final Object stateLock = new Object(); private static final int ST_UNINITIALIZED = -1; private static final int ST_INUSE = 0; private static final int ST_KILLED = 1; private int state = -1; private InetSocketAddress localAddress; private boolean isReuseAddress; ServerSocket socket; // 这个就是调用socket取得的数据 public ServerSocket socket() &#123; Object var1 = this.stateLock; synchronized (this.stateLock) &#123; if (this.socket == null) &#123; this.socket = ServerSocketAdaptor.create(this); &#125; return this.socket; &#125; &#125;&#125;public class ServerSocketAdaptor extends ServerSocket &#123; private final ServerSocketChannelImpl ssc; private volatile int timeout = 0; public static ServerSocket create(ServerSocketChannelImpl var0) &#123; try &#123; return new ServerSocketAdaptor(var0); &#125; catch (IOException var2) &#123; throw new Error(var2); &#125; &#125;&#125; Selectorselector 是nio中能够管理多个channel通道并感知各个通道的读写状态的一个组件，可以使用单线程管理多个channel的从而同时处理多个网络请求。selector和channel是通过selectorkey绑定的 12345678// 创建一个selectorSelector selector = Selector.open();// 创建serversocketChannel并绑定端口ServerSocketChannel serverSocketChannel ..... // 设置为非阻塞模式ServerSocketChannel.configureBlocking(false); // register绑定selector和channel到一个对象SelectionKey中SelectionKey key = channel.register(selector,Selectionkey.OP_READ); 注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件： Selectionkey.Connect 可以连接 （客户端接收到可连接到请求）; Selectionkey.Accept 可以接受 （服务端接到客户端连接的请求）; Selectionkey.Read 可以读取数据; Selectionkey.Write 可以写入数据; SelectionKey绑定channel和selector的对象，还包含有read集合和interest集合(感兴趣，在register设置的值),还可以通过attachment()方法绑定一些其他数据。配套的还有判断其状态的方法 123456public class SelectionKeyImpl extends AbstractSelectionKey &#123; final SelChImpl channel; public final SelectorImpl selector; private int index; private volatile int interestOps; private int readyOps; 选择通道selector从已经注册好的channel中获取已经准备就绪的通道进行操作，以下三种是获取通道的方法: int select() // 阻塞模式，至少有一个准备就绪的通道才返回 int select(long timeout) // 加入超时设置 int selectNow() // 会立即返回，返回当前就绪的通道个数 selectedKeys()获取当前就绪的通道集合 close() 关闭当前的selector，使得绑定的key全部不可用，但是通道本身还是可以正常使用的 12345678910111213141516171819int count = selector.select();Iterator it = selector.selectedKeys().iterator();while (it.hasNext())&#123; SelectionKey selectionKey = (SelectionKey)it.next(); it.remove(); // 处理完成一个key就移除掉，无需再次处理 if(selectionKey.isAcceptable())&#123; ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel(); SocketChannel socketChannel = serverSocketChannel.accept(); socketChannel.configureBlocking(false); socketChannel.register(selector, SelectionKey.OP_READ); &#125; if(selectionKey.isReadable())&#123; SocketChannel socketChannel = (SocketChannel) selectionKey.channel(); createProcessor(socketChannel); socketChannel.register(selector, SelectionKey.OP_WRITE); selectionKey.cancel(); // 当前key取消掉了，但是通道依旧可用 &#125;&#125; ####### DatagramChannel 收发UTP包的通道，适用于UTP协议，发送和读取的是用户数据报 123456DatagramChannel channel = DatagramChannel.open();channel.socket().bind(new InetSocketAddress(10002));// 建立了一个本地10002端口的UTP服务端channel.connect(new InetSocketAddress(10002));// 连接一个IP默认为本机，端口为10002服务// 读写和传统的read、write类似]]></content>
      <categories>
        <category>RPC</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写RPC--简易版]]></title>
    <url>%2F%E6%89%8B%E5%86%99RPC-%E7%AE%80%E6%98%93%E7%89%88.html</url>
    <content type="text"><![CDATA[之前在网上看很多公司在面试的时候都会问到Dubbo等一些RPC框架，更有甚者直接要求面试者手写PRC，今天就来撩下RPC。 什么是RPCRPC（Remote Procedure Call），远程过程调用，意思是可以在一台机器上调用远程的服务。在非分布式环境下，我们的程序调用服务都是本地调用，但是随着分布式结构的普遍，越来越多的应用需要解耦，将不同的独立功能部署发布成不同的服务供客户端调用，RPC就是为了解决这个问题的。RPC是一种规范，和TCP、UDP都没有关系，RPC可以采用TCP协议完成数据传输，甚至可以使用HTTP应用协议。RPC是C端模式，包含了服务端（服务提供方）、客户端（服务使用方），采用特定的网络传输协议，把数据按照特定的协议包装后进行传输操作等操作。 RPC原理首先，我们心里带着这样的问题：要怎么样去调用远程的服务呢？ ①肯定要知道IP和端口吧（确定唯一一个进程）； ②肯定要知道调用什么服务吧（方法名和参数）； ③调用服务后可能需要结果吧。 这三点又怎么实现呢？RPC的设计由Client，Client stub，Network，Server stub，Server构成。其中Client就是用来调用服务的，Cient stub是用来把调用的方法和参数序列化的（因为要在网络中传输，必须要把对象转变成字节），网络用来传输这些信息到服务器存根，服务器存根用来把这些信息反序列化的，服务器就是服务的提供者，最终调用的就是服务器提供的方法。RPC的结构如下图： 图中1-10序号的含义如下： 客户端像调用本地服务似的调用远程服务; 客户端stub接收到调用后，将类名，方法名，参数列表序列化; 客户端通过插座将消息发送到服务端; Server stub收到消息后进行解码（将消息对象反序列化）; 服务器存根根据解码结果调用本地的服务; 本地服务执行（对于服务端来说是本地执行）并将结果返回给服务器存根; 服务器存根将返回结果打包成消息（将结果消息对象序列化）; 服务端通过插座将消息发送到客户端; 客户端stub接收到结果消息，并进行解码（将结果消息发序列化）; 客户端得到最终结果。 这就是一个完成PRC调用过程，对使用方而言就只暴露了本地代理对象，剩下的数据解析、运输等都被包装了，从服务提供方的角度看还有服务暴露，如下是Dubbo的架构图： 简易RPC实现项目目录 MethodParameter对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.springboot.whb.study.rpc.rpc_v1;import com.alibaba.fastjson.JSON;import lombok.Data;import java.io.InputStream;import java.io.ObjectInputStream;/** * @author: whb * @description: 请求对象 */@Datapublic class MethodParameter &#123; /** * 类名 */ private String className; /** * 方法名 */ private String methodName; /** * 参数 */ private Object[] arguments; /** * 参数类型 */ private Class&lt;?&gt;[] parameterTypes; @Override public String toString() &#123; return JSON.toJSONString(this); &#125; /** * 从输入流中读取出类名、方法名、参数等数据组装成一个MethodParameter * * @param inputStream * @return */ public static MethodParameter convert(InputStream inputStream) &#123; try &#123; ObjectInputStream input = new ObjectInputStream(inputStream); String className = input.readUTF(); String methodName = input.readUTF(); Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject(); Object[] arguments = (Object[]) input.readObject(); MethodParameter methodParameter = new MethodParameter(); methodParameter.setClassName(className); methodParameter.setMethodName(methodName); methodParameter.setArguments(arguments); methodParameter.setParameterTypes(parameterTypes); return methodParameter; &#125; catch (Exception e) &#123; throw new RuntimeException("解析请求错误：&#123;&#125;", e); &#125; &#125;&#125; 服务端-服务暴露1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.springboot.whb.study.rpc.rpc_v1;import com.springboot.whb.study.rpc.rpc_v1.MethodParameter;import java.lang.reflect.Method;import java.util.HashMap;import java.util.Map;/** * @author: whb * @description: 服务端暴露 * 服务暴露存储在objectMap对象中，所有可对提供的服务都必须添加到该容器中，以便于收到网络数据后能找到对应的服务，然后采用反射invoke调用，返回得到的结果。 */public class RpcExploreService &#123; private Map&lt;String, Object&gt; objectMap = new HashMap&lt;&gt;(); /** * 可对外提供的服务 * * @param className * @param object */ public void explore(String className, Object object) &#123; objectMap.put(className, object); &#125; /** * 采用反射进行调用 * * @param methodParameter * @return */ public Object invoke(MethodParameter methodParameter) &#123; Object object = objectMap.get(methodParameter.getClassName()); if (object == null) &#123; throw new RuntimeException("无对应的执行类：【" + methodParameter.getClassName() + "】"); &#125; Method method = null; try &#123; method = object.getClass().getMethod(methodParameter.getMethodName(), methodParameter.getParameterTypes()); &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException("执行类：【" + methodParameter.getClassName() + "】无对应的执行方法：【" + methodParameter.getMethodName() + "】"); &#125; try &#123; Object result = method.invoke(object, methodParameter.getArguments()); System.out.println(methodParameter); return result; &#125; catch (Exception e) &#123; throw new RuntimeException("invoke方法执行失败：" + e.getMessage()); &#125; &#125;&#125; 服务端-网络数据处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.springboot.whb.study.rpc.rpc_v1;import com.google.common.base.Joiner;import org.apache.commons.lang3.concurrent.BasicThreadFactory;import java.io.IOException;import java.io.InputStream;import java.io.ObjectOutputStream;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author: whb * @description: 服务端-网络数据处理 * 简单的BIO模型，开启了一个ServerSocket后，接收到数据后就将套接字丢给一个新的线程处理，ServerSocketRunnable接收一个socket之后， * 解析出MethodParameter请求对象，然后调用服务暴露的Invoke方法，再写回socket传输给客户端。 */public class IOService implements Runnable &#123; private int port; private ServerSocket serverSocket; private RpcExploreService rpcExploreService; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 100, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(1000), new BasicThreadFactory.Builder().namingPattern(Joiner.on("-").join("thread-pool-", "%s")).build()); private volatile boolean flag; public IOService(RpcExploreService rpcExploreService, int port) throws IOException &#123; this.rpcExploreService = rpcExploreService; this.port = port; this.serverSocket = new ServerSocket(port); this.flag = true; System.out.println("******服务端启动了********"); //优雅关闭 Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; &#123; flag = false; System.out.println("+++++服务端关闭了+++++"); &#125;)); &#125; @Override public void run() &#123; while (true) &#123; Socket socket = null; try &#123; socket = serverSocket.accept(); &#125; catch (IOException e) &#123; &#125; if (socket == null) &#123; continue; &#125; threadPoolExecutor.execute(new ServerSocketRunnable(socket)); &#125; &#125; class ServerSocketRunnable implements Runnable &#123; private Socket socket; public ServerSocketRunnable(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; InputStream inputStream = socket.getInputStream(); OutputStream outputStream = socket.getOutputStream(); MethodParameter methodParameter = MethodParameter.convert(inputStream); Object result = rpcExploreService.invoke(methodParameter); ObjectOutputStream output = new ObjectOutputStream(outputStream); output.writeObject(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 客户端-服务订阅12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.springboot.whb.study.rpc.rpc_v1;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;/** * @author: whb * @description: 客户端-服务订阅 * 服务使用方需要使用register进行服务的注册，会生成对应的本地代理对象，后续只需要通过本地代理对象。 */public class RpcUsedService &#123; private Map&lt;String, Object&gt; proxyObejctMap = new HashMap&lt;&gt;(); private Map&lt;String, Class&gt; classMap = new HashMap&lt;&gt;(); private IOClient ioClient; public void setIoClient(IOClient ioClient) &#123; this.ioClient = ioClient; &#125; /** * 服务注册 * * @param clazz */ public void register(Class clazz) &#123; String className = clazz.getName(); classMap.put(className, clazz); if (!clazz.isInterface()) &#123; throw new RuntimeException("暂时只支持接口类型的"); &#125; try &#123; RpcInvocationHandler handler = new RpcInvocationHandler(); handler.setClazz(clazz); Object proxyInstance = Proxy.newProxyInstance(clazz.getClassLoader(), new Class&lt;?&gt;[]&#123;clazz&#125;, handler); proxyObejctMap.put(className, proxyInstance); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public &lt;T&gt; T get(Class&lt;T&gt; clazz) &#123; String className = clazz.getName(); return (T) proxyObejctMap.get(className); &#125; class RpcInvocationHandler implements InvocationHandler &#123; private Class clazz; public void setClazz(Class clazz) &#123; this.clazz = clazz; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; MethodParameter methodParameter = new MethodParameter(); methodParameter.setClassName(clazz.getName()); methodParameter.setMethodName(method.getName()); methodParameter.setArguments(args); methodParameter.setParameterTypes(method.getParameterTypes()); return ioClient.invoke(methodParameter); &#125; &#125;&#125; 客户端-网络处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.springboot.whb.study.rpc.rpc_v1;import java.io.*;import java.net.Socket;/** * @author: whb * @description: 客户端-网络处理 * 代理对象被调用后生成一个MethodParameter对象，通过此IOClient把数据传输到服务端，并且返回对应的数据。 */public class IOClient &#123; private String ip; private int port; public IOClient(String ip, int port) &#123; this.ip = ip; this.port = port; &#125; public Object invoke(MethodParameter methodParameter) &#123; Socket socket = null; try &#123; socket = new Socket(ip, port); OutputStream outputStream = socket.getOutputStream(); ObjectOutputStream output = new ObjectOutputStream(outputStream); output.writeUTF(methodParameter.getClassName()); output.writeUTF(methodParameter.getMethodName()); output.writeObject(methodParameter.getParameterTypes()); output.writeObject(methodParameter.getArguments()); InputStream inputStream = socket.getInputStream(); ObjectInputStream input = new ObjectInputStream(inputStream); return input.readObject(); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; throw new RuntimeException("socket关闭失败"); &#125; &#125; &#125; return null; &#125;&#125; 实践-服务端1234567891011121314151617181920212223package com.springboot.whb.study.rpc.rpc_v1;import com.springboot.whb.study.rpc.rpc_v1.expore.HelloWorldImpl;/** * @author: whb * @description: 服务端 */public class Service &#123; public static void main(String[] args) &#123; RpcExploreService rpcExploreService = new RpcExploreService(); //传入的字符串是接口的全名称 rpcExploreService.explore("com.springboot.whb.study.rpc.rpc_v1.expore.HelloWorld", new HelloWorldImpl()); try &#123; //开启11111端口监听服务 Runnable ioService = new IOService(rpcExploreService, 11111); new Thread(ioService).start(); &#125; catch (Exception e) &#123; &#125; &#125;&#125; 实践-客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.springboot.whb.study.rpc.rpc_v1;import com.google.common.base.Joiner;import com.springboot.whb.study.rpc.rpc_v1.expore.HelloWorld;import org.apache.commons.lang3.concurrent.BasicThreadFactory;import java.util.Random;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author: whb * @description: 客户端 */public class Client &#123; public static final ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 100, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(1000), new BasicThreadFactory.Builder().namingPattern(Joiner.on("-").join("client-thread-pool-", "%s")).build()); public static void main(String[] args) &#123; RpcUsedService rpcUsedService = new RpcUsedService(); rpcUsedService.register(HelloWorld.class); try &#123; IOClient ioClient = new IOClient("127.0.0.1", 11111); //网络套接字连接 同上是10001端口 rpcUsedService.setIoClient(ioClient); HelloWorld helloWorld = rpcUsedService.get(HelloWorld.class); //生成的本地代理对象 proxy for (int i = 0; i &lt; 100; i++) &#123; threadPoolExecutor.execute(() -&gt; &#123; long start = System.currentTimeMillis(); int a = new Random().nextInt(100); int b = new Random().nextInt(100); int c = helloWorld.add(a, b); // .add 操作就是屏蔽了所有的细节，提供给客户端使用的方法 System.out.println("a: " + a + ", b:" + b + ", c=" + c + ", 耗时:" + (System.currentTimeMillis() - start)); &#125;); &#125; &#125; catch (Exception e) &#123; throw new RuntimeException("客户端执行出错:&#123;&#125;", e); &#125; finally &#123; threadPoolExecutor.shutdown(); &#125; &#125;&#125; 服务接口12345678910package com.springboot.whb.study.rpc.rpc_v1.expore;/** * @author: whb * @description: 接口定义 */public interface HelloWorld &#123; int add(int a, int b);&#125; 服务接口实现123456789101112131415161718192021222324package com.springboot.whb.study.rpc.rpc_v1.expore;import java.util.Random;/** * @author: whb * @description: 接口实现类 */public class HelloWorldImpl implements HelloWorld &#123; @Override public int add(int a, int b) &#123; long start = System.currentTimeMillis(); try &#123; Thread.sleep(new Random().nextInt(10000)); // 故意添加了耗时操作，以便于模拟真实的调用操作 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int c = a + b; System.out.println(Thread.currentThread().getName() + " 耗时:" + (System.currentTimeMillis() - start)); return c; &#125;&#125; 运行效果 总结这只是一个非常简单的RPC实践，包含了服务暴露、服务注册（Proxy生成）、BIO模型进行网络传输，java默认的序列化方法，对RPC有一个初步的认识和了解，知道RPC必须包含的模块。 不过还是有很多需要优化的点以改进： IO模型：使用的是BIO模型，可以改进换成NIO模型，引入netty; 池化：不要随意新建线程，所有的线程都应有线程池统一管理; 服务发现：本地模拟的小demo，并没有服务发现，可以采用zk管理; 序列化：java本身自带的序列化效率很低，可以换成Hessian（DUBBO默认采用其作为序列化工具）、Protobuf（Protobuf是由Google提出的一种支持多语言的跨平台的序列化框架）等; 还有例如服务统计、优雅下线、负载均衡等也都是一个成熟的RPC框架必须要考虑到的点。]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java String常见问题]]></title>
    <url>%2FJava-String%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[首先看一段代码块： 123456789public String gets1() &#123; return "" + System.currentTimeMillis();&#125;public String gets2() &#123; return String.valueOf(System.currentTimeMillis());&#125;public String gets3() &#123; return new String("") + System.currentTimeMillis();&#125; 这三个方法都是输出当前时间戳string类型的数据，但他们有什么不同呢？反编译看下三个方法的细节： 12345678910111213141516171819202122232425262728293031public java.lang.String gets1();Code: 0: new #2 // class java/lang/StringBuilder 3: dup 4: invokespecial #3 // Method java/lang/StringBuilder."&lt;init&gt;":()V 7: ldc #4 // String 9: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 12: invokestatic #6 // Method java/lang/System.currentTimeMillis:()J 15: invokevirtual #7 // Method java/lang/StringBuilder.append:(J)Ljava/lang/StringBuilder; 18: invokevirtual #8 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 21: areturn' public java.lang.String gets2();Code: 0: invokestatic #6 // Method java/lang/System.currentTimeMillis:()J 3: invokestatic #9 // Method java/lang/String.valueOf:(J)Ljava/lang/String; 6: areturnpublic java.lang.String gets3();Code: 0: new #2 // class java/lang/StringBuilder 3: dup 4: invokespecial #3 // Method java/lang/StringBuilder."&lt;init&gt;":()V 7: new #10 // class java/lang/String 10: dup 11: ldc #4 // String 13: invokespecial #11 // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V 16: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: invokestatic #6 // Method java/lang/System.currentTimeMillis:()J 22: invokevirtual #7 // Method java/lang/StringBuilder.append:(J)Ljava/lang/StringBuilder; 25: invokevirtual #8 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 28: areturn 方法1：””+System.currentTimeMillis()是通过StringBuilder的append方法添加了一个空字符串及当前时间戳，然后通过toString方法生成一个全新的String对象。 该方法中使用了一个StringBuilder和一个String对象。 方法2：String.valueOf(System.currentTimeMillis())直接获取当前时间戳，然后创建了一个String对象。 该方法中使用了一个String对象。 方法3：new String(“”) + System.currentTimeMillis()则最麻烦，先创建了StringBuilder对象，然后新建了一个空字符串的String对象，通过append方法添加进去，最后toString创建了一个新的String对象。 该方法中使用了一个StringBuilder对象和两个String对象。 从上面的分析中就可以看出，很明显方法2是最优的，为什么呢？在深入String之前，先了解下JVM的组成。 堆：JVM运行中申请的对象存放的位置。也就是所说的新生代+老年代。 虚拟机栈：每个方法在被调用执行时都会创建一个虚拟机栈，用于存储临时的遍历、方法等信息。调用相当于进栈，返回结果则相当于出栈，异常输出的栈信息就是从这里来的。 本地方法栈：也是方法调用，只是调用的方法是本地native方法。 方法区：存储的类的结构信息，静态变量等信息。也就是永生代，发生FULL GC的地方（Java8中以元空间代替了永生代这个概念）。 常量池：方法区的一部分，用来存放各种生成的字面量，例如定义的一个String类型的数据（Java7中把常量池移到了堆中） 0. String的特性 1、String类是final的，不可被继承。 2、String类是的本质是字符数组char[], 并且其值不可改变。 3、Java运行时会维护一个String Pool（String池），JavaDoc翻译很模糊“字符串缓冲区”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。而一般对象不存在这个缓冲池，并且创建的对象仅仅存在于方法的堆栈区。 1. 创建字符串创建字符串一般就两种方法： 123String s1="hello";String s2=new String("hello"); 第一种方法是在栈中创建一个String类型的引用s1，然后在常量池中寻找，如果常量池中存在hello的字符串数据，则直接把s1指向常量池中hello的地址；否则就会在常量池中创建hello这个字符串数据，然后把s1指向新创建的hello地址。 第二种方法是在栈中创建一个String类型的引用s2，然后在常量池中寻找，如果常量池中存在该数据，则在堆中复制拷贝该数据，然后把s2指向堆中新建的地址；否则会创建一个字符串存放在常量池中，然后进行拷贝一份到堆中，s2指向堆中的地址。 通过new创建的string一定会在堆中创建一份数据，同时常量池肯定有一个值的备份操作；而单独的字符串则是直接指向常量池，所以一般还是使用字符串更好些，具体可看如下的图解： 2. 字符串 + 操作 1234567891011String s1="helloworld";String s2="hello" + "world";String s3=new String("hello") + "world";System.out.println(s1 == s2); // trueSystem.out.println(s2 == s3); // falseSystem.out.println(s1 == s3); // false 代码中”hello” + “world”在编译期已经知道了数据情况（使用javac编译查看class文件会发现s1和s2是一致的），JVM会自动优化使得s1和s2是一样的，s3由于有new操作，所以需要StringBuilder的append完成，具体可看如下图解: 3. 字符串变量 + 操作 123456789String s1="hello";String s2="world";String s3="helloworld";String s4=s1 + s2;System.out.println(s3 == s4); // false 这里的样例和上一个样例存在一些差别，这里的s4是由s1 + s2获得的，在编译期无法感知到其实际值，在运行期时会利用StringBuilder的append剩下一个新的String对象，所以s3指向的是常量池，而s4指向的堆，两者自然是不一样的。 1s4 = new StringBuilder()).append(s1).append(s2).toString(); 5. 带final的字符串变量 + 操作 12345678910111213final String s1="hello";String s2="world";String s3="helloworld";String s4=s1 + "world";String s5=s1 + s2;System.out.println(s3 == s4); // trueSystem.out.println(s3 == s5); // false 使用javac反编译之后的class文件如下： 1234567891011String var1 = "world";String var2 = "helloworld";String var3 = "helloworld";String var4 = "hello" + var1;System.out.println(var2 == var3);System.out.println(var2 == var4); 添加了final关键字修饰的变量在编译期会被对应的字符串直接替换掉，相当于字符串数据，而包含了字符串变量的+操作则依旧是使用了StringBuilder。 5. intern()方法String.intern方法是一个native方法，获取的是当前字符串在常量池的数据，如果常量池存在该数据则直接返回，如果不存在则把该数据添加到常量池中后返回，所以有String s1 = “abc” 和 String s2 = s1.intern() 中的s1 == s2和String s1=”world” 和 String s2=new String(“world”) 中 s1.intern() == s2.intern()1 6. 总结 String 本身是final类型的类，在日常使用中需要频繁的做字符串合并操作时，尽可能的使用StringBuilder（如需要考虑线程安全则使用StringBuffer），降低无谓的字符串创建操作，在保证安全的情况下，提高效率！]]></content>
      <categories>
        <category>Java</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis异常There is no getter for property named 'XXX' in class]]></title>
    <url>%2FMybatis%E5%BC%82%E5%B8%B8There-is-no-getter-for-property-named-XXX-in-class.html</url>
    <content type="text"><![CDATA[在集成Mybatis的项目中定义接口并实现映射SQL时，遇到过一个很奇怪的问题，如下： 定义接口： 1UserCouponBo getUserCouponInfoById(Long userCouponId); 然后对应的sql的xml如下： 12345678&lt;select id="selectUserCouponInfoById" parameterType="java.lang.Long" resultMap="baseResultMap"&gt; select amount,receive_time from user_coupon &lt;where&gt; &lt;if test="userCouponId != null"&gt; id = #&#123;userCouponId,jdbcType=BIGINT&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 上面的接口就是通过id查询指定的优惠券信息，个人感觉该sql写的不够优雅。就是这个接口，报错：There is no gettery for property…!!!这是为什么呢？原因是在if里面用了Mybatis的内置对象，&lt;if test=&quot;id != null&quot;&gt;，Mybatis默认采用OGNL解析参数，所以会自动采用对象树的形式取long.xxx值，如果没在方法中定义，则会抛出异常。 解决方案一：把#{xxx}修改为#{_parameter}即可 12345678&lt;select id="selectUserCouponInfoById" parameterType="java.lang.Long" resultMap="baseResultMap"&gt; select amount,receive_time from user_coupon &lt;where&gt; &lt;if test="_parameter != null"&gt; id = #&#123;_parameter&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 解决解决方案二：在方法中提前定义。 1UserCouponBo getUserCouponInfoById(@Param("userCouponId") Long userCouponId); 给userCouponId加@Param注解，定义一下就可以了。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库常用架构方案]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%9E%B6%E6%9E%84%E6%96%B9%E6%A1%88.html</url>
    <content type="text"><![CDATA[数据库架构原则 高可用 高性能 一致性 扩展性 常见的架构方案主备架构该方案只有主库提供读写服务，备库冗余作故障转移。数据库链接字符串：jdbc:mysql://vip:3306/xxdb 高可用分析：高可用，主库挂了，keepalive（一种工具）会自动切换到备库。这个过程对业务层是透明的，无需修改代码或配置。 高性能分析：读写都操作主库，很容易产生瓶颈。大部分互联网应用读多写少，读会先成为瓶颈，进而影响写性能。另外，备库只是单纯的备份，资源利用率只有50%。 一致性分析：读写都操作主库，不存在数据一致性问题。 扩展性分析：无法通过加从库来扩展读性能，进而提高整体性能。 可落地分析：两点影响落地：第一，性能一般，这点可以通过建立高效的索引和引入缓存来增加读性能，进而提高性能。这也是通用的方案。第二，扩展性差，这点可以通过分库分表来扩展。 双主架构该方案，两个主库同时提供服务，负载均衡。数据库链接字符串：jdbc:mysql://vip:3306/xxdb 高可用分析：高可用，一个主库挂了，不影响另一台主库提供服务。这个过程对业务层是透明的，无需修改代码或配置。 高性能分析：读写性能相比于方案一都得到提升，提升一倍。 一致性分析：存在数据一致性问题。 扩展性分析：当然可以扩展成三主循环，但不建议（会多一层数据同步，这样同步的时间会更长）。如果非得在数据库架构层面扩展的话，扩展为方案四。 可落地分析：两点影响落地:第一，数据一致性问题，一致性解决方案可解决问题。第二，主键冲突问题，ID统一地由分布式ID生成服务来生成可解决问题。 一主多从该方案采用主从架构，一主多从，读写分离。数据库链接字符串： 12345jdbc:mysql://master-ip:3306/xxdb jdbc:mysql://slave1-ip:3306/xxdb jdbc:mysql://slave2-ip:3306/xxdb 高可用分析：主库单点，从库高可用。一旦主库挂了，写服务也就无法提供。 高性能分析：大部分互联网应用读多写少，读会先成为瓶颈，进而影响整体性能。读的性能提高了，整体性能也提高了。另外，主库可以不用索引，线上从库和线下从库也可以建立不同的索引（线上从库如果有多个还是要建立相同的索引，不然得不偿失；线下从库是平时开发人员排查线上问题时查的库，可以建更多的索引）。 一致性分析：存在数据一致性问题。 扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。（带来的问题是，从库越多需要从主库拉取binlog日志的端就越多，进而影响主库的性能，并且数据同步完成的时间也会更长） 可落地分析：两点影响落地:第一，数据一致性问题，一致性解决方案可解决问题。第二，主库单点问题，暂时没想到很好的解决方案。 双主+主从数据库链接字符串： 12345jdbc:mysql://vip:3306/xxdbjdbc:mysql://slave1-ip:3306/xxdbjdbc:mysql://slave2-ip:3306/xxdb 高可用分析：高可用。 高性能分析：高性能。 一致性分析：存在数据一致性问题。 扩展性分析：可以通过加从库来扩展读性能，进而提高整体性能。（带来的问题同方案二） 可落地分析：同方案二，但数据同步又多了一层，数据延迟更严重。 数据一致性解决方案主库和从库一致性解决方案 注：图中圈出的是数据同步的地方，数据同步（从库从主库拉取binlog日志，再执行一遍）是需要时间的，这个同步时间内主库和从库的数据会存在不一致的情况。如果同步过程中有读请求，那么读到的就是从库中的老数据。如下图。 既然知道了数据不一致性产生的原因，有下面几个解决方案供参考： 直接忽略，如果业务允许延时存在，那么就不去管它。 强制读主，采用主备架构方案，读写都走主库。用缓存来扩展数据库读性能 。如果缓存挂了，可能会产生雪崩现象，不过一般分布式缓存都是高可用的。 选择读主，写操作时根据库+表+业务特征生成一个key放到Cache里并设置超时时间（大于等于主从数据同步时间）。读请求时，同样的方式生成key先去查Cache，再判断是否命中。若命中，则读主库，否则读从库。代价是多了一次缓存读写，基本可以忽略。 半同步复制，等主从同步完成，写请求才返回。就是大家常说的“半同步复制”semi-sync。这可以利用数据库原生功能，实现比较简单。代价是写请求时延增长，吞吐量降低。 数据库中间件，引入开源（mycat等）或自研的数据库中间层。思路同选择读主。数据库中间件的成本比较高，并且还多引入了一层。 DB和缓存一致性解决方案 先来看一下常用的缓存使用方式： 第一步：淘汰缓存； 第二步：写入数据库； 第三步：读取缓存？返回：读取数据库； 第四步：读取数据库后写入缓存。 注：如果按照这种方式，图一，不会产生DB和缓存不一致问题；图二，会产生DB和缓存不一致问题，即r2.read先于w3.sync执行。如果不做处理，缓存里的数据可能一直是脏数据。解决方式如下： 注：设置缓存时，一定要加上失效时间，以防延时淘汰缓存失败的情况！ MySQL复制MySQL主从复制目的实现数据库读写分离，写操作访问主数据库，读操作访问从数据库，从而使数据库具有更强大的访问负载能力，支撑更多的用户访问。 原理当应用程序客户端发送一条更新命令到数据库的时候，数据库会把这条更新命令同步记录到Binlog中，然后由另外一个线程从Binlog中读取这条日志，然后通过远程通讯的方式将它复制到从服务器上面去，从服务器获得这条更新日志后，将其加入到自己的Relay log中，然后由另外一个SQL执行线程从Relay log中读取这条新的日志，并把它在本地的数据库中重新执行一遍。 这样当客户端应用程序执行一个update命令的时候，这个命令会在主数据库和从数据库上同步执行，从而实现了主数据库向从数据库的复制，让从数据库和主数据库保持一样的数据。 MySQL一主多从复制目的MySQL的主从复制是一种数据同步机制，除了可以将一个主数据库中的数据同步复制到一个从数据库上，还可以将一个主数据库上的数据同步复制到多个从数据库上，也就是所谓的MySQL的一主多从复制。 原理多个从数据库关联到主数据库后，将主数据库上的Binlog日志同步地复制到了多个从数据库上。通过执行日志，让每个从数据库的数据都和主数据库上的数据保持了一致。这里面的数据更新操作表示的是所有数据库的更新操作，除了不包括SELECT之类的查询读操作，其他的INSERT、DELETE、UPDATE这样的DML写操作，以及CREATE TABLE、DROPT ABLE、ALTER TABLE等DDL操作也都可以同步复制到从数据库上去。 优点一主多从复制有四大优点，分别是分摊负载、专机专用、便于冷备和高可用。 分摊负载：将只读操作分布在多个从数据库上，从而将负载分摊到多台服务器上。 专机专用：可以针对不同类型的查询，使用不同的从服务器。 便于冷备：即使数据库进行了一主多从的复制，在一些极端的情况下。也可能会导致整个数据中心的数据都丢失。所以通常需要对数据做冷备，但冷备有一个困难点在于，数据库如果正在进行写操作，冷备的数据就可能不完整，数据文件可能处于损坏状态。使用一主多从的复制就就可以实现零停机的备份。只需要关闭数据库的数据复制进程，文件就处于关闭状态了，然后进行数据文件拷贝，拷贝完成后再重新打开数据复制就可以了。 高可用：如果一台服务器宕机了，只要不发请求给这台服务器就不会出问题。当这台服务器恢复的时候，重新发请求到这台服务器。所以，在一主多从的情况下，某一台从服务器宕机不可用，对整个系统的影响是非常小的。 MySQL主主复制目的一主多从只能够实现从服务器上的这些优点，当主数据库宕机不可用的时候，数据依然是不能够写入的，因为数据不能够写入到从服务器上面去，从服务器是只读的。为了解决主服务器的可用性问题，采用MySQL的主主复制方案。 原理当客户端程序对主服务器A进行数据更新操作的时候，主服务器A会把更新操作写入到Binlog日志中。然后Binlog会将数据日志同步到主服务器B，写入到主服务器的Relay log中，然后执Relay log，获得Relay log中的更新日志，执行SQL操作写入到数据库服务器B的本地数据库中。B服务器上的更新也同样通过Binlog复制到了服务器A的Relay log中，然后通过Relay log将数据更新到服务器A中。 通过这种方式，服务器A或者B任何一台服务器收到了数据的写的操作都会同步更新到另一台服务器，实现了数据库主主复制。主主复制可以提高系统的写可用，实现写操作的高可用。 MySQL主主复制失效恢复正常情况下用户会写入到主服务器A中，然后数据从A复制到主服务器B上。当主服务器A失效的时候，写操作会被发送到主服务器B中去，数据从B服务器复制到A服务器。 主主失效维护过程：最开始的时候，所有的主服务器都可以正常使用，当主服务器A失效的时候，进入故障状态，应用程序检测到主服务器A失效，检测到这个失效可能需要几秒钟或者几分钟的时间，然后应用程序需要进行失效转移，将写操作发送到备份主服务器B上面去，将读操作发送到B服务器对应的从服务器上面去。 一段时间后故障结束，A服务器需要重建失效期间丢失的数据，也就是把自己当作从服务器从B服务器上面去同步数据。同步完成后系统才能恢复正常。这个时候B服务器是用户的主要访问服务器，A服务器当作备份服务器。 MySQL复制注意事项 不要对两个数据库同时进行数据写操作，因为这种情况会导致数据冲突。 复制只是增加了数据的读并发处理能力，并没有增加写并发的能力和系统存储能力。 更新数据表的结构会导致巨大的同步延迟。 需要更新表结构的操作，不要写入到到Binlog中，要关闭更新表结构的Binlog。如果要对表结构进行更新，应该由运维工程师DBA对所有主从数据库分别手工进行数据表结构的更新操作。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis为什么这么快]]></title>
    <url>%2FRedis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB.html</url>
    <content type="text"><![CDATA[前言Redis本质上是一个基于键值对(Key-Value)类型的内存数据库，Redis的Value可以由String，hash，list，set，zset，Bitmaps，HyperLogLog等多种数据结构和算法组成。整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。可用于缓存、事件发布或订阅、高速队列等场景。该数据库使用ANSI C语言编写，支持网络，提供字符串、哈希、列表、队列、集合结构直接存取，基于内存，可持久化。Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。官方给出的性能可以达到10W+qps，那么Redis到底快在哪呢？ 开发语言现在我们都用高级语言来编程，比如Java、python等。也许你会觉得C语言很古老，但是它真的很有用，毕竟unix系统就是用C实现的，所以C语言是非常贴近操作系统的语言。Redis就是用C语言开发的，所以执行会比较快。 纯内存访问Redis将所有数据放在内存中，非数据同步正常工作中，是不需要从磁盘读取数据的，0次IO。内存响应时间大约为100纳秒，这是Redis速度快的重要基础。 单线程第一，单线程简化算法的实现，并发的数据结构实现不但困难且测试也麻烦。第二，单线程避免了线程切换以及加锁释放锁带来的消耗，对于服务端开发来说，锁和线程切换通常是性能杀手。 当然了，单线程也会有它的缺点，也是Redis的噩梦：阻塞。如果执行一个命令过长，那么会造成其他命令的阻塞，对于Redis是十分致命的，所以Redis是面向快速执行场景的数据库。 除了Redis之外，Node.js也是单线程，Nginx也是单线程，但他们都是服务器高性能的典范。 非阻塞多路I/O复用机制先说一下传统的阻塞I/O是如何工作的：当使用read或者write对某一文件描述符（File Descriptor FD）进行读写的时候，如果数据没有收到，那么该线程会被挂起，直到收到数据。阻塞模型虽然易于理解，但是在需要处理多个客户端任务的时候，不会使用阻塞模型。 I/O多路复用实际上是指多个连接的管理可以在同一进程。多路是指网络连接，复用只是同一个线程。在网络服务中，I/O多路复用起的作用是一次性把多个连接的事件通知业务代码处理，处理的方式由业务代码来决定。在I/O多路复用模型中，最重要的函数调用就是I/O 多路复用函数，该方法能同时监控多个文件描述符（fd）的读写情况，当其中的某些fd可读/写时，该方法就会返回可读/写的fd个数。 Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll的read、write、close等都转换成事件，不在网络I/O上浪费过多的时间。实现对多个FD读写的监控，提高性能。 举个例子:比如一个tcp服务器处理20个客户端socket。A方案：顺序处理，如果第一个socket因为网卡读数据处理慢了，一阻塞，后面都玩蛋去。 B方案：每个socket请求都创建一个分身子进程来处理，不说每个进程消耗大量系统资源，光是进程切换就够操作系统累的了。 C方案（I/O复用模型，epoll）：将用户socket对应的fd注册进epoll（实际上服务器和操作系统之间传递的不是socket的fd而是fd_set的数据结构），然后epoll只告诉哪些需要读/写的socket，只需要处理那些活跃的、有变化的socket fd的就好了。这样，整个过程只在调用epoll的时候才会阻塞，收发客户消息是不会阻塞的。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Spring中的注解]]></title>
    <url>%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3.html</url>
    <content type="text"><![CDATA[概述Spring中的注解大概可以分为两类： Spring的bean容器相关的注解，或者说bean工厂相关的注解； Springmvc相关的注解。 Spring的bean容器相关的注解有：@Required,@Autowired,@PostConstruct,@PreDestory,还有Spring3.0开始支持的JSR-330标准javax.inject.*中的注解：@Inject,@Named,@Qualifer,@Provider,@Scope,@Singleton。 Springmvc相关的注解有：@Controller,@RequestMapping,@RequestParam,@ResponseBody等等。 要理解Spring中的注解，先要理解Java中的注解。 Java中的注解@OverrideJdk1.5开始引入注解，最熟悉常见的应该是@Override，它的定义如下： 12345678910111213141516171819/** * Indicates that a method declaration is intended to override a * method declaration in a supertype. If a method is annotated with * this annotation type compilers are required to generate an error * message unless at least one of the following conditions hold: * The method does override or implement a method declared in a * supertype. * The method has a signature that is override-equivalent to that of * any public method declared in Object. * * @author Peter von der Ah&amp;eacute; * @author Joshua Bloch * @jls 9.6.1.4 @Override * @since 1.5 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 从注释可以看出，@Override的作用是，提示编译器，使用了@Override注解的方法必须override父类或者java.lang.Object中的一个同名方法。我们看到@Override的定义中使用到了 @Target, @Retention，它们就是所谓的“元注解”——就是定义注解的注解，或者说注解注解的注解。 @Retention看下@Retention注解定义： 12345678910111213141516/** * Indicates how long annotations with the annotated type are to * be retained. If no Retention annotation is present on * an annotation type declaration, the retention policy defaults to * RetentionPolicy.CLASS. */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; /** * Returns the retention policy. * @return the retention policy */ RetentionPolicy value();&#125; @Retention用于提示注解被保留多长时间，有三种取值： 12345678910111213141516171819public enum RetentionPolicy &#123; /** * Annotations are to be discarded by the compiler. */ SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * @see java.lang.reflect.AnnotatedElement */ RUNTIME&#125; RetentionPolicy.SOURCE 保留在源码级别，被编译器抛弃(@Override就是此类)；RetentionPolicy.CLASS被编译器保留在编译后的类文件级别，但是被虚拟机丢弃；RetentionPolicy.RUNTIME保留至运行时，可以被反射读取。 @Target1234567891011121314151617181920212223package java.lang.annotation;/** * Indicates the contexts in which an annotation type is applicable. The * declaration contexts and type contexts in which an annotation type may be * applicable are specified in JLS 9.6.4.1, and denoted in source code by enum * constants of java.lang.annotation.ElementType * @since 1.5 * @jls 9.6.4.1 @Target * @jls 9.7.4 Where Annotations May Appear */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; /** * Returns an array of the kinds of elements an annotation type * can be applied to. * @return an array of the kinds of elements an annotation type * can be applied to */ ElementType[] value();&#125; @Target用于提示该注解使用的地方，取值有： 12345678910111213141516171819202122232425262728public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * @since 1.8 */ TYPE_USE&#125; 分别表示该注解可以被使用的地方： 1) 类,接口,注解,enum;2) 属性域；3）方法；4）参数；5）构造函数；6）局部变量；7）注解类型；8）包。 所以： 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 表示 @Override 只能使用在方法上，保留在源码级别，被编译器处理，然后抛弃掉。 @Documented12345678910111213/** * Indicates that annotations with a type are to be documented by javadoc * and similar tools by default. This type should be used to annotate the * declarations of types whose annotations affect the use of annotated * elements by their clients. If a type declaration is annotated with * Documented, its annotations become part of the public API * of the annotated elements. */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125; 表示注解是否能被 javadoc 处理并保留在文档中。 使用 元注解 来自定义注解 和 处理自定义注解有了元注解，就可以使用它来自定义我们需要的注解。结合自定义注解和AOP或者过滤器，十分强大。比如可以使用注解来实现权限的细粒度的控制——在类或者方法上使用权限注解，然后在AOP或者过滤器中进行拦截处理。下面是一个关于登录的权限的注解的实现： 12345678/** * 不需要登录注解 */@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface NoLogin &#123;&#125; 自定义了一个注解 @NoLogin, 可以被用于 方法 和 类 上，注解一直保留到运行期，可以被反射读取到。该注解的含义是：被 @NoLogin 注解的类或者方法，即使用户没有登录，也是可以访问的。下面就是对注解进行处理了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 检查登录拦截器 * 如不需要检查登录可在方法或者controller上加上@NoLogin */public class CheckLoginInterceptor implements HandlerInterceptor &#123; private static final Logger logger = Logger.getLogger(CheckLoginInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (!(handler instanceof HandlerMethod)) &#123; logger.warn("当前操作handler不为HandlerMethod=" + handler.getClass().getName() + ",req=" + request.getQueryString()); return true; &#125; HandlerMethod handlerMethod = (HandlerMethod) handler; String methodName = handlerMethod.getMethod().getName(); // 判断是否需要检查登录 NoLogin noLogin = handlerMethod.getMethod().getAnnotation(NoLogin.class); if (null != noLogin) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("当前操作methodName=" + methodName + "不需要检查登录情况"); &#125; return true; &#125; noLogin = handlerMethod.getMethod().getDeclaringClass().getAnnotation(NoLogin.class); if (null != noLogin) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("当前操作methodName=" + methodName + "不需要检查登录情况"); &#125; return true; &#125; if (null == request.getSession().getAttribute(CommonConstants.SESSION_KEY_USER)) &#123; logger.warn("当前操作" + methodName + "用户未登录,ip=" + request.getRemoteAddr()); response.getWriter().write(JsonConvertor.convertFailResult(ErrorCodeEnum.NOT_LOGIN).toString()); // 返回错误信息 return false; &#125; return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 上面我们定义了一个登录拦截器，首先使用反射来判断方法上是否被 @NoLogin 注解： NoLogin noLogin = handlerMethod.getMethod().getAnnotation(NoLogin.class);然后判断类是否被 @NoLogin注解： noLogin = handlerMethod.getMethod().getDeclaringClass().getAnnotation(NoLogin.class); 如果被注解了，就返回 true，如果没有被注解，就判断是否已经登录，没有登录则返回错误信息给前台和false.这是一个简单的使用 注解 和 过滤器 来进行权限处理的例子。扩展开来，那么我们就可以使用注解，来表示某方法或者类，只能被具有某种角色，或者具有某种权限的用户所访问，然后在过滤器中进行判断处理。 Spring的bean容器相关的注解 @Autowired 是我们使用得最多的注解，其实就是 autowire=byType 就是根据类型的自动注入依赖（基于注解的依赖注入），可以被使用在属性域，方法，构造函数上。 @Qualifier 就是 autowire=byName, @Autowired注解判断多个bean类型相同时，就需要使用 @Qualifier(&quot;xxBean&quot;) 来指定依赖的bean的id： 123456@Controller@RequestMapping("/user")public class HelloController &#123; @Autowired @Qualifier("userService") private UserService userService; @Resource 属于JSR-250标准，用于属性域和方法上。也是 byName 类型的依赖注入。使用方式：@Resource(name=&quot;xxBean&quot;). 不带参数的 @Resource 默认值类名首字母小写。 JSR-330标准javax.inject.*中的注解(@Inject, @Named, @Qualifier, @Provider, @Scope, @Singleton)。@Inject就相当于@Autowired, @Named 就相当于 @Qualifier, 另外 @Named 用在类上还有 @Component的功能。 @Component, @Controller, @Service, @Repository, 这几个注解不同于上面的注解，上面的注解都是将被依赖的bean注入进来，而这几个注解的作用都是生产bean, 这些注解都是注解在类上，将类注解成spring的bean工厂中一个一个的bean。@Controller, @Service, @Repository基本就是语义更加细化的@Component。 @PostConstruct 和 @PreDestroy 不是用于依赖注入，而是bean 的生命周期。类似于 init-method(InitializeingBean)和destory-method(DisposableBean)。 Spring中注解的处理spring中注解的处理基本都是通过实现接口 BeanPostProcessor 来进行的： 1234public interface BeanPostProcessor &#123; Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;&#125; 相关的处理类有：AutowiredAnnotationBeanPostProcessor，CommonAnnotationBeanPostProcessor，PersistenceAnnotationBeanPostProcessor，RequiredAnnotationBeanPostProcessor。 这些处理类，可以通过 &lt;context:annotation-config/&gt; 配置 隐式的配置进spring容器。这些都是依赖注入的处理，还有生产bean的注解(@Component， @Controller, @Service, @Repository)的处理： &lt;context:component-scan base-package=&quot;net.aazj.service,net.aazj.aop&quot; /&gt; 这些都是通过指定扫描的基包路径来进行的，将他们扫描进spring的bean容器。注意 &lt;context:component-scan/&gt; 也会默认将 AutowiredAnnotationBeanPostProcessor，CommonAnnotationBeanPostProcessor 配置进来。所以&lt;context:annotation-config/&gt;是可以省略的。另外&lt;context:component-scan/&gt;也可以扫描@Aspect风格的AOP注解，但是需要在配置文件中加入 &lt;aop:aspectj-autoproxy/&gt;进行配合。 Spring注解和JSR-330标准注解的区别]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL-索引结构]]></title>
    <url>%2FMySQL-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.html</url>
    <content type="text"><![CDATA[BTree索引BTree（多路搜索树，并不是二叉的）是一种常见的数据结构。 不适合： 单列索引的列不能包含null的记录，复合索引的各个列不能包含同时为null的记录，否则会全表扫描；索引失效很多时候是因为这列有null，空值不适合键值较少的列（重复数据较多的列）；假如你建立了，会发生什么情况呢？查询反而会变慢前导模糊查询不能利用索引(like ‘%XX’或者like ‘%XX%’)，该类sql语句导致索引失效 Hash散列索引Hash散列索引是根据HASH算法来构建的索引。 适合： 精确查找非常快（包括= &lt;&gt; 和in），其检索效率非常高，索引的检索可以一次定位，不像BTree 索引需要从根节点到枝节点，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 不适合： 不适合模糊查询和范围查询（包括like，&gt;，&lt;，between……and等），由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样；不适合排序，数据库无法利用索引的数据来提升排序性能，同样是因为Hash值的大小不确定；复合索引不能利用部分索引字段查询，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。同样不适合键值较少的列（重复值较多的列）； Bitmap位图索引就是用位图表示的索引，对列的每个键值建立一个位图。相对于BTree索引，占用的空间非常小，创建和使用非常快。位图索引由于只存储键值的起止Rowid和位图,占用的空间非常少。 适合 适合决策支持系统；当select count(XX) 时,可以直接访问索引中一个位图就快速得出统计数据；当根据键值做and，or或 in(x,y,..)查询时，直接用索引的位图进行或运算,快速得出结果行数据。 不适合 不适合键值较多的列（重复值较少的列）；不适合update、insert、delete频繁的列，代价很高。到底是什么代价呢？update,insert,delete的时候会锁住键值一样的行。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴连接池DruidDataSource的一个bug]]></title>
    <url>%2F%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E8%BF%9E%E6%8E%A5%E6%B1%A0DruidDataSource%E7%9A%84%E4%B8%80%E4%B8%AAbug.html</url>
    <content type="text"><![CDATA[问题使用阿里巴巴的数据库连接池Druid，当应用程序连接数据库，老是报错：caused by wait mills 5000,active 0,maxactive 20连接数据库超时，但是使用单独的jdbc连接却是可以连接的。 解决经过反复测试，发现问题所在，原来是连接池参数&lt;property name=&quot;validationQuery&quot; value=&quot;select 1&quot;&gt;配置错误。虽然是配置错误，但是连接池版本是1.0.10，太旧，导致没有把真正的报错提示出来ora-00923 未找到要求的关键字from，而是报这个错：caused by wait mills 5000,active 0,maxactive 20。也就是说，本来是因为配置错误导致的，但是因为阿里巴巴连接池DruidDataSource的bug，把这个错误隐藏起来了，一直没有把真正的错误报出来。 总结将Druid版本升级到最新的稳定版本，DruidDataSource配置成如下： 123456789&lt;property name="minIdle" value="1" /&gt;&lt;property name="validationQuery" value="SELECT 1 FROM DUAL" /&gt;&lt;property name="testOnBorrow" value="true" /&gt;&lt;property name="poolPreparedStatements" value="true" /&gt;&lt;property name="initialSize" value=1 /&gt; 参数说明 validationQuery SQL查询,用来验证从连接池取出的连接,在将连接返回给调用者之前.如果指定, 则查询必须是一个SQL SELECT并且必须返回至少一行记录。 testOnBorrow true–指明是否在从池中取出连接前进行检验,如果检验失败, 则从池中去除连接并尝试取出另一个。 注意: 设置为true后如果要生效,validationQuery参数必须设置为非空字符串 。 testOnReturn false–指明是否在归还到池中前进行检验。 注意: 设置为true后如果要生效,validationQuery参数必须设置为非空字符串 。 testWhileIdle false–指明连接是否被空闲连接回收器(如果有)进行检验.如果检测失败, 则连接将被从池中去除。 注意: 设置为true后如果要生效,validationQuery参数必须设置为非空字符串 timeBetweenEvictionRunsMillis -1–在空闲连接回收器线程运行期间休眠的时间值,以毫秒为单位. 如果设置为非正数,则不运行空闲连接回收器线程。 numTestsPerEvictionRun 3–在每次空闲连接回收器线程(如果有)运行时检查的连接数量 。 minEvictableIdleTimeMillis 1000 * 60 * 30–连接在池中保持空闲而不被空闲连接回收器线程(如果有)回收的最小时间值，单位毫秒。]]></content>
      <categories>
        <category>druid</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>druid</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库、缓存不一致问题]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[只要用缓存，就可能会涉及到缓存与数据库双存储双写，只要是双写，就一定会有数据一致性问题，如何保证缓存与数据库的双写一致性？ 读写串行化一般来说，如果允许缓存可以稍微跟数据库偶尔有不一致，也就是说系统不是严格要求缓存+数据库必须保持一致性的话，可以采用读写请求串行化：即读请求和写请求串到一个内存队列里去，从而达到防止并发请求导致数据错乱的问题。值得注意的是，串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低。 代码实现大致如下（网上找的）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 请求异步处理的service实现 * @author Administrator * */@Service("requestAsyncProcessService") public class RequestAsyncProcessServiceImpl implements RequestAsyncProcessService &#123; @Override public void process(Request request) &#123; try &#123; // 先做读请求的去重 RequestQueue requestQueue = RequestQueue.getInstance(); Map&lt;Integer, Boolean&gt; flagMap = requestQueue.getFlagMap(); if(request instanceof ProductInventoryDBUpdateRequest) &#123; // 如果是一个更新数据库的请求，那么就将那个productId对应的标识设置为true flagMap.put(request.getProductId(), true); &#125; else if(request instanceof ProductInventoryCacheRefreshRequest) &#123; Boolean flag = flagMap.get(request.getProductId()); // 如果flag是null if(flag == null) &#123; flagMap.put(request.getProductId(), false); &#125; // 如果是缓存刷新的请求，那么就判断，如果标识不为空，而且是true，就说明之前有一个这个商品的数据库更新请求 if(flag != null &amp;&amp; flag) &#123; flagMap.put(request.getProductId(), false); &#125; // 如果是缓存刷新的请求，而且发现标识不为空，但是标识是false // 说明前面已经有一个数据库更新请求+一个缓存刷新请求了，大家想一想 if(flag != null &amp;&amp; !flag) &#123; // 对于这种读请求，直接就过滤掉，不要放到后面的内存队列里面去了 return; &#125; &#125; // 做请求的路由，根据每个请求的商品id，路由到对应的内存队列中去 ArrayBlockingQueue&lt;Request&gt; queue = getRoutingQueue(request.getProductId()); // 将请求放入对应的队列中，完成路由操作 queue.put(request); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取路由到的内存队列 * @param productId 商品id * @return 内存队列 */ private ArrayBlockingQueue&lt;Request&gt; getRoutingQueue(Integer productId) &#123; RequestQueue requestQueue = RequestQueue.getInstance(); // 先获取productId的hash值 String key = String.valueOf(productId); int h; int hash = (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); // 对hash值取模，将hash值路由到指定的内存队列中，比如内存队列大小8 // 用内存队列的数量对hash值取模之后，结果一定是在0~7之间 // 所以任何一个商品id都会被固定路由到同样的一个内存队列中去的 int index = (requestQueue.queueSize() - 1) &amp; hash; System.out.println("===========日志===========: 路由内存队列，商品id=" + productId + ", 队列索引=" + index); return requestQueue.getQueue(index); &#125;&#125; Cache Aside PatternCache Aside Patten：经典的缓存+数据库读写模式。 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。更新的时候，先删除缓存，然后再更新数据库。 为什么是删除缓存，而不是更新缓存？ 之所以更新的时候只是删除缓存，因为对于一些复杂有逻辑的缓存数据，每次数据变更都更新一次缓存会造成额外的负担，只是删除缓存，让该数据下一次被使用的时候再去执行读的操作来重新缓存，这里采用的是懒加载的策略。举个例子，一个缓存涉及的表的字段，在1分钟内就修改了20次，或者是100次，那么缓存更新20次，100次;但是这个缓存在1分钟内就被读取了1次，因此每次更新缓存就会有大量的冷数据，对于缓存符合28黄金法则，20%的数据，占用了80%的访问量。 最初级的缓存不一致问题及解决方案问题：先修改数据库，再删除缓存。如果删除缓存失败了，那么导致数据库中是新数据，缓存中是旧数据，数据就会出现不一致性。 解决思路：先删除缓存，再修改数据库。如果数据库修改失败了，那么数据库中是旧数据，缓存中是空的，那么数据就不会不一致。因为读的时候缓存中没有，则读数据库中的旧数据，然后再更新到缓存中。 比较复杂的数据不一致问题问题：数据发生了变更，先删除了缓存，然后要去修改数据库，但是还没来得及修改，一个请求过来，去读缓存，发现缓存是空的，去查询数据库，查到了修改前的旧数据，放到了缓存中，随后数据变更的程序完成了数据库的修改，这样就会造成数据库和缓存中的数据不一致。 解决思路：更新数据的时候，根据数据的唯一标识，将操作路由到一个JVM的内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个JVM内部队列中。一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。这样，一个数据变更的操作，先删除缓存，再去更新数据库，但是还没完成更新，此时一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送的队列中，此时会在队列中积压，然后同步等待缓存更新完成。 这样有一个优点：一个队列中多个更新缓存的请求串在一起是没意义的，因此可以做过滤。如果发现队列中已经有一个更新缓存的请求，那么不再放更新缓存的请求操作进去，直接等待前面的更新操作完成即可。 待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。 如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。 高并发场景下，该方案要注意如下的问题： 读请求长时阻塞由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。 该方案最大的风险点在于，可能数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库。 所以务必通过一些模拟真实的测试，看看更新数据的频率是怎样的。 另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要部署多个服务，每个服务分摊一些数据的更新操作。 如果一个内存队列里积压 100 个商品的库存修改操作，每个库存修改操作要耗费 10ms 去完成。那么最后一个商品的读请求，可能等待 10*100=1000ms=1s 后，才能得到数据，这个时候就导致读请求的长时阻塞。 因此，一定要根据实际业务系统的运行情况，去进行一些压力测试和模拟线上环境，看高峰期，内存队列可能会积压多少更新操作，可能会导致最后一个更新操作对应的读请求，会 Hang 多少时间。 如果读请求在 200ms 返回，哪怕是最繁忙的时候，积压 10 个更新操作，最多等待 200ms，那还可以的。 如果一个内存队列中可能积压的更新操作特别多，那就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。 一般来说，数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。像这种针对读高并发、读缓存架构的项目，一般来说写请求是非常少的，每秒的 QPS 能到几百就不错了。 实际粗略测算一下，如果一秒有 500 的写操作，分成 5 个时间片，每 200ms 就 100 个写操作，放到 20 个内存队列中，每个内存队列，可能就积压 5 个写操作。 每个写操作性能测试后，一般是在 20ms 左右就完成，那么针对每个内存队列的数据的读请求，也就最多 Hang 一会儿，200ms 以内肯定能返回了。 经过简单的测算，单机支撑的写 QPS 在几百是没问题的，如果写 QPS 扩大了 10 倍，那么就扩容机器，扩容 10 倍的机器，每个机器 20 个队列。 读请求并发量过高这里还必须做好压力测试，确保恰巧碰上上述情况时，还有一个风险，就是突然间大量读请求会在几十毫秒的延时 Hang 在服务上，看服务能不能扛的住，需要多少机器才能扛住最大的极限情况的峰值。 但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。 多服务实例部署的请求路由可能这个服务部署了多个实例，那么必须保证执行数据更新操作，以及执行缓存更新操作的请求，都通过 Nginx 服务器路由到相同的服务实例上。 比如对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 Hash 路由，也可以用 Nginx 的 Hash 路由功能等等。]]></content>
      <categories>
        <category>缓存</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOM常见原因及解决]]></title>
    <url>%2FOOM%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3.html</url>
    <content type="text"><![CDATA[Java heap space 当堆内存（Heap Space）没有足够空间存放新创建的对象时，就会抛出 java.lang.OutOfMemoryError:Javaheap space 错误（根据实际生产经验，可以对程序日志中的 OutOfMemoryError 配置关键字告警，一经发现，立即处理）。 原因分析 Javaheap space 错误产生的常见原因可以分为以下几类： 1、请求创建一个超大对象，通常是一个大数组。 2、超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。 3、过度使用终结器（Finalizer），该对象没有立即被 GC。 4、内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收。 解决方案 针对大部分情况，通常只需要通过 -Xmx 参数调高 JVM 堆内存空间即可。如果仍然没有解决，可以参考以下情况做进一步处理： 1、如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制。 2、如果是业务峰值压力，可以考虑增加机器资源，或者做限流降级。 3、如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。 GC overhead limit exceeded 当 Java 进程花费 98% 以上的时间执行 GC，但只恢复了不到 2% 的内存，且该动作连续重复了 5 次，就会抛出 java.lang.OutOfMemoryError:GC overhead limit exceeded错误。简单地说，就是应用程序已经基本耗尽了所有可用内存， GC 也无法回收。 此类问题的原因与解决方案跟 Javaheap space 非常类似，可以参考。 Permgen space 该错误表示永久代（Permanent Generation）已用满，通常是因为加载的 class 数目太多或体积太大。 原因分析: 永久代存储对象主要包括以下几类： 1、加载/缓存到内存中的 class 定义，包括类的名称，字段，方法和字节码； 2、常量池； 3、对象数组/类型数组所关联的 class； 4、JIT 编译器优化后的 class 信息。 PermGen 的使用量与加载到内存的 class 的数量/大小正相关。 解决方案: 根据 Permgen space 报错的时机，可以采用不同的解决方案，如下： 1、程序启动报错，修改 -XX:MaxPermSize 启动参数，调大永久代空间。 2、应用重新部署时报错，很可能是没有应用没有重启，导致加载了多份 class 信息，只需重启 JVM 即可解决。 3、运行时报错，应用程序可能会动态创建大量 class，而这些 class 的生命周期很短暂，但是 JVM 默认不会卸载 class，可以设置 -XX:+CMSClassUnloadingEnabled 和 -XX:+UseConcMarkSweepGC这两个参数允许 JVM 卸载 class。 如果上述方法无法解决，可以通过 jmap 命令 dump 内存对象 jmap-dump:format=b,file=dump.hprof&lt;process-id&gt;，然后利用 Eclipse MAT https://www.eclipse.org/mat 功能逐一分析开销最大的 classloader 和重复 class。 Metaspace JDK 1.8 使用 Metaspace 替换了永久代（Permanent Generation），该错误表示 Metaspace 已被用满，通常是因为加载的 class 数目太多或体积太大。 此类问题的原因与解决方法跟 Permgenspace 非常类似，可以参考。需要特别注意的是调整 Metaspace 空间大小的启动参数为 -XX:MaxMetaspaceSize。 Unable to create new native thread 每个 Java 线程都需要占用一定的内存空间，当 JVM 向底层操作系统请求创建一个新的 native 线程时，如果没有足够的资源分配就会报此类错误。 原因分析: JVM 向 OS 请求创建 native 线程失败，就会抛出 Unableto create new native thread，常见的原因包括以下几类： 1、线程数超过操作系统最大线程数 ulimit 限制； 2、线程数超过 kernel.pid_max（只能重启）； 3、native 内存不足； 该问题发生的常见过程主要包括以下几步： 1、JVM 内部的应用程序请求创建一个新的 Java 线程； 2、JVM native 方法代理了该次请求，并向操作系统请求创建一个 native 线程； 3、操作系统尝试创建一个新的 native 线程，并为其分配内存； 4、如果操作系统的虚拟内存已耗尽，或是受到 32 位进程的地址空间限制，操作系统就会拒绝本次 native 内存分配； 5、JVM 将抛出 java.lang.OutOfMemoryError:Unable to create new native thread 错误。 解决方案: 1、升级配置，为机器提供更多的内存； 2、降低 Java Heap Space 大小； 3、修复应用程序的线程泄漏问题； 4、限制线程池大小； 5、使用 -Xss 参数减少线程栈的大小； 6、调高 OS 层面的线程最大数：执行 ulimia-a 查看最大线程数限制，使用 ulimit-u xxx 调整最大线程数限制。 ulimit -a …. 省略部分内容 ….. max user processes (-u) 16384 Out of swap space? 该错误表示所有可用的虚拟内存已被耗尽。虚拟内存（Virtual Memory）由物理内存（Physical Memory）和交换空间（Swap Space）两部分组成。当运行时程序请求的虚拟内存溢出时就会报 Outof swap space?错误。 原因分析: 该错误出现的常见原因包括以下几类： 1、地址空间不足； 2、物理内存已耗光； 3、应用程序的本地内存泄漏（native leak），例如不断申请本地内存，却不释放。 4、执行 jmap-histo:live&lt;pid&gt; 命令，强制执行 Full GC；如果几次执行后内存明显下降，则基本确认为 Direct ByteBuffer 问题。 解决方案: 1、升级地址空间为 64 bit； 2、使用 Arthas 检查是否为 Inflater/Deflater 解压缩问题，如果是，则显式调用 end 方法。 3、Direct ByteBuffer 问题可以通过启动参数 -XX:MaxDirectMemorySize 调低阈值。 4、升级服务器配置/隔离部署，避免争用。 Kill process or sacrifice child 有一种内核作业（Kernel Job）名为 Out of Memory Killer，它会在可用内存极低的情况下“杀死”（kill）某些进程。OOM Killer 会对所有进程进行打分，然后将评分较低的进程“杀死”，具体的评分规则可以参考 Surviving the Linux OOM Killer。 不同于其他的 OOM 错误， Killprocessorsacrifice child 错误不是由 JVM 层面触发的，而是由操作系统层面触发的。 原因分析: 默认情况下，Linux 内核允许进程申请的内存总量大于系统可用内存，通过这种“错峰复用”的方式可以更有效的利用系统资源。 然而，这种方式也会无可避免地带来一定的“超卖”风险。例如某些进程持续占用系统内存，然后导致其他进程没有可用内存。此时，系统将自动激活 OOM Killer，寻找评分低的进程，并将其“杀死”，释放内存资源。 解决方案: 1、升级服务器配置/隔离部署，避免争用。 2、OOM Killer 调优。 Requested array size exceeds VM limit JVM 限制了数组的最大长度，该错误表示程序请求创建的数组超过最大长度限制。 JVM 在为数组分配内存前，会检查要分配的数据结构在系统中是否可寻址，通常为 Integer.MAX_VALUE-2。 此类问题比较罕见，通常需要检查代码，确认业务是否需要创建如此大的数组，是否可以拆分为多个块，分批执行。 Direct buffer memory Java 允许应用程序通过 Direct ByteBuffer 直接访问堆外内存，许多高性能程序通过 Direct ByteBuffer 结合内存映射文件（Memory Mapped File）实现高速 IO。 原因分析: Direct ByteBuffer 的默认大小为 64 MB，一旦使用超出限制，就会抛出 Directbuffer memory 错误。 解决方案: 1、Java 只能通过 ByteBuffer.allocateDirect 方法使用 Direct ByteBuffer，因此，可以通过 Arthas 等在线诊断工具拦截该方法进行排查。 2、检查是否直接或间接使用了 NIO，如 netty，jetty 等。 3、通过启动参数 -XX:MaxDirectMemorySize 调整 Direct ByteBuffer 的上限值。 4、检查 JVM 参数是否有 -XX:+DisableExplicitGC 选项，如果有就去掉，因为该参数会使 System.gc() 失效。 5、检查堆外内存使用代码，确认是否存在内存泄漏；或者通过反射调用 sun.misc.Cleaner 的 clean() 方法来主动释放被 Direct ByteBuffer 持有的内存空间。 6、内存容量确实不足，升级配置。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 计数排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想：计数排序是一种非基于比较的排序算法，其空间复杂度和时间复杂度均为O(n+k)，其中k是整数的范围。基于比较的排序算法时间复杂度最小是O(nlogn)的。该算法于1954年由 Harold H. Seward 提出。 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 算法步骤： 花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max。 开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)。 数组 B 中 index 的元素记录的值是 A 中某元素出现的次数。 最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数。 算法演示： 算法演示说明： 首先，扫描一下整个序列。 获得最小值为 2 ，最大值为 7。 新建数组包含 2~7 的元素。 再次扫描序列，将序列的值放置在新建数组中。 扫描数字 5，数组中 index 为 3 的值为 5，次数为 1。 扫描数字 3，数组中 index 为 1 的值为 3，次数为 1。 扫描数字 4，数组中 index 为 2 的值为 4，次数为 1。 扫描数字 7，数组中 index 为 5 的值为 7，次数为 1。 扫描数字 2，数组中 index 为 0 的值为 2，次数为 1。 扫描数字 4，数组中 index 为 2 的值为 4，次数为 2。 扫描数字 3，数组中 index 为 1 的值为 3，次数为 2。 按照这种节奏，扫描结束后，新建数组中存放了整个序列以及每个数字出现的次数。 最后输出目标整数序列。 输出数字 2，同时数组中 index 为 0 的值为 2 的元素次数变为 0。 输出数字 3，同时数组中 index 为 1 的值为 3 的元素次数变为 1。 同样的操作，整个序列就完全输出了。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;import java.util.Arrays;/** * @author: whb * @description: 计数排序 */public class CountingSort &#123; public static int[] countingSort(int[] unsorted) &#123; //开始声明桶,找到数组的最小值和最大值 int minNum = unsorted[0]; int maxNum = unsorted[0]; for (int i = 0; i &lt; unsorted.length; i++) &#123; if (unsorted[i] &lt; minNum) &#123; minNum = unsorted[i]; &#125; if (unsorted[i] &gt; maxNum) &#123; maxNum = unsorted[i]; &#125; &#125; System.out.println("最小数字为:" + minNum); System.out.println("最大数字位:" + maxNum); //找到最大最小值的之后,就开始声明有序桶,桶的初始位代表的值为minNum最大值为maxNum //数组的长度为(maxNum-minNum+1) int[] bucket = new int[(maxNum - minNum + 1)]; //声明了有序桶之后,开始对数字进行放桶操作 for (int j = 0; j &lt; unsorted.length; j++) &#123; //因为是找到了待排序数组的最小值minNum,所以,与数组数组比较的值应为(j+minNum) //如果遍历的值大小与数组代表的数字大小相等,则放入 //j次循环得到的数字是tempArray[j],则存储到下标为tempArray[j]+minNum的桶中 bucket[unsorted[j] - minNum] = bucket[unsorted[j] - minNum] + 1; &#125; //将得到的桶排序结果进行输出,输出的是桶排序的数组的下标 //可以声明新数组对该序列进行存储 int[] sorted = new int[unsorted.length]; int count = 0; for (int k = 0; k &lt; bucket.length; k++) &#123; if (bucket[k] != 0) &#123; //桶里装的值可能不是1,所以,在不等于一的时候,对桶里面的数字进行遍历存储 if (bucket[k] != 1) &#123; for (int z = 0; z &lt; bucket[k]; z++) &#123; sorted[count] = k + minNum; count++; &#125; &#125; else &#123; sorted[count] = k + minNum; count++; &#125; &#125; &#125; return sorted; &#125; public static void main(String[] args) &#123; //产生随机待排序列 int[] unsorted = new int[(int) (Math.random() * 11) + 5]; for (int i = 0; i &lt; unsorted.length; i++) &#123; unsorted[i] = (int) (Math.random() * 100); &#125; System.out.println("**************计数排序******************"); System.out.println("排序前："); CommonUtils.display(unsorted); System.out.println("排序后："); int[] sorted = countingSort(unsorted); CommonUtils.display(sorted); &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 珠排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E7%8F%A0%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想： 将每个数用珠子表示，例如：数字5就是5个珠子。用珠子表示好每一个数后，让所有的珠子自由下落。排序完成。 上图中的三个珠就表示数字3,两个珠表示数字2,这个OK了继续,这里的3和2都叫bead。 上图(a)中有两个数字,4和3,分别串在四条线上,于是数字4的最后一个珠子下落,因为它下边是空的,自由下落后变成上图(b) 上图(c)中随机给了四个数字,分别是3,2,4,2,这些珠子自由下落,就变成了(d)中,落完就有序了,2,2,3,4 以上就是珠排序的精华。 上图中的n表示待排序数组的长度,有多少数字就有多少层,横向表示一层;m表示有多少个珠子,就是多少个1,这取决于最大数是几。 举个例子：比如待排数组[6 2 4 1 5 9]。 让珠子全部做自由落体运动 9没有什么好落的,它在最底层 5也没有什么好落的,全部有支撑点 1同样不需要滑落 4除了第一个珠子不动外,其它三颗全部下落,落到1的位置变成下边这样 过程的细节不画了,原则就是你下边有支点,你就不用再滑落了,最后变成下边这样,排序完毕。 从上到下顺序输出即可得到结果:[ 1 2 4 5 6 9]。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @description: 珠排序:将每个数用珠子表示，例如：数字5就是5个珠子。用珠子表示好每一个数后，让所有的珠子自由下落。排序完成。 */public class BeadSort &#123; /** * 珠排序 * * @param unsorted 待排序列 * @return */ public static int[] beadSort(int[] unsorted) &#123; //待排序列中的最大值 int max = 0; //获取最大值 for (int i = 0; i &lt; unsorted.length; i++) &#123; if (unsorted[i] &gt; max) &#123; max = unsorted[i]; &#125; &#125; //每个数都用珠子表示，比如5就用5个珠子，所以用二维数组表示每个数 char[][] grid = new char[unsorted.length][max]; int[] levelCount = new int[max]; for (int i = 0; i &lt; max; i++) &#123; levelCount[i] = 0; for (int j = 0; j &lt; unsorted.length; j++) &#123; grid[j][i] = '_'; &#125; &#125; //删除珠子 for (int i = 0; i &lt; unsorted.length; i++) &#123; int num = unsorted[i]; for (int j = 0; num &gt; 0; j++) &#123; grid[levelCount[j]++][j] = '*'; num--; &#125; &#125; //数珠子，放到已排序列表 int[] sorted = new int[unsorted.length]; for (int i = 0; i &lt; unsorted.length; i++) &#123; int putt = 0; for (int j = 0; j &lt; max &amp;&amp; grid[unsorted.length - 1 - i][j] == '*'; j++) &#123; putt++; &#125; sorted[i] = putt; &#125; return sorted; &#125; public static void main(String[] args) &#123; //产生随机待排序列 int[] unsorted = new int[(int) (Math.random() * 11) + 5]; for (int i = 0; i &lt; unsorted.length; i++) &#123; unsorted[i] = (int) (Math.random() * 10); &#125; System.out.println("**************珠排序******************"); System.out.println("排序前："); CommonUtils.display(unsorted); System.out.println("排序后："); int[] sorted = beadSort(unsorted); CommonUtils.display(sorted); &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 耐心排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%80%90%E5%BF%83%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[耐心排序充分集合了桶排序和插入排序的优点，首先使用桶排序，排序之后每个桶中数据相对有序，这样再使用插入排序，简化了问题，速度变的更快。 建桶规则:如果没有桶,新建一个桶;如果不符合入桶规则那么新建一个桶。 入桶规则:只要比桶里最上边的数字小即可入桶,如果有多个桶可入,那么按照从左到右的顺序入桶即可。 举个例子：待排序数组[6 4 5 1 8 7 2 3] 第一步：因为此前还没有桶，则建立一个桶，我们命名为桶1,从上面取出第一个数字 6，然后将6放入到桶中。 第二步：我们使用第二个值4，然后遍历现有的桶，遍历的工程中先遇到桶1，我们发现桶1中最上面的元素是6,4比6大，则6下沉，有桶【4,6】。 第三步：我们使用第三个值5，然后遍历现有的桶，因为第一个桶第一个元素是4，比5小，所以重新开一个桶【5】，之后共有两个桶【4,5】【5】。 第四部：我们使用第四个值1，然后遍历现有的桶，因为第一个桶第一个元素是4，比1大，所以放到桶1【4,6】最前面，从而形成【1,4,6】【5】。 第五步：我们使用第五个元素，然后遍历现有的桶，第一个桶第一个元素是1，第二个桶第一个元素是5，都比8小，所以需要重新开一个桶【8】，此时共有桶【1,4,6】【5】【8】。 第六步：使用同样的方法，之后桶是【1,4,6】【5】【7，8】。 第七步：使用同样的方法，之后桶是【1,4,6】【2，5】【7，8】。 第八步：使用同样的方法，之后桶是【1,4,6】【2，5】【3，7，8】。 注意：遍历的数组，只跟各个桶的第一个元素做比较，这样保证各个桶元素有序。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;import java.util.ArrayList;import java.util.List;/** * @author: whb * @description: 耐心排序 */public class PatienceSort &#123; public static int[] patienceSort(int[] unsorted) &#123; List new_list = new ArrayList(); for (int i = 0; i &lt; unsorted.length; i++) &#123; List bucket_list = new ArrayList(); if (i == 0) &#123; bucket_list.add(unsorted[i]); new_list.add(bucket_list); &#125; else &#123; boolean is_ok = false; for (int j = 0; j &lt; new_list.size(); j++) &#123; if (unsorted[i] &lt; (int) ((List) new_list.get(j)).get(0)) &#123; ((List) new_list.get(j)).add(0, unsorted[i]); is_ok = true; break; &#125; &#125; if (!is_ok) &#123; bucket_list.add(unsorted[i]); new_list.add(bucket_list); &#125; &#125; &#125; //多维数组变成单维数组 int[] ok_list = new int[unsorted.length]; int q = 0; for (int m = 0; m &lt; new_list.size(); m++) &#123; for (int n = 0; n &lt; ((List) new_list.get(m)).size(); n++) &#123; ok_list[q] = (int) ((List) new_list.get(m)).get(n); q++; &#125; &#125; //插入循环 //将数组的长度赋给n是为了防止每次for循环中判断时都调用length方法影响性能 int n = ok_list.length; //用于中转数据 int tmp; int j; //排序的次数 for (int i = 1; i &lt; n; i++) &#123; tmp = ok_list[i]; //取i前面的所有跟i位置元素进行比较，先比较i-1和i，如果i-1大于i，则互换位置，i-1和i-2比较，以此类推 for (j = i - 1; j &gt;= 0 &amp;&amp; ok_list[j] &gt; tmp; j--) &#123; ok_list[j + 1] = ok_list[j]; &#125; ok_list[j + 1] = tmp; &#125; return ok_list; &#125; public static void main(String[] args) &#123; int[] unsorted = &#123;6, 4, 5, 1, 8, 7, 2, 3&#125;; System.out.println("**************耐心排序******************"); System.out.println("排序前："); CommonUtils.display(unsorted); System.out.println("排序后："); int[] sorted = patienceSort(unsorted); CommonUtils.display(sorted); &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 梳排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%A2%B3%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想： 梳排序和希尔排序很类似。希尔排序是在直接插入排序的基础上做的优化，而梳排序是在冒泡排序的基础上做的优化。也是像希尔排序一样，将待排序序列通过增量分为若干个子序列，然后对子序列进行一趟冒泡排序，一步步减小增量，直至增量为1。所以梳排序的最后一次排序是冒泡排序。梳排序增量是根据递减率减小的，递减率的设定影响着梳排序的效率，原作者以随机数作实验，得到最有效递减率为1.3的。因为编程中乘法比除法快，所以会取递减率的倒数与间距相乘，即0.8。其实当间距为1的时候，梳排序就是冒泡排序，而间距大于1的时候，梳排序的就是尽量把小的数字往前移动并保证此次间隔内的组是有序的。 举个例子：假设待数组[10 4 3 9 6 5 2 1 7 8] 待排数组长度为10,而10÷1.3=8,则比较10和7,4和8,并做交换。 交换后的结果为： [7 4 3 9 6 5 2 1 10 8] 第二次循环,更新间距为8÷1.3=6,比较7和2,4和1,3和10,9和8,7和2，4和1,9和8需要交换。 交换后的结果为： [2 1 3 8 6 5 7 4 10 9] 第三次循环,更新距离为4,比较2和6,1和5,3和7,8和4,6和10,5和9,8和4需要交换。 [2 1 3 4 6 5 7 8 10 9] 第四次循环,更新距离为3,比较2和4,1和6,3和5,4和7,6和8,5和10,7和9，不需要交换。 第五次循环,更新距离为2,比较2和3,1和4,3和6,4和5,6和7,5和8,7和10,8和9，不需要交换。 第六次循环，更新距离为1，为冒泡排序。 [1 2 3 4 5 6 7 8 9 10] 交换后排序结束,顺序输出即可得到[1 2 3 4 5 6 7 8 9 10]。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @description: 梳排序 */public class CombSort &#123; /** * 梳排序 * * @param unsorted 待排序列 */ public static void combSort(int[] unsorted) &#123; int gap = unsorted.length; boolean swapped = true; while (gap &gt; 1 || swapped) &#123; if (gap &gt; 1) &#123; gap = (int) (gap / 1.3); &#125; int i = 0; swapped = false; while (i + gap &lt; unsorted.length) &#123; if (unsorted[i] &gt; unsorted[i + gap]) &#123; swap(unsorted, i, i + gap); swapped = true; &#125; i++; &#125; &#125; &#125; /** * 按从小到大的顺序交换数组 * * @param a 传入的数组 * @param b 传入的要交换的数b * @param c 传入的要交换的数c */ public static void swap(int[] a, int b, int c) &#123; if (b == c) &#123; return; &#125; int temp = a[b]; a[b] = a[c]; a[c] = temp; &#125; public static void main(String[] args) &#123; int[] unsorted = &#123;11, 95, 45, 15, 78, 84, 51, 24, 12&#125;; System.out.println("**************梳排序******************"); System.out.println("排序前："); CommonUtils.display(unsorted); System.out.println("排序后："); combSort(unsorted); CommonUtils.display(unsorted); &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 奇偶排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思路是奇数列排一趟序,偶数列排一趟序,再奇数排,再偶数排,直到全部有序。 举个例子：待排数组[6 2 4 1 5 9] 第一次比较奇数列,奇数列与它的邻居偶数列比较,如6和2比,4和1比,5和9比。 [6 2 4 1 5 9] 交换后变成 [2 6 1 4 5 9] 第二次比较偶数列,即6和1比,5和5比。 [2 6 1 4 5 9] 交换后变成 [2 1 6 4 5 9] 第三趟又是奇数列,选择的是2,6,5分别与它们的邻居列比较。 [2 1 6 4 5 9] 交换后 [1 2 4 6 5 9] 第四趟偶数列。 [1 2 4 6 5 9] 一次交换 [1 2 4 5 6 9] 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @description: 奇偶排序：基本思路是奇数列排一趟序,偶数列排一趟序,再奇数排,再偶数排,直到全部有序 */public class OddEventSort &#123; public static void oddEventSort(int[] unsorted) &#123; int temp; for (int i = unsorted.length - 1; i &gt; unsorted.length / 2 - 1; i--) &#123; //奇数排序 for (int j = 1; j &lt;= i; j += 2) &#123; if (j == unsorted.length - 1) &#123; break; &#125; if (unsorted[j] &gt; unsorted[j + 1]) &#123; temp = unsorted[j]; unsorted[j] = unsorted[j + 1]; unsorted[j + 1] = temp; &#125; &#125; //偶数排序 for (int j = 0; j &lt;= i; j += 2) &#123; if (j == unsorted.length - 1) &#123; break; &#125; if (unsorted[j] &gt; unsorted[j + 1]) &#123; temp = unsorted[j]; unsorted[j] = unsorted[j + 1]; unsorted[j + 1] = temp; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] unsorted = new int[]&#123;12, 33, 45, 33, 13, 55, 34, 7, 6&#125;; System.out.println("**************奇偶排序******************"); System.out.println("排序前："); CommonUtils.display(unsorted); System.out.println("排序后："); oddEventSort(unsorted); CommonUtils.display(unsorted); &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 地精排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9C%B0%E7%B2%BE%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[号称最简单的排序算法,只有一层循环,默认情况下前进冒泡,一旦遇到冒泡的情况发生就往回冒,直到把这个数字放好为止。 举个例子：待排数组[6 2 4 1 5 9]。 先设计一个标识i=0然后从头开始判断,什么时候(i &lt; 6)不成立,什么时候排序结束。 [6 2 4 1 5 9] [0 1 2 3 4 5] 下具体的排序过程如下： [ i = 0 ]时啥也不干,先让i自增1,达到值为1才开始真正的比较。 交换前[6 2 4 1 5 9][ i = 0] 交换后[6 2 4 1 5 9][ i = 1] [ i = 1 ]比较6和2,发生交换,只要发生交换i就减1。 交换前[6 2 4 1 5 9][ i = 1] 交换后[2 6 4 1 5 9][ i = 0] [ i = 0 ]又成0了,啥也不干,自增变成1再说。 交换前[2 6 4 1 5 9][ i = 0] 交换后[2 6 4 1 5 9][ i = 1] [ i = 1 ]再比较2和6,不交换,只要不交换就自增1。 交换前[2 6 4 1 5 9][ i = 1] 交换后[2 6 4 1 5 9][ i = 2] [ i = 2 ]比较6和4,发生交换,只要交换就减1。 交换前[2 6 4 1 5 9][ i = 2] 交换后[2 4 6 1 5 9][ i = 1] [ i = 1 ]比较2和4,不交换,只要不交换就自增1。 交换前[2 4 6 1 5 9][ i = 1] 交换后[2 4 6 1 5 9][ i = 2] [ i = 2 ]比较4和6,不交换,只要不交换就自增1。 交换前[2 4 6 1 5 9][ i = 2] 交换后[2 4 6 1 5 9][ i = 3] [ i = 3 ]比较6和1,交换,只要交换就减1。 交换前[2 4 6 1 5 9][ i = 3] 交换后[2 4 1 6 5 9][ i = 2] [ i = 2 ]比较4和1,交换,只要交换就减1。 交换前[2 4 1 6 5 9][ i = 2] 交换后[2 1 4 6 5 9][ i = 1] [ i = 1 ]比较2和1,交换,只要交换就减1。 交换前[2 1 4 6 5 9][ i = 1] 交换后[1 2 4 6 5 9][ i = 0] [ i = 0 ]时啥也不干,先让i自增1,达到值为1才开始真正的比较。 交换前[1 2 4 6 5 9][ i = 0] 交换后[1 2 4 6 5 9][ i = 1] [ i = 1]比较1和2,不交换,只要不交换就自增1。 [ i = 2]比较2和4,不交换,只要不交换就自增1。 [ i = 3]比较4和6,不交换,只要不交换就自增1。 [ i = 4]比较6和5,交换,只要交换就减1。 交换前[1 2 4 6 5 9][ i = 4] 交换后[1 2 4 5 6 9][ i = 3] [ i = 3]比较4和5,不交换,只要不交换就自增1。 [ i = 4]比较5和6,不交换,只要不交换就自增1。 [ i = 5]比较6和9,不交换,只要不交换就自增1。 [ i = 6]表达式(i &lt; n)不成立,排序结束。 顺序输出结果即可:[ 1 2 4 5 6 9]。 代码如下： 12345678910111213141516171819202122232425262728293031323334package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @description: 地精排序：号称最简单的排序算法,只有一层循环,默认情况下前进冒泡,一旦遇到冒泡的情况发生就往回冒,直到把这个数字放好为止。 */public class GnomeSort &#123; public static void gnomeSort(int[] unsorted) &#123; int i = 0; while (i &lt; unsorted.length) &#123; if (i == 0 || unsorted[i - 1] &lt;= unsorted[i]) &#123; i++; &#125; else &#123; int temp = unsorted[i]; unsorted[i] = unsorted[i - 1]; unsorted[i - 1] = temp; i--; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] unsorted = &#123;6, 2, 4, 1, 5, 9&#125;; System.out.println("**************地精排序******************"); System.out.println("排序前："); CommonUtils.display(unsorted); System.out.println("排序后："); gnomeSort(unsorted); CommonUtils.display(unsorted); &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 鸡尾酒排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[鸡尾酒排序基于冒泡排序,双向循环。 举个例子：给定待排数组[2 3 4 5 1] 第一趟过去时的每一步。 第一步迭代,2 &lt; 3不换 [2 3 4 5 1] 第二步迭代,3 &lt; 4不换 [2 3 4 5 1] 第三步迭代,4 &lt; 5不换 [2 3 4 5 1] 第四步迭代,5 &gt; 1交换 [2 3 4 1 5] 第一趟回来时的第一步,鸡尾酒一次到头后就回返回来,再到头后再过去,来回比,一个来回能排两个数字。 第五步迭代,1 &lt; 5不交换 [2 3 4 1 5] 第六步迭代,1 &lt; 4交换 [2 3 1 4 5] 第七步迭代,1 &lt; 3交换 [2 1 3 4 5] 第八步迭代,2 &gt; 1交换 [1 2 3 4 5] 排序完毕,顺序输出结果即可得[ 1 2 3 4 5]。 如何判断排序结束了? 假如一趟来回没有交换任何数字,则表示该数组已经有序了,可以设置了个变量表示有没有交换过。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @description: 鸡尾酒排序 基于冒泡排序,双向循环 */public class CocktailSort &#123; public static void cocktailSort(int[] unsorted) &#123; boolean swapped = false; do &#123; for (int i = 0; i &lt; unsorted.length - 1; i++) &#123; if (unsorted[i] &gt; unsorted[i + 1]) &#123; int temp = unsorted[i]; unsorted[i] = unsorted[i + 1]; unsorted[i + 1] = temp; swapped = true; &#125; &#125; swapped = false; for (int j = unsorted.length - 1; j &gt; 0; j--) &#123; if (unsorted[j] &lt; unsorted[j - 1]) &#123; int temp = unsorted[j]; unsorted[j] = unsorted[j - 1]; unsorted[j - 1] = temp; swapped = true; &#125; &#125; &#125; while (swapped); &#125; public static void main(String[] args) &#123; int[] unsorted = &#123;6, 2, 4, 1, 5, 9&#125;; System.out.println("**************鸡尾酒排序******************"); System.out.println("排序前："); CommonUtils.display(unsorted); System.out.println("排序后："); cocktailSort(unsorted); CommonUtils.display(unsorted); &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 鸽巢排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%B8%BD%E5%B7%A2%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[鸽巢排序是桶排序的一种，顾名思义，就是一排鸽巢，看里面有几个鸽巢，然后遍历这些鸽巢，打印出来就好，排序之前得先知道区间和最大值。 比如有数组a = [2,7,5,9,8,8]，我们需要对这个数组进行排序，这是一个最大值不超过10的数组，那么我们定区间为0-10，定义一个下标0-10这样一个11位数组b,初始化值为0。然后遍历已知数组a，通过a的一项一项的值和我们定义的数组b的下标进行对应。 遍历开始： 取a[0]=2，然后操作b[2]=1 取a[1]=7，然后操作b[7]=1 取a[2]=5，然后操作b[5]=1 取a[3]=9，然后操作b[9]=1 取a[4]=8，然后操作b[8]=1 取a[5]=8，然后操作b[8]=2（注意了哦） 这样就对号入座了，之后遍历b，如果b中某个小标对应的值是多个，则遍历多次，把不是0的给打印出来，结果就是我们想要的了 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @description: 鸽巢排序 * 原理类似桶排序,同样需要一个很大的鸽巢[桶排序里管这个叫桶,名字无所谓] * 鸽巢其实就是数组,数组的索引位置就表示值,该索引位置的值表示出现次数,如果全部为1次或0次那就是桶排序 * 例如 * int[] pigeonHole = new int[100]; * pigeonHole[0]的值表示0的出现次数... * pigeonHole[1]的值表示1的出现次数... * pigeonHole[2]的值表示2的出现次数... */public class PigeonholeSort &#123; /** * 鸽巢排序 * * @param unsorted 待排序列 * @param maxNumber 最大数 * @return */ public static int[] pigeonholeSort(int[] unsorted, int maxNumber) &#123; int[] pogeonHole = new int[maxNumber + 1]; for (int item : unsorted) &#123; pogeonHole[item]++; &#125; return pogeonHole; &#125; public static void main(String[] args) &#123; int[] unsorted = &#123;99, 65, 24, 47, 47, 50, 99, 88, 66, 33, 66, 67, 31, 18, 24&#125;; System.out.println("**************鸽巢排序******************"); System.out.println("排序前："); CommonUtils.display(unsorted); int[] sorted = pigeonholeSort(unsorted, 99); System.out.println("排序后："); for (int i = 0; i &lt; sorted.length; i++) &#123; for (int j = 0; j &lt; sorted[i]; j++) &#123; System.out.print(i + " "); &#125; &#125; &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 基数排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基数排序过程无须比较关键字，而是通过“分配”和“收集”过程来实现排序。它们的时间复杂度可达到线性阶：O(n)。 实例:扑克牌中52张牌，可按花色和面值分成两个字段，其大小关系为： 花色： 梅花&lt; 方块&lt; 红心&lt; 黑心 面值： 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A若对扑克牌按花色、面值进行升序排序，得到如下序列： 即两张牌，若花色不同，不论面值怎样，花色低的那张牌小于花色高的，只有在同花色情况下，大小关系才由面值的大小确定。这就是多关键码排序。为得到排序结果，我们讨论两种排序方法。方法1：先对花色排序，将其分为4 个组，即梅花组、方块组、红心组、黑心组。再对每个组分别按面值进行排序，最后，将4 个组连接起来即可。方法2：先按13 个面值给出13 个编号组(2 号，3 号，…，A 号)，将牌按面值依次放入对应的编号组，分成13 堆。再按花色给出4 个编号组(梅花、方块、红心、黑心)，将2号组中牌取出分别放入对应花色组，再将3 号组中牌取出分别放入对应花色组，……，这样，4 个花色组中均按面值有序，然后，将4 个花色组依次连接起来即可。设n 个元素的待排序列包含d 个关键码{k1，k2，…，kd}，则称序列对关键码{k1，k2，…，kd}有序是指：对于序列中任两个记录r[i]和rj都满足下列有序关系： 其中k1 称为最主位关键码，kd 称为最次位关键码。 两种多关键码排序方法：多关键码排序按照从最主位关键码到最次位关键码或从最次位到最主位关键码的顺序逐次排序，分两种方法： 最高位优先(Most Significant Digit first)法，简称MSD 法： 1）先按k1 排序分组，将序列分成若干子序列，同一组序列的记录中，关键码k1 相等。 2）再对各组按k2 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd 对各子组排序后。 3）再将各组连接起来，便得到一个有序序列。扑克牌按花色、面值排序中介绍的方法一即是MSD 法。 最低位优先(Least Significant Digit first)法，简称LSD 法： 1) 先从kd 开始排序，再对kd-1进行排序，依次重复，直到按k1排序分组分成最小的子序列后。 2) 最后将各个子序列连接起来，便可得到一个有序的序列, 扑克牌按花色、面值排序中介绍的方法二即是LSD 法。基于LSD方法的链式基数排序的基本思想 “多关键字排序”的思想实现“单关键字排序”。对数字型或字符型的单关键字，可以看作由多个数位或多个字符构成的多关键字，此时可以采用“分配-收集”的方法进行排序，这一过程称作基数排序法，其中每个数字或字符可能的取值个数称为基数。比如，扑克牌的花色基数为4，面值基数为13。在整理扑克牌时，既可以先按花色整理，也可以先按面值整理。按花色整理时，先按红、黑、方、花的顺序分成4摞（分配），再按此顺序再叠放在一起（收集），然后按面值的顺序分成13摞（分配），再按此顺序叠放在一起（收集），如此进行二次分配和收集即可将扑克牌排列有序。基数排序:是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @description: 基数排序：过程无须比较关键字，而是通过“分配”和“收集”过程来实现排序。 * 平均O(d(n+r)),最好O(d(n+r)),最坏O(d(n+r));空间复杂度O(n+r);稳定;较复杂 * d为位数,r为分配后链表的个数 */public class RadixSort &#123; /** * 基数排序 * * @param unsorted 待排数组 * @param max 最大几位数 */ public static void radixSort(int[] unsorted, int max) &#123; //count数组用来计数 int[] count = new int[unsorted.length]; //bucket用来当桶，放数据，取数据 int[] bucket = new int[unsorted.length]; //k表示第几位，1代表个位，2代表十位，3代表百位 for (int k = 1; k &lt;= max; k++) &#123; //把count置空，防止上次循环的数据影响 for (int i = 0; i &lt; unsorted.length; i++) &#123; count[i] = 0; &#125; //分别统计第k位是0,1,2,3,4,5,6,7,8,9的数量 //以下便称为桶 //即此循环用来统计每个桶中的数据的数量 for (int i = 0; i &lt; unsorted.length; i++) &#123; count[getFigure(unsorted[i], k)]++; &#125; //利用count[i]来确定放置数据的位置 for (int i = 1; i &lt; unsorted.length; i++) &#123; count[i] = count[i] + count[i - 1]; &#125; //执行完此循环之后的count[i]就是第i个桶右边界的位置 //利用循环把数据装入各个桶中，注意是从后往前装 for (int i = unsorted.length - 1; i &gt;= 0; i--) &#123; int j = getFigure(unsorted[i], k); bucket[count[j] - 1] = unsorted[i]; count[j]--; &#125; //将桶中的数据取出来，赋值给unsorted for (int i = 0, j = 0; i &lt; unsorted.length; i++, j++) &#123; unsorted[i] = bucket[j]; &#125; &#125; &#125; /** * 返回整型数num的第pos位是什么 * * @param num 整数num * @param pos pos=1表示个位，pos=2表示十位 * @return */ public static int getFigure(int num, int pos) &#123; int tmp = 1; for (int i = 0; i &lt; pos - 1; i++) &#123; tmp *= 10; &#125; return (num / tmp) % 10; &#125; /** * 二维数组的方式实现基数排序 * * @param unsorted 待排序列 * @param arr_x 最大数字不超过999999999...(array_x个9) * @param arr_y 最大位数 */ public static void radix_sort(int[] unsorted, int arr_x, int arr_y) &#123; for (int i = 0; i &lt; arr_x; i++) &#123; int[][] bucket = new int[arr_x][arr_y]; //分配 for (int item : unsorted) &#123; int temp = (item / (int) Math.pow(10, i)) % 10; for (int j = 0; j &lt; arr_y; j++) &#123; if (bucket[temp][j] == 0) &#123; bucket[temp][j] = item; break; &#125; &#125; &#125; //收集 for (int o = 0, x = 0; x &lt; arr_x; x++) &#123; for (int y = 0; y &lt; arr_y; y++) &#123; if (bucket[x][y] == 0) &#123; continue; &#125; unsorted[o++] = bucket[x][y]; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; //定义待排整型数组 int[] arr = &#123;21, 56, 88, 195, 354, 1, 35, 12, 6, 7&#125;; System.out.println("**************基数排序******************"); System.out.println("排序前："); CommonUtils.display(arr); //调用基数排序函数 radixSort(arr, 3); System.out.println("排序后："); //输出排序后的数组 CommonUtils.display(arr); System.out.println(" "); int[] unsorted = &#123;999999999, 65, 24, 47, 13, 50, 92, 88, 66, 33, 22445, 10001, 624159, 624158, 624155501&#125;; System.out.println("**************二维数组方式实现的基数排序******************"); System.out.println("排序前："); CommonUtils.display(unsorted); radix_sort(unsorted, 10, 100); System.out.println("排序后："); for (int tmp : unsorted) &#123; if (tmp &gt; 0) &#123; System.out.print(tmp + " "); &#125; &#125; &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哆啦A梦]]></title>
    <url>%2F%E5%93%86%E5%95%A6A%E6%A2%A6.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;title&gt;哆啦A梦&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; &#125; #doraemon &#123; background-color: #fff; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body onmousemove="zuobiao(event)"&gt;&lt;canvas id="doraemon" width="400" height="600"&gt;&lt;/canvas&gt;&lt;div id="put" style="width: 50px" height="20px"&gt;&lt;/div&gt;&lt;script&gt; window.onload = function () &#123; var cxt = document.getElementById('doraemon').getContext('2d'); /* 头部*/ cxt.beginPath();//起始路径 cxt.lineWidth = 1;//线宽度为1 cxt.strokeStyle = '#000';//笔触的颜色 cxt.arc(200, 175, 175, 0.7 * Math.PI, 0.3 * Math.PI);//绘制弧，中心点（200，175），半径175 cxt.fillStyle = '#0bb0da';//设置填充时的颜色 cxt.fill();//填充颜色 cxt.stroke();//绘制路径 /*脸部*/ cxt.beginPath(); cxt.fillStyle = '#fff'; cxt.moveTo(110, 110);//将路径移到点（110，110），不创建线条 cxt.quadraticCurveTo(-10, 200, 120, 315);//创建二次贝塞尔曲线,控制点(-10,200),结束点(120,315) cxt.lineTo(280, 315);//添加一个新点，然后在画布中创建从（110，110）到（280，315）的线条 cxt.quadraticCurveTo(410, 210, 290, 110); cxt.lineTo(110, 110); cxt.fill(); cxt.stroke(); /*眼睛*/ cxt.beginPath(); cxt.lineWidth = 1; cxt.fillStyle = '#fff'; cxt.moveTo(110, 110); cxt.bezierCurveTo(110, 25, 200, 25, 200, 100);//创建三次贝塞尔曲线,控制点1(110,25),控制点2(200,25),结束点(200,100)，也就是画左上半椭圆 cxt.bezierCurveTo(200, 175, 110, 175, 110, 100);//画左下半椭圆 cxt.moveTo(200, 100); cxt.bezierCurveTo(200, 25, 290, 25, 290, 100); cxt.bezierCurveTo(290, 175, 200, 175, 200, 100); cxt.fill(); cxt.stroke(); /*右眼球*/ cxt.beginPath(); cxt.fillStyle = '#000'; cxt.arc(230, 130, 12, 0, 2 * Math.PI); cxt.fill(); cxt.stroke(); /*左眼球*/ cxt.beginPath(); cxt.fillStyle = '#000'; cxt.arc(170, 130, 12, 0, 2 * Math.PI); cxt.fill(); cxt.stroke(); /* 鼻子*/ cxt.beginPath(); cxt.arc(200, 165, 25, 0, 2 * Math.PI); cxt.fillStyle = '#d05823'; cxt.fill(); cxt.stroke(); /*胡须*/ //左胡须 cxt.beginPath(); cxt.moveTo(80, 175); cxt.lineTo(150, 195); cxt.moveTo(80, 200); cxt.lineTo(150, 205); cxt.moveTo(80, 225); cxt.lineTo(150, 215); //中部胡须 cxt.moveTo(200, 195); cxt.lineTo(200, 290); //右胡须 cxt.moveTo(250, 195); cxt.lineTo(320, 175); cxt.moveTo(250, 205); cxt.lineTo(320, 200); cxt.moveTo(250, 215); cxt.lineTo(320, 225); cxt.stroke(); /*嘴*/ cxt.moveTo(80, 240); cxt.quadraticCurveTo(200, 350, 320, 240); cxt.stroke(); /*围巾*/ cxt.beginPath(); cxt.moveTo(96, 316); cxt.lineTo(305, 316); cxt.lineTo(320, 316); cxt.arcTo(330, 316, 330, 326, 10);//在画布上创建介于两个切线之间的弧，起点坐标为(330,316),终点坐标为(330,326),半径为10 cxt.lineTo(330, 336); cxt.arcTo(330, 346, 305, 346, 10); cxt.lineTo(81, 346); cxt.arcTo(71, 346, 71, 336, 10); cxt.lineTo(71, 326); cxt.arcTo(71, 316, 81, 316, 10); cxt.lineTo(96, 316); cxt.fillStyle = '#b13209'; cxt.fill(); cxt.stroke(); /*下半身*/ cxt.beginPath(); cxt.fillStyle = '#0bb0da'; cxt.moveTo(80, 346); //左衣服 cxt.lineTo(26, 406); cxt.lineTo(65, 440); cxt.lineTo(85, 418); cxt.lineTo(85, 528); cxt.lineTo(185, 528); //右衣服 cxt.lineTo(315, 528); cxt.lineTo(315, 418); cxt.lineTo(337, 440); cxt.lineTo(374, 406); cxt.lineTo(320, 346); cxt.fill(); cxt.stroke(); /*手*/ //左手 cxt.beginPath(); cxt.fillStyle = '#fff'; cxt.arc(37, 433, 30, 0, 2 * Math.PI); cxt.fill(); cxt.stroke(); //右手 cxt.beginPath(); cxt.fillStyle = '#fff'; cxt.arc(363, 433, 30, 0, 2 * Math.PI); cxt.fill(); cxt.stroke(); /*肚*/ cxt.beginPath(); cxt.fillStyle = '#fff'; cxt.arc(200, 400, 91, 1.8 * Math.PI, 1.2 * Math.PI); cxt.fill(); cxt.stroke(); //小口袋 cxt.beginPath(); cxt.fillStyle = '#fff'; cxt.moveTo(130, 394); cxt.lineTo(270, 394); cxt.moveTo(130, 394); cxt.bezierCurveTo(130, 490, 270, 490, 270, 394); cxt.fill(); cxt.stroke(); /*两只脚的空隙*/ cxt.beginPath(); cxt.fillStyle = '#fff'; cxt.arc(200, 529, 20,Math.PI, 0); cxt.fill(); cxt.stroke(); /*脚*/ //左脚 cxt.beginPath(); cxt.fillStyle='#fff'; cxt.moveTo(180,528); cxt.lineTo(72,528); cxt.bezierCurveTo(52,528,52,558,72,558); cxt.lineTo(180,558); cxt.moveTo(180,558); cxt.bezierCurveTo(200,558,200,528,180,528); cxt.fill(); cxt.stroke(); //右脚 cxt.beginPath(); cxt.fillStyle='#fff'; cxt.moveTo(220,528); cxt.lineTo(328,528); cxt.bezierCurveTo(348,528,348,558,328,558); cxt.lineTo(220,558); cxt.moveTo(220,558); cxt.bezierCurveTo(200,558,200,528,220,528); cxt.fill(); cxt.stroke(); &#125;; //显示坐标 function zuobiao(event) &#123; var x = event.clientX; var y = event.clientY; var out = document.getElementById("put"); out.innerHTML = "x:" + x + " y:" + y; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下：]]></content>
      <categories>
        <category>Html</category>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 桶排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想：是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。 例如要对大小为[1..1000]范围内的n个整数A[1..n]排序。首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储(10..20]的整数，……集合B[i]存储((i-1)10, i10]的整数，i = 1,2,..100。总共有100个桶。然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任何排序法都可以。最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这样就得到所有数字排好序的一个序列了。假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果对每个桶中的数字采用快速排序，那么整个算法的复杂度是O(n + m * n/m*log(n/m)) = O(n + nlogn - nlogm)从上式看出，当m接近n的时候，桶排序复杂度接近O(n)。 当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的 ，实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。 桶排序的缺点是：1）首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。2）其次待排序的元素都要在一定的范围内等等。桶式排序是一种分配排序。分配排序的特点是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。 例如待排数字[6 2 4 1 5 9] 准备10个空桶,最大数个空桶 [6 2 4 1 5 9] 待排数组 [0 0 0 0 0 0 0 0 0 0] 空桶 [0 1 2 3 4 5 6 7 8 9] 桶编号(实际不存在) 1,顺序从待排数组中取出数字,首先6被取出,然后把6入6号桶,这个过程类似这样:空桶[ 待排数组[ 0 ] ] = 待排数组[ 0 ] [6 2 4 1 5 9] 待排数组 [0 0 0 0 0 0 6 0 0 0] 空桶 [0 1 2 3 4 5 6 7 8 9] 桶编号(实际不存在) 2,顺序从待排数组中取出下一个数字,此时2被取出,将其放入2号桶,是几就放几号桶 [6 2 4 1 5 9] 待排数组 [0 0 2 0 0 0 6 0 0 0] 空桶 [0 1 2 3 4 5 6 7 8 9] 桶编号(实际不存在) 3,4,5,6省略,过程一样,全部入桶后变成下边这样 [6 2 4 1 5 9] 待排数组 [0 1 2 0 4 5 6 0 0 9] 空桶 [0 1 2 3 4 5 6 7 8 9] 桶编号(实际不存在) 0表示空桶,跳过,顺序取出即可:1 2 4 5 6 9 代码如下： 12345678910111213141516171819202122232425262728293031323334353637package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @description: 桶排序 */public class BucketSort &#123; /** * 是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。 * 桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。 * 但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。 */ public static int[] bucketSort(int[] unsorted, int maxNumber) &#123; int[] sorted = new int[maxNumber + 1]; for (int i = 0; i &lt; unsorted.length; i++) &#123; sorted[unsorted[i]] = unsorted[i]; &#125; return sorted; &#125; public static void main(String[] args) &#123; int[] unsorted = &#123;99, 65, 24, 47, 50, 88, 33, 66, 67, 31, 18&#125;; int[] sorted = bucketSort(unsorted, 99); System.out.println("**************桶排序******************"); System.out.println("排序前："); CommonUtils.display(unsorted); System.out.println("排序后："); for (int tmp : sorted) &#123; if (tmp &gt; 0) &#123; System.out.print(tmp + " "); &#125; &#125; &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 归并排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 算法步骤： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针到达序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 算法流程图： 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @description: 归并排序 */public class MergeSort &#123; /** * 归并排序（Merge Sort）与快速排序思想类似：将待排序数据分成两部分，继续将两个子部分进行递归的归并排序；然后将已经有序的两个子部分进行合并，最终完成排序。 * 其时间复杂度与快速排序均为O(nlogn)，但是归并排序除了递归调用间接使用了辅助空间栈，还需要额外的O(n)空间进行临时存储。从此角度归并排序略逊于快速排序，但是归并排序是一种稳定的排序算法，快速排序则不然。 * 所谓稳定排序，表示对于具有相同值的多个元素，其间的先后顺序保持不变。对于基本数据类型而言，一个排序算法是否稳定，影响很小，但是对于结构体数组，稳定排序就十分重要。例如对于student结构体按照关键字score进行非降序排序： */ public static void mergeSort(int[] numArr, int[] tempArr, int head, int rear) &#123; if (head &lt; rear) &#123; //取分割位置 int middle = (head + rear) / 2; //递归划分列表的左序列 mergeSort(numArr, tempArr, head, middle); //递归划分列表的右序列 mergeSort(numArr, tempArr, middle + 1, rear); //列表的合并 merge(numArr, tempArr, head, middle + 1, rear); &#125; &#125; /** * 合并操作(列表的两两合并) * * @param numArr * @param tempArr * @param head * @param middle * @param rear */ public static void merge(int[] numArr, int[] tempArr, int head, int middle, int rear) &#123; //左指针尾 int headEnd = middle - 1; //右指针头 int rearStart = middle; //临时表的下标 int tempIndex = head; //列表合并后的长度 int tempLength = rear - head + 1; //先循环两个区间段都没有结束的情况 while ((headEnd &gt;= head) &amp;&amp; (rearStart &lt;= rear)) &#123; //如果发现右序列大，则将此数放入临时列表 if (numArr[head] &lt; numArr[rearStart]) &#123; tempArr[tempIndex++] = numArr[head++]; &#125; else &#123; tempArr[tempIndex++] = numArr[rearStart++]; &#125; &#125; //判断左序列是否结束 while (head &lt;= headEnd) &#123; tempArr[tempIndex++] = numArr[head++]; &#125; //判断右序列是否结束 while (rearStart &lt;= rear) &#123; tempArr[tempIndex++] = numArr[rearStart++]; &#125; //交换数据 for (int i = 0; i &lt; tempLength; i++) &#123; numArr[rear] = tempArr[rear]; rear--; &#125; &#125; public static void main(String[] args) &#123; int[] numArr = &#123;27, 11, 13, 45, 34, 22, 19, 8, 3, 99, 74, 55, 88, 66&#125;; System.out.println("**************归并排序******************"); System.out.println("排序前："); CommonUtils.display(numArr); System.out.println("排序后："); mergeSort(numArr, new int[numArr.length], 0, numArr.length - 1); CommonUtils.display(numArr); &#125;&#125; CommonUtils工具类： 12345678910111213141516171819202122package main.java.com.study.utils;/** * @author: whb * @description: 工具类 */public class CommonUtils &#123; /** * 遍历打印 * * @param numArr */ public static void display(int[] numArr) &#123; if (numArr != null &amp;&amp; numArr.length &gt; 0) &#123; for (int num : numArr) &#123; System.out.print(num + " "); &#125; &#125; System.out.println(""); &#125;&#125; 测试结果如下:]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 希尔排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想： 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。希尔排序，也称递减增量排序算法，是插入排序的一种高速而稳定的改进版本。 操作方法： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 算法流程图: 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @description: 希尔排序 */public class ShellSort &#123; /** * 希尔排序（Shell’s Sort）又称“缩小增量排序”(Diminishing Increment Sort)，它也是一种属于插入排序类的方法，但在时间效率上比直接插入排序方法有较大的改进。 * 从对直接插入排序的分析可知，其算法时间复杂度为O(n2)，但是，若待排记录序列为“正序”时，其时间复杂度可提高至O(n)。 * 由此设想，若待排记录序列按关键字“基本有序”，直接插入排序的效率就可以大大提高。 * 从另一方面来看，由于直接插入排序算法简单，所以在n值很小时效率比较高。希尔排序正是从这两点分析出发对直接插入排序进行改进而得到的一种插入排序方法。 * &lt;p&gt; * 希尔排序的基本思想是：先将整个待排序列分割成若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。（这是《数据结构》这本书里的说法。） * &lt;p&gt; * 通俗点说就是：先取较大的步长对待排序列进行直接插入排序，每排一次就缩小一次步长，再进行插入排序，直到最后步长变为1。 */ public static void shellSort(int[] numArr) &#123; int length = numArr.length; //取增量 int gap = length / 2; while (gap &gt;= 1) &#123; //无序序列 for (int i = gap; i &lt; length; i++) &#123; int temp = numArr[i]; int j; //有序序列 for (j = i - gap; j &gt;= 0 &amp;&amp; numArr[j] &gt; temp; j = j - gap) &#123; numArr[j + gap] = numArr[j]; &#125; numArr[j + gap] = temp; &#125; //缩小增量 gap = gap / 2; &#125; &#125; public static void main(String[] args) &#123; int[] numArr = &#123;27, 11, 13, 45, 34, 22, 19, 8, 3, 99, 74, 55, 88, 66&#125;; System.out.println("**************希尔排序******************"); System.out.println("排序前："); CommonUtils.display(numArr); System.out.println("排序后："); shellSort(numArr); CommonUtils.display(numArr); &#125;&#125; CommonUtils工具类： 12345678910111213141516171819202122package main.java.com.study.utils;/** * @author: whb * @description: 工具类 */public class CommonUtils &#123; /** * 遍历打印 * * @param numArr */ public static void display(int[] numArr) &#123; if (numArr != null &amp;&amp; numArr.length &gt; 0) &#123; for (int num : numArr) &#123; System.out.print(num + " "); &#125; &#125; System.out.println(""); &#125;&#125; 测试结果如下:]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 快速排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想： 1）选择一个基准元素,通常选择第一个元素或者最后一个元素, 2）如果选择第一个元素作为基准元素，则先从右向左找比基准元素小的元素，再从左向右找比基准元素大的元素，交换这两个元素的位置。（如果选择最后一个元素做基准元素，则先从左向右找）直到找到同一位置，跟基准元素位置交换，第一趟排序就结束。 3）通过一趟排序将记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的元素值比基准值大。 4）此时基准元素在其排好序后的正确位置 5）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。 算法流程图： 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @description: 快速排序 */public class QuickSort &#123; /** * 快速排序的基本思想是，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 * &lt;p&gt; * 一趟快速排序（或一次划分）的过程如下：首先任意选取一个记录（通常可选第一个记录）作为枢轴（或支点）（pivot），然后按下列原则重新排列其余记录：将所有关键字比它小的记录都安置在它的位置之前，将所有关键字比它大的记录都安置在它的位置之后。 * &lt;p&gt; * 经过一趟快速排序之后，以该枢轴记录最后所落的位置i作分界线，将序列分割成两个子序列，之后再分别对分割所得的两个子序列进行快速排序。 * &lt;p&gt; * 可以看出这个算法可以递归实现，可以用一个函数来实现划分，并返回分界位置。然后不断地这么分下去直到排序完成，可以看出函数的输入参数需要提供序列的首尾位置。 */ public static void quickSort(int[] numArr, int left, int right) &#123; //不管使用哪种分割方式，都可以通过递归形式进行排序 // 需要注意的是这个if语句不能少，不然没法停止，会导致堆栈溢出的异常。 if (left &lt; right) &#123; //分割数组，找到分割点 int point = partitionTwo(numArr, left, right); //递归调用，对左子数组进行快速排序 quickSort(numArr, left, point - 1); //递归调用，对右子数组进行快速排序 quickSort(numArr, point + 1, right); &#125; &#125; /** * 划分实现1 （枢轴跳来跳去法） * 一趟快速排序的实现：设两个指针left和right，设枢轴记录的关键字为first，则首先从right所指位置起向前搜索找到第一个关键字小于first的记录和枢轴记录互相交换， * 然后从left所指位置起向后搜索，找到第一个关键字大于first的记录和枢轴记录互相交换，重复这两步直至left==right为止。 */ public static int partitionOne(int[] numArr, int left, int right) &#123; //用数组的第一个元素做基准元素 int first = numArr[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; numArr[right] &gt;= first) &#123; right--; &#125; //交换 swap(numArr, left, right); while (left &lt; right &amp;&amp; numArr[left] &lt;= first) &#123; left++; &#125; //交换 swap(numArr, left, right); &#125; //返回分割点所在的位置 return left; &#125; /** * 划分实现2 （枢轴一次到位法） * partitionOne实现可以看出，枢轴元素（即最开始选的“中间”元素（其实往往是拿第一个元素作为“中间”元素））需要不断地和其他元素交换位置，而每交换一次位置实际上需要三次赋值操作。 * &lt;p&gt; * 实际上，只有最后left=right的位置才是枢轴元素的最终位置，所以可以先将枢轴元素保存起来，排序过程中只作元素的单向移动，直至一趟排序结束后再将枢轴元素移至正确的位置上。 * * @return */ public static int partitionTwo(int[] numArr, int left, int right) &#123; int first = numArr[left]; int temp = numArr[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; numArr[right] &gt;= first) &#123; right--; &#125; numArr[left] = numArr[right]; while (left &lt; right &amp;&amp; numArr[left] &lt;= first) &#123; left++; &#125; numArr[right] = numArr[left]; &#125; numArr[left] = temp; return left; &#125; /** * 交换数组中两个位置的元素 */ public static void swap(int[] numArr, int left, int right) &#123; int temp = 0; if (numArr != null &amp;&amp; numArr.length &gt; 0) &#123; temp = numArr[left]; numArr[left] = numArr[right]; numArr[right] = temp; &#125; &#125; public static void main(String[] args) &#123; int[] numArr = &#123;27, 11, 13, 45, 34, 22, 19, 8, 3, 99, 74, 55, 88, 66&#125;; System.out.println("**************快速排序******************"); System.out.println("排序前："); CommonUtils.display(numArr); System.out.println("排序后："); quickSort(numArr, 0, numArr.length - 1); CommonUtils.display(numArr); &#125;&#125; CommonUtils工具类： 12345678910111213141516171819202122package main.java.com.study.utils;/** * @author: whb * @description: 工具类 */public class CommonUtils &#123; /** * 遍历打印 * * @param numArr */ public static void display(int[] numArr) &#123; if (numArr != null &amp;&amp; numArr.length &gt; 0) &#123; for (int num : numArr) &#123; System.out.print(num + " "); &#125; &#125; System.out.println(""); &#125;&#125; 测试结果如下:]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 堆排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[堆排序是一种树形选择排序，是对直接选择排序的有效改进。 基本思想：堆的定义如下：具有n个元素的序列（k1,k2,…,kn),当且仅当满足 时称之为堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最小项（小顶堆）。 若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。如：（a）大顶堆序列：（96, 83,27,38,11,09)（b）小顶堆序列：（12，36，24，85，47，30，53，91） 初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储顺序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。因此，实现堆排序需解决两个问题： 如何将n 个待排序的数建成堆； 输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。 首先讨论第二个问题：输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。 调整小顶堆的方法： 1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。 2）将根结点与左、右子树中较小元素的进行交换。 3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）. 4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）. 5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。称这个自根结点到叶子结点的调整过程为筛选。如图： 再讨论对n 个元素初始建堆的过程。建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。1）n 个结点的完全二叉树，则最后一个结点是第个结点的子树。2）筛选从第 个结点为根的子树开始，该子树成为堆。3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49） 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @description: 堆排序 */public class HeapSort &#123; /** * 堆排序的是集合了插入排序的单数组操作，又有归并排序的时间复杂度，完美的结合了2者的优点。 */ public static void heapSort(int[] numArr) &#123; //将无序堆构造成一个大根堆，大根堆有length/2个父节点 for (int i = numArr.length / 2 - 1; i &gt;= 0; i--) &#123; headAdjust(numArr, i, numArr.length); &#125; //逐步将每个最大值的根节点与末尾元素交换，并且再调整其为最大堆 for (int i = numArr.length - 1; i &gt; 0; i--) &#123; //将堆顶元素和当前未经排序的子序列的最后一个元素交换位置 swap(numArr, 0, i); headAdjust(numArr, 0, i); &#125; &#125; /** * 构造大根堆 */ public static void headAdjust(int[] numArr, int parent, int length) &#123; //保存当前父节点 int temp = numArr[parent]; //得到左孩子 int leftChild = 2 * parent + 1; while (leftChild &lt; length) &#123; //如果parent有左孩子，则要判断左孩子是否小于右孩子 if (leftChild + 1 &lt; length &amp;&amp; numArr[leftChild] &lt; numArr[leftChild + 1]) &#123; leftChild++; &#125; //如果父节点大于子节点，就不交换 if (temp &gt;= numArr[leftChild]) &#123; break; &#125; //将较大子节点的值赋给父节点 numArr[parent] = numArr[leftChild]; //然后将子节点作为父节点 parent = leftChild; //找到该父节点较小的左孩子 leftChild = 2 * parent + 1; &#125; //最后将temp的值赋给较大的子节点，以形成两值交换 numArr[parent] = temp; &#125; /** * 交换数组中两个位置的元素 */ public static void swap(int[] numArr, int top, int last) &#123; int temp = numArr[top]; numArr[top] = numArr[last]; numArr[last] = temp; &#125; public static void main(String[] args) &#123; int[] numArr = &#123;27, 11, 13, 45, 34, 22, 19, 8, 3, 99, 74, 55, 88, 66&#125;; System.out.println("**************堆排序******************"); System.out.println("排序前："); CommonUtils.display(numArr); System.out.println("排序后："); heapSort(numArr); CommonUtils.display(numArr); &#125;&#125; CommonUtils工具类： 12345678910111213141516171819202122package main.java.com.study.utils;/** * @author: whb * @description: 工具类 */public class CommonUtils &#123; /** * 遍历打印 * * @param numArr */ public static void display(int[] numArr) &#123; if (numArr != null &amp;&amp; numArr.length &gt; 0) &#123; for (int num : numArr) &#123; System.out.print(num + " "); &#125; &#125; System.out.println(""); &#125;&#125; 测试结果如下:]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 简单选择排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想：在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。 操作方法：第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；以此类推…..第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，直到整个序列按关键码有序。 算法流程图: 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @description: 选择排序 */public class SelectionSort &#123; /** * 选择排序：每一趟在剩余未排序的若干记录中选取关键字最小的（也可以是最大的）记录作为有序序列中下一个记录。 * 如第i趟选择排序就是在n-i+1个记录中选取关键字最小的记录作为有序序列中第i个记录。 * 这样，整个序列共需要n-1趟排序。 */ public static void selctionSort(int[] numArr) &#123; int length = numArr.length; //要遍历的次数（length-1） for (int i = 0; i &lt; length - 1; i++) &#123; //将当前下标定义为最小值下标 int min = i; //遍历min之后的数据 for (int j = i + 1; j &lt; length - 1; j++) &#123; //如果有小于当前最小值的元素，将它的下标赋值给min if (numArr[j] &lt; numArr[min]) &#123; min = j; &#125; &#125; //如果min不等于i，则说明找到了真正的最小值 if (min != i) &#123; swap(numArr, min, i); &#125; &#125; &#125; /** * 交换数组中两个元素的位置 * * @param numArr * @param min * @param i */ public static void swap(int[] numArr, int min, int i) &#123; int temp = numArr[min]; numArr[min] = numArr[i]; numArr[i] = temp; &#125; public static void main(String[] args) &#123; int[] numArr = &#123;27, 11, 13, 45, 34, 22, 19, 8, 3, 99, 74, 55, 88, 66&#125;; System.out.println("**************选择排序******************"); System.out.println("排序前："); CommonUtils.display(numArr); System.out.println("排序后："); selctionSort(numArr); CommonUtils.display(numArr); &#125;&#125; CommonUtils工具类： 12345678910111213141516171819202122package main.java.com.study.utils;/** * @author: whb * @description: 工具类 */public class CommonUtils &#123; /** * 遍历打印 * * @param numArr */ public static void display(int[] numArr) &#123; if (numArr != null &amp;&amp; numArr.length &gt; 0) &#123; for (int num : numArr) &#123; System.out.print(num + " "); &#125; &#125; System.out.println(""); &#125;&#125; 测试结果如下:]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 直接插入排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想: 将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。 操作方法： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 算法流程图: 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @description: 插入排序 */public class InsertSort &#123; /** * 直接插入排序是一种最简单的排序方法，它的基本操作是将一个记录插入到已排好的有序的表中，从而得到一个新的、记录数增1的有序表。 * &lt;p&gt; * 当前元素的前面元素均为有序，要插入时，从当前元素的左边开始往前找（从后往前找），比当前元素大的元素均往右移一个位置，最后把当前元素放在它应该呆的位置就行了。 * 移动、比较的次数可作为衡量时间复杂性的标准。 * &lt;p&gt; * 最优情况：如果原始的输入序列为正序： * &lt;p&gt; * 比较次数：n-1 * &lt;p&gt; * 移动次数：0 * &lt;p&gt; * 最差情况：如果原始的输入序列为逆序： * &lt;p&gt; * 比较次数：(n+2)(n-1)/2 * &lt;p&gt; * 移动次数：(n+4)(n-1)/2 * &lt;p&gt; * 所以直接插入排序的时间复杂度为O(n2)。 */ public static void insertSort(int[] numArr) &#123; int length = numArr.length; for (int i = 1; i &lt; length; i++) &#123; int temp = numArr[i]; int j; //遍历有序序列，如果有序序列中的元素比临时元素大，则将有序序列中比临时元素大的元素依次向后移动 for (j = i - 1; j &gt;= 0 &amp;&amp; numArr[j] &gt; temp; j--) &#123; numArr[j + 1] = numArr[j]; &#125; //将临时元素插入到腾出的位置 numArr[j + 1] = temp; &#125; &#125; public static void main(String[] args) &#123; int[] numArr = &#123;27, 11, 13, 45, 34, 22, 19, 8, 3, 99, 74, 55, 88, 66&#125;; System.out.println("**************直接插入排序******************"); System.out.println("排序前："); CommonUtils.display(numArr); System.out.println("排序后："); insertSort(numArr); CommonUtils.display(numArr); &#125;&#125;``` CommonUtils工具类：```Javapackage main.java.com.study.utils;/** * @author: whb * @description: 工具类 */public class CommonUtils &#123; /** * 遍历打印 * * @param numArr */ public static void display(int[] numArr) &#123; if (numArr != null &amp;&amp; numArr.length &gt; 0) &#123; for (int num : numArr) &#123; System.out.print(num + " "); &#125; &#125; System.out.println(""); &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 冒泡排序]]></title>
    <url>%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。 算法步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 算法流程图： 算法改进对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @description: 冒泡排序 */public class BubbleSort &#123; /** * 冒泡排序的过程很简单，就是不断比较相邻两个元素的大小关系，若逆序则交换，这样通过一轮比较，关子健最大的记录就沉底了。 * 一般地，第i趟冒泡排序从第一个元素起到第n-i+1个元素依次比较相邻两个记录的关键字，并在逆序时交换相邻记录，其结果就是这n-i+1个记录中关键字最大的记录被交换到n-i+1的位置上。 * 当然也可以反过来，从后往前进行，这样每经过一趟排序，就把未排序的序列中最小的元素放在它应当处于的位置上，然后下次比较就不再让前面的元素参与了。 * 整个排序过程需要进行k趟冒泡排序，其中k至少为1，至多为n-1次，如果一趟冒泡排序中没有出现交换元素的操作，则说明序列已经有序了，可以停止排序了。 * 时间复杂度：正序时O(n)， 逆序时O(n2)，平均时间复杂性O(n2)。使用temp 作为临时交换变量，空间复杂度为 O(1). * &lt;p&gt; * 一般情况下貌似效率不及直接插入排序（尽管它们的平均时间复杂度都是O(n2)）。 */ public static void bubbleSort(int[] numArr) &#123; int length = numArr.length; //最多length-1次排序 for (int i = 0; i &lt; length; i++) &#123; //每一轮多少元素参与排序 for (int j = 0; j &lt; length - 1 - i; j++) &#123; if (numArr[j] &gt; numArr[j + 1]) &#123; /** * 交换顺序，不使用临时变量，利用 * a = a + b; * b = a - b; * a = a - b; */ numArr[j] = numArr[j] + numArr[j + 1]; numArr[j + 1] = numArr[j] - numArr[j + 1]; numArr[j] = numArr[j] - numArr[j + 1]; &#125; &#125; &#125; &#125; /** * 改进版冒泡：当某趟排序没有元素交换的时候，证明整个序列有序，无需再循环比较 * * @param numArr */ public static void bubbleSortImprove(int[] numArr) &#123; int length = numArr.length; //设置标志变量，这样当序列有序时及时退出循环，避免冗余处理。 boolean sorted = false; //最多length-1次排序 for (int i = 0; i &lt; length; i++) &#123; sorted = true; //每一轮多少元素参与排序 for (int j = 0; j &lt; length - 1 - i; j++) &#123; if (numArr[j] &gt; numArr[j + 1]) &#123; /** * 交换顺序，不使用临时变量，利用 * a = a + b; * b = a - b; * a = a - b; */ numArr[j] = numArr[j] + numArr[j + 1]; numArr[j + 1] = numArr[j] - numArr[j + 1]; numArr[j] = numArr[j] - numArr[j + 1]; sorted = false; &#125; &#125; if (sorted) &#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] numArr = &#123;27, 11, 13, 45, 34, 22, 19, 8, 3, 99, 74, 55, 88, 66&#125;; System.out.println("**************冒泡排序******************"); System.out.println("排序前："); CommonUtils.display(numArr); System.out.println("排序后："); bubbleSortImprove(numArr); CommonUtils.display(numArr); &#125;&#125; CommonUtils工具类： 12345678910111213141516171819202122package main.java.com.study.utils;/** * @author: whb * @description: 工具类 */public class CommonUtils &#123; /** * 遍历打印 * * @param numArr */ public static void display(int[] numArr) &#123; if (numArr != null &amp;&amp; numArr.length &gt; 0) &#123; for (int num : numArr) &#123; System.out.print(num + " "); &#125; &#125; System.out.println(""); &#125;&#125; 测试结果如下:]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--单例模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[单例模式介绍** 意图 **：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 ** 主要解决 **：一个全局使用的类频繁地创建与销毁。 ** 何时使用 **：当您想控制实例数目，节省系统资源的时候。 ** 如何解决 **：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 ** 关键代码 **：构造函数是私有的。 ** 优点 **： 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 避免对资源的多重占用（比如写文件操作）。 ** 缺点 **：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 ** 使用场景 **： 要求生产唯一序列号。 WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 实现方式饿汉式（静态常量）【可用】** 代码实现 **： 12345678910111213141516171819202122package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 饿汉式（静态常量）【可用】 * 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。 * 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。 */public class Hungry &#123; //自有永久的对象 private static final Hungry hungry = new Hungry(); //构造器私有化 private Hungry() &#123; System.out.println("饿汉式（静态常量）..."); &#125; public static Hungry getInstance() &#123; return hungry; &#125;&#125; ** 测试类 **： 123456789101112131415161718192021package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 饿汉式（静态常量）【可用】 */ Hungry hungry = Hungry.getInstance(); System.out.println("第" + (finalI + 1) + "次获得的hungry对象的hashCode：" + hungry.hashCode()); &#125;).start(); &#125; &#125;&#125; ** 输出结果 **： 饿汉式（静态代码块）【可用】** 代码实现 **： 12345678910111213141516171819202122232425package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 饿汉式（静态代码块）【可用】 * 将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。 * 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。 * 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。 */public class Hungry2 &#123; private static Hungry2 hungry2; static &#123; hungry2 = new Hungry2(); &#125; private Hungry2() &#123; System.out.println("饿汉式（静态代码块）..."); &#125; public static Hungry2 getInstance() &#123; return hungry2; &#125;&#125; ** 测试类 **： 123456789101112131415161718192021package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 饿汉式（静态代码块）【可用】 */ Hungry2 hungry2 = Hungry2.getInstance(); System.out.println("第" + (finalI + 1) + "次获得的hungry2对象的hashCode：" + hungry2.hashCode()); &#125;).start(); &#125; &#125;&#125; ** 输出结果 **： 懒汉式（线程不安全）【不可用】** 代码实现 **： 123456789101112131415161718192021222324package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 懒汉式（线程不安全）【不可用】 * 这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。 * 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句， * 这时便会产生多个实例。所以在多线程环境下不可使用这种方式。 */public class Lazy &#123; private static Lazy lazy; private Lazy() &#123; System.out.println("懒汉式（线程不安全）..."); &#125; public static Lazy getInstance() &#123; if (lazy == null) &#123; lazy = new Lazy(); &#125; return lazy; &#125;&#125; ** 测试类 **： 123456789101112131415161718192021package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 懒汉式（线程不安全）【不可用】 */ Lazy lazy = Lazy.getInstance(); System.out.println("第" + (finalI + 1) + "次获得的lazy对象的hashCode：" + lazy.hashCode()); &#125;).start(); &#125; &#125;&#125; ** 输出结果 **： 懒汉式(线程安全，同步方法)【不推荐用】** 代码实现 **： 123456789101112131415161718192021222324package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 懒汉式(线程安全，同步方法)【不推荐用】 * 有点：解决了线程不安全问题，做个线程同步就可以了，于是就对getInstance()方法进行了线程同步。 * 缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。 * 而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。 */public class Lazy2 &#123; private static Lazy2 lazy; private Lazy2() &#123; System.out.println("懒汉式(线程安全，同步方法)..."); &#125; public static synchronized Lazy2 getInstance() &#123; if (lazy == null) &#123; lazy = new Lazy2(); &#125; return lazy; &#125;&#125; ** 测试类 **： 123456789101112131415161718192021package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 懒汉式(线程安全，同步方法)【不推荐用】 */ Lazy2 lazy2 = Lazy2.getInstance(); System.out.println("第" + (finalI + 1) + "次获得的lazy2对象的hashCode：" + lazy2.hashCode()); &#125;).start(); &#125; &#125;&#125; ** 输出结果 **： 懒汉式(线程安全 ， 同步代码块)【不可用】** 代码实现 **： 12345678910111213141516171819202122232425package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 懒汉式(线程安全 ， 同步代码块)【不可用】 * 由于同步方法的同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。 * 但是这种同步并不能起到线程同步的作用。假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。 */public class Lazy3 &#123; private static volatile Lazy3 lazy; private Lazy3() &#123; System.out.println("懒汉式(线程安全，同步代码块)..."); &#125; public static Lazy3 getInstance() &#123; if (lazy == null) &#123; synchronized (Lazy3.class) &#123; lazy = new Lazy3(); &#125; &#125; return lazy; &#125;&#125; ** 测试类 **： 123456789101112131415161718192021package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 懒汉式(线程安全，同步代码块)【不可用】 */ Lazy3 lazy3 = Lazy3.getInstance(); System.out.println("第" + (finalI + 1) + "次获得的lazy3对象的hashCode：" + lazy3.hashCode()); &#125;).start(); &#125; &#125;&#125; ** 输出结果 **： 静态内部类【推荐用】** 代码实现 **： 12345678910111213141516171819202122232425package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 静态内部类【推荐用】 * 这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。 * &lt;p&gt; * 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 * &lt;p&gt; * 优点：避免了线程不安全，延迟加载，效率高。 */public class StaticInnerClass &#123; private StaticInnerClass() &#123; System.out.println("静态内部类..."); &#125; private static class SingletonInstance &#123; private static StaticInnerClass instance = new StaticInnerClass(); &#125; public static StaticInnerClass getInstance() &#123; return SingletonInstance.instance; &#125;&#125; ** 测试类 **： 123456789101112131415161718192021package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 静态内部类【推荐用】 */ StaticInnerClass staticInnerClass = StaticInnerClass.getInstance(); System.out.println("第" + (finalI + 1) + "次获得的staticInnerClass对象的hashCode：" + staticInnerClass.hashCode()); &#125;).start(); &#125; &#125;&#125; ** 输出结果 **： 双重检查【推荐用】** 代码实现 **： 123456789101112131415161718192021222324252627package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 双重检查【推荐用】 * 我们进行了两次if (doubleCheck == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (doubleCheck == null)，直接return实例化对象。 * 优点：线程安全；延迟加载；效率较高。 */public class DoubleCheck &#123; private static volatile DoubleCheck doubleCheck; private DoubleCheck() &#123; System.out.println("双重检查..."); &#125; public static DoubleCheck getInstance() &#123; if (doubleCheck == null) &#123; synchronized (DoubleCheck.class) &#123; if (doubleCheck == null) &#123; doubleCheck = new DoubleCheck(); &#125; &#125; &#125; return doubleCheck; &#125;&#125; ** 测试类 **： 123456789101112131415161718192021package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 双重检查【推荐用】 */ DoubleCheck doubleCheck = DoubleCheck.getInstance(); System.out.println("第" + (finalI + 1) + "次获得的doubleCheck对象的hashCode：" + doubleCheck.hashCode()); &#125;).start(); &#125; &#125;&#125; ** 输出结果 **： 枚举【推荐用】** 代码实现 **： 12345678910111213package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 枚举【推荐用】 * 不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。 */public enum EnumSingleton &#123; Instance; public void whatEverMethod() &#123; &#125;&#125; ** 测试类 **： 123456789101112131415161718192021package main.java.com.study.designPatterns.single;/** * @author: whb * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 双重检查【推荐用】 */ DoubleCheck doubleCheck = DoubleCheck.getInstance(); System.out.println("第" + (finalI + 1) + "次获得的doubleCheck对象的hashCode：" + doubleCheck.hashCode()); &#125;).start(); &#125; &#125;&#125; ** 输出结果 **：]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~检出]]></title>
    <url>%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E6%A3%80%E5%87%BA.html</url>
    <content type="text"><![CDATA[HEAD的重置即检出HEAD可以理解为“头指针”，是当前工作区的“基础版本”，当执行提交时，HEAD指向的提交作为新提交的父提交。看看当前HEAD的指向。 1$ cat .git/HEAD 可以看出HEAD指向了分支master，此时执行git branch会看到当前处于master分支。 1$ git branch -v 现在使用git checkout命令检出该ID的父提交，看看会怎么样。 1$ git checkout 23995a2 翻译一下上面的输出结果： 12345678910$ git checkout 23995a2注意：正在检出 &apos;23995a2&apos;.您现在处于&apos;分离头指针&apos;状态，您可以检查、测试和提交，而不影响任何分支。通过执行另外的一个 checkout 检出指令会丢弃在此状态下的修改和提交。如果想保留在此状态下的修改和提交，使用 -b 参数调用 checkout 检出指令以创建新的跟踪分支。如： git checkout -b new_branch_name 头指针现在指向 23995a2... 提交说明为：does master follow this new commit? 什么叫做“分离头指针”状态？查看一下此时的HEAD的内容就明白了。 12$ cat .git/HEAD23995a2d61d0a2667ba0db8aa4a17b127c1977d1 原来“分离头指针”状态指的就是HEAD头指针指向了一个具体的提交ID，而不是一个引用（分支）。 查看最新提交的reflog也可以看到当针对提交执行git checkout命令时，HEAD头指针就被更改了：由指向master分支变成了指向一个提交ID。 12$ git reflog -l23995a2 (HEAD, master) HEAD@&#123;0&#125;: checkout: moving from master to 23995a2 注意上面的reflog是HEAD头指针的变迁记录，而非master分支。查看一下HEAD和master对应的提交ID，会发现现在它们指向的不一样。 1$ git rev-parse HEAD master 前一个是HEAD头指针的指向，后一个是master分支的指向。而且还可以看到执行git checkout命令与执行git reset命令不同，分支(master)的指向并没有改变，仍旧指向原有的提交ID。现在版本库的HEAD是指向23995a提交的，再做一次提交，HEAD会如何变化？ 先做一次修改：创建一个新文件detached-commit.txt，添加到暂存区中。 12$ touch detached-commit.txt $ git add detached-commit.txt 看一下状态，会发现其中有“当前不处于任何分支”的字样，显然这是因为HEAD处于“分离头指针”模式。 1$ git status 执行提交。在提交输出中也会出现[detached HEAD...]的标识，这也是对用户的警示。 1$ git commit -m &quot;commit in detached HEAD mode&quot; 此时头指针指向了新的提交。 12$ cat .git/HEAD1fe77f7b9993cd79b050826df1c73715cc1d1e45 再查看一下日志会发现新的提交是建立在之前的提交基础上的。 1$ git log --graph --oneline 记下新的提交ID(1fe77f7b9993cd79b050826df1c73715cc1d1e45)，然后以master分支名作为参数执行git checkout命令，会切换到master分支上。 切换到master分支上，再没有之前大段的文字警告。 1$ git checkout master 因为HEAD头指针重新指向了分支，而不是处于“分离头指针模式”。 1$ cat .git/HEAD 切换之后，之前本地建立的detached-commit.txt文件不见了。 12$ lsnew-commit.txt welcome.txt 切换之后，刚才的提交日志也不见了。 1$ git log --graph --oneline 刚才的提交还存在于版本库的对象库中吗？看看刚才记下的提交ID。 1$ git show 1fe77 可以看出这个提交现在仍在版本库中。由于这个提交没有被任何分支跟踪到，因此不能保证这个提交会永久存在。实际上当reflog中含有该提交的日志过期后，这个提交随时都会从版本库中彻底清除。 挽救分离头指针在“分离头指针”模式下进行的测试提交除了使用ID（1fe77）访问之外，不能通过master分支或其他引用访问到。如果这个提交是master分支所需的，那么该如何处理？如果使用git reset，的确可以将master分支重置到该测试提交的1fe77，但这就会丢掉master分支原先的提交23995a2。使用合并操作git merge可以实现两者的兼顾。下面的操作会将提交1fe77合并到master分支中来，具体操作如下： 确认当前处于master分支。 1$ git branch -v 执行合并操作，将1fe77提交合并到当前分支。 1$ git merge 1fe77 工作区中多了一个detached-commit.txt文件。 深入了解git checkout命令git checkout是Git常用的命令之一，同时也是很危险的命令，因为这条命令会重写工作区。检出命令的用法如下： 123用法一： git checkout [-q] [&lt;commit&gt;] [--] &lt;paths&gt;...用法二： git checkout [&lt;branch&gt;]用法三： git checkout [-m] [[-b|--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;] 用法一和用法二的区别在于，用法一在命令中包含路径。为了避免路径和引用（或者提交ID）同名而发生冲突，可以在前用两个连续的短线作为分隔。 第一种用法的是可选项，如果省略相当于从暂存区(index)进行检出。这和重置命令大不相同：重置的默认值是HEAD，而检出的默认值是暂存区。因此重置一般用于重置暂存区(除非使用–hard参数，否则不重置工作区)，而检出命令主要是覆盖工作区(如果不省略，也会替换暂存区中相应的文件)。 用法一(包含了路径的用法)不会改变HEAD头指针，主要是用于指定版本的文件覆盖工作区中对应的文件。如果省略，则会用暂存区的文件覆盖工作区的文件，否则用指定提交中的文件覆盖暂存区和工作区中对应的文件。 用法二(不使用路径的用法)则会改变HEAD头指针。之所以后面的参数写作，是因为只有HEAD切换一个分支才可以对提交进行跟踪，否则仍然会进入“分离头指针”状态。在“分离头指针”状态下的提交不能被引用关联到，从而可能丢失。用法二的最主要作用就是切换到分支。如果省略则相当于对工作区进行状态检查。 用法三主要是创建和切换到新分支()，新的分支从指定的提交开始创建。新分支和我们熟悉的master分支没有什么实质的不同，都是在refs/heads命名空间下引用。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~重置]]></title>
    <url>%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E9%87%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[分支游标master的探秘先来看看当有新的提交发生时，文件.git/refs/heads/master的内容如何改变。首先在工作区创建一个新文件，姑且叫做new-commit.txt，然后提交到版本库中。 123$ touch new-commit.txt $ git add new-commit.txt $ git commit -m &quot;does master follow this new commit?&quot; 此时工作目录下会有两个文件，其中文件new-commit.txt是新增的。 12$ lsnew-commit.txt welcome.txt 来看看master分支指向的提交ID是否改变了。 先看看在版本库引用空间(.git/refs/目录)下的master文件内容的确更改了，指向了新的提交。 12$ cat .git/refs/heads/master23995a2d61d0a2667ba0db8aa4a17b127c1977d1 再用git log查看一下提交日志，可以看到刚刚完成的提交。 1$ gilt log --graph --oneline 引用refs/heads/master就好像是一个游标，在有新的提交发生的时候指向了新的提交。可是如果只可上、不可下，就不能称为“游标”。Git提供了git reset命令，可以将“游标”指向任意一个存在的提交ID。下面就尝试人为更改游标。 1$ git reset --hard HEAD^ 注意，上面的命令中使用了--hard参数，会破坏工作区未提交的改动，要慎用。这条命令将master重置到了上一个老的提交上，来看下master文件内容是否更改了。 12$ cat .git/refs/heads/mastera67c6fdd0a0e809340944432a3bf7d78e7e10f31 果然master分支的引用文件的指向更改为前一次提交的ID了。而且通过下面的命令可以看到新添加的文件new-commit.txt也丢失了。 1$ ls 重置命令不仅可以重置到前一次提交，还可以直接使用提交ID重置到任何一次提交。 通过git log查询到最早的提交ID。 1$ git log --graph --oneline 然后重置到最早的一次提交。 1$ git reset --hard d3e0684 -重置后会发现welcome.txt也回退到了最原始版本库，曾经的修改都丢失了。 1$ cat welcome.txt 使用重置命令很危险，会彻底的丢弃历史。那么还能够通过浏览提交历史的办法找到丢弃的提交ID，再使用重置命令恢复历史吗？不可能！！！因为重置让提交历史也改变了。 1$ git log 使用reflog挽救错误的重置如果没有记下重置前master分支指向的提交ID，想要重置回原来的提交真的是一件麻烦的事情(去对象库中一个个地找)。幸好Git提供了一个挽救机制，通过.git/logs目录下日志文件记录了分支的变更。默认非裸版本库（带有工作区）都提供分支日志功能，这是因为带有工作区的八本库都有如下设置： 1$ git config core.logallrefupdates 查看一下master分支的日志文件.git/logs/refs/heads/master中的内容。下面命令显示了该文件的最后几行。 1$ tail -5 .git/logs/refs/heads/master 可以看出这个文件记录了master分支指向的变迁，最新的改变追加到文件的末尾因此最后出现。最后一行可以看出因执行git reset --hard命令，指向的提交ID由a67c6f改变为d3e0684。Git提供了一个git reflog命令，对这个文件进行操作。使用show子命令可以显示此文件的内容。 1$ git reflog show master | head -5 使用git reflog的输出和直接查看日志文件最大的不同在于显示顺序不同，即最新改变放在了最前面显示，而且只显示每次改变的最终的SHA1哈希值。还有个区别在于使用git reflog的输出中还提供了一个方便易记的表达式：&lt;refname&gt;@{&lt;n&gt;}。这个表达式的含义是引用&lt;refname&gt;之前第次改变时的SHA1哈希值。那么将引用master切换到两次变更之前的值，可以使用如下命令： 重置master为两次改变之前的值。 1$ git reset --hard master@&#123;2&#125; 重置后工作区中文件new-commit.txt又回来了。 12$ lsnew-commit.txt welcome.txt 提交的历史也回来了。 1$ git log --oneline 此时如果再用git reflog查看，会看到恢复master的操作也记录在了日志中。 1$ git reflog show master | head -5 深入了解git reset命令重置命令git reset是Git最常用的命令之一，也是最危险，最容易误用的命令。用法如下： 12用法一：git reset [-q] [&lt;commit&gt;] [--] &lt;paths&gt;…​用法二：git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;] 上面列出的用法中，是可选项，可以使用引用或者提交ID，如果省略则相当于使用了HEAD的指向作为提交ID。上面列出的两种用法的区别在于，第一种用法在命令中包含路径&lt;paths&gt;。为了避免路径和引用（或者提交ID）同名而冲突，可以在&lt;paths&gt;前用两个连续的短线作为分隔。 第一种用法不会重置引用，更不会改变工作区，而是用指定提交状态（）下的文件（）替换掉暂存区的文件。例如命令git reset HEAD &lt;paths&gt;相当于取消之前执行的git add &lt;paths&gt;命令时改变的暂存区。 第二种用法（不使用路径&lt;paths&gt;的用法）则会重置引用。根据不同的选项，可以对暂存区或者工作区进行重置。参照下面的版本库模型图，来看一看不同的参数对第二种重置语法的影响。 命令格式：git reset [–soft | –mixed | –hard] [] 使用参数--hard，如：git reset --hard &lt;commit&gt; 会执行上图中的1、2、3全部的三个动作。即： 替换引用的指向。引用指向新的提交ID。 替换暂存区。替换后，暂存区的内容和引用指向的目录树一致。 替换工作区。替换后，工作区的内容变得和暂存区一致，也和HEAD指向的目录树内容相同。 使用参数--soft，如：git reset --soft &lt;commit&gt;，会执行上图中的操作1.即只更改引用的指向，不改变暂存区和工作区。 使用参数--mixed或者不使用参数（缺省为--mixed），如：git reset &lt;commit&gt;，会执行上图中的操作1和操作2。即更改引用的指向以及重置暂存区，但不改变工作区。 下面通过一些示例，看一下重置命令的不同用法。 命令：git reset仅用HEAD指向的目录树重置暂存区，工作区不受影响，相当于将之前用git add命令更新到暂存区的内容撤出暂存区。引用也未改变，因为引用重置到HEAD相当于没有重置。 命令：git reset HEAD 同上。 命令：git reset -- filename。仅将文件filename撤出暂存区，暂存区中其他文件不改变。相当于对命令git add filename的反向操作。 命令：git reset HEAD filename。同上。 命令：git reset --soft HEAD^。工作区和暂存区不改变，但是引用向前回退一次。当对最新提交的提交说明或者提交的更改不满意时，撤销下最新的提交以便重新提交。 之前曾经介绍过一个修改提交命令：git commit --amend，用于对最新的提交进行重新提交以修补错误的提交说明或者错误的提交文件。修补命令实际上相当于执行了下面两条命令。（文件.git/COMMIT_EDITMSG保存了上次的提交日志） 12$ git reset --soft HEAD^$ git commit -e -F .git/COMMIT_EDITMSG 命令：git reset HEAD^。工作区不改变，但是暂存区会回退到上一次提交之前，引用也会回退一次。 命令：git reset --mixed HEAD^。同上。 命令：git reset --hard HEAD^。彻底撤销最近的提交。引用会回退到前一次，而且工作区和暂存区都会回退到上一次提交的状态。自上一次以来的提交全部丢失。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~对象]]></title>
    <url>%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E5%AF%B9%E8%B1%A1.html</url>
    <content type="text"><![CDATA[Git对象库探秘通过查看日志的详尽输出，会看到非常多的SHA1哈希值。 1$ git log -l --pretty=raw 一个提交中居然包含了三个SHA1哈希值表示的对象ID。 commit a67c6fdd0a0e809340944432a3bf7d78e7e10f31这是本次提交的唯一标识。 tree b79fd13fac802739388af44a81d72b6e1d68da89这是本次提交所对应的的目录树。 parent d3617dadd10c274e6e2b6caf47635d5771b9034c这是本次提交的父提交（上一次提交）。 研究Git对象ID的一个重量级武器：git cat-file命令。用下面的命令可以查看这三个ID的类型。 123456$ git cat-file -t a67c6fcommit$ git cat-file -t b79ftree$ git cat-file d3617commit 在引用对象ID的时候，没有必要把整个40位的ID写全，只需要从头开始的几位不冲突即可。下面再使用git cat-file命令查看一下这几个对象的内容。 commit对象a67c6fdd0a0e809340944432a3bf7d78e7e10f31 1$ git cat-file -p a67c6f tree对象b79fd13fac802739388af44a81d72b6e1d68da89 1$ git cat-file -p b79fd commit对象d3617dadd10c274e6e2b6caf47635d5771b9034c 1$ git cat-file -p d3617 在上面目录树(tree)对象中看到了一个新的类型的对象：blob对象。这个对象保存着文件welcome.txt的内容。 该对象的类型为blob。 12$ git cat-file -t d7230d74c5f8d61ff3c1adbfd3b035c09cb62c16blob 该对象的内容就是welcome.txt文件的内容。 123$ git cat-file -p d7230d74c5f8d61ff3c1adbfd3b035c09cb62c16Hello Git.很高兴见到你。 这些对象保存在哪里？当然是Git库中的objects目录下（ID的前两位作为目录名，后38位作为文件名。） 用下面的命令可以看到这些对象在对象库中的实际位置。 1for id in a67c6f b79fd d3617 d7230d; do ls .git/objects/$&#123;id:0:2&#125;/$&#123;id:2&#125;*;done 通过下面的命令可以看到提交对象之间相互关联的跟踪连。 1$ git log --pretty=raw --graph a67c 上面的命令通过--graph参数可以看到提交链路，通过--pretty=raw参数以便显示每个提交对象的parent属性。最后一个提交没有parent属性，所以跟踪连到此终结，这实际上就是提交的起点。 HEAD和Master探秘现在先看下工作区的状态。 12$ git status -s -b## master 上面在显示工作区状态时，除了使用-s参数以显示精简输出外，还使用了-b参数以便能够同时显示出当前工作分支的名称。使用git branch也可以显示当前的工作分支。 12$ git branch * master 在master分支名称前面出现一个星号表明这个分支是当前工作分支。现在连续执行下面三个命令会看到相同的输出： 12345$ git log -1 HEAD $ git log -1 master $ git log -1 refs/heads/master 也就是说在当前版本库中，HEAD、master和refs/heads/master具有相同的指向。让我们去版本库.git目录中看一看。 12345$ find .git -name HEAD -o -name master.git/HEAD.git/logs/HEAD.git/logs/refs/heads/master.git/refs/heads/master 显示一下.git/HEAD的内容： 12$ cat .git/HEADref: refs/heads/master 把HEAD的内容翻译过来就是：“指向一个引用：refs/heads/master”。这个引用在文件.git/refs/heads/master。 12$ cat .git/refs/heads/mastera67c6fdd0a0e809340944432a3bf7d78e7e10f31 用git cat-file命令查看下a67c6fdd0a0e809340944432a3bf7d78e7e10f31的内容。 显示SHA1哈希值指代的数据类型。 12$ git cat-file -t a67c6commit 显示提交的内容。 1234567$ git cat-file -p a67c6tree b79fd13fac802739388af44a81d72b6e1d68da89parent d3617dadd10c274e6e2b6caf47635d5771b9034cauthor wanghongbo &lt;270028806@qq.com&gt; 1560174530 +0800committer wanghongbo &lt;270028806@qq.com&gt; 1560174530 +0800哪个版本的数据会被提交？ 原来分支master指向的是一个提交ID（最新提交）。这样的分支实现很巧妙：既然可以从任何提交开始建立一条历史跟踪连，那么用一个文件指向这个链条的最新提交，那么这个文件就可以用于追踪整个提交历史了。这个文件就是.git/refs/heads/master文件。下面看一个更接近于真实的版本库结构图： 目录.git/refs是保存引用的命名空间，其中.git/refs/heads目录下的引用又称为分支。对于分支既可以使用正规的长格式表示法，如refs/heads/master，也可以去掉前面的两级目录用master表示。Git有一个底层命令git rev-parse可以用于显示引用对应的提交ID。 12345678$ git rev-parse mastera67c6fdd0a0e809340944432a3bf7d78e7e10f31$ git rev-parse refs/heads/master a67c6fdd0a0e809340944432a3bf7d78e7e10f31$ git rev-parse HEAD a67c6fdd0a0e809340944432a3bf7d78e7e10f31 可以看出它们都指向同一个对象。下面来展示一下提交的SHA1哈希值生成方法。 看看HEAD对应的提交的内容。使用git cat-file命令。 1234567$ git cat-file commit HEADtree b79fd13fac802739388af44a81d72b6e1d68da89parent d3617dadd10c274e6e2b6caf47635d5771b9034cauthor wanghongbo &lt;270028806@qq.com&gt; 1560174530 +0800committer wanghongbo &lt;270028806@qq.com&gt; 1560174530 +0800哪个版本的数据会被提交？ 提交信息中总共包含243个字符。 1$ git cat-file commit HEAD | wc -c 在提交信息的前面加上内容commit 243&lt;null&gt;(为空字符)，然后执行SHA1哈希算法。 12$ (printf &quot;commit 243\000&quot;; git cat-file commit HEAD) | sha1suma67c6fdd0a0e809340944432a3bf7d78e7e10f31 *- 上面命令得到的哈希值和用git rev-parse看到的是一样的。 1$ git rev-parse HEAD 下面看一看文件内容的SHA1哈希值生成方法。 看看版本库中welcome.txt的内容，使用git cat-file命令。 123$ git cat-file blob HEAD:welcome.txtHello Git.很高兴见到你。 文件总共包含33字节的内容。 12$ git cat-file blob HEAD:welcome.txt | wc -c 33 在文件内容的前面加上blob 33&lt;null&gt;的内容，然后执行SHA1哈希算法。 12$ (printf &quot;blob 33\000&quot;; git cat-file blob HEAD:welcome.txt) | sha1sumd7230d74c5f8d61ff3c1adbfd3b035c09cb62c16 *- 上面命令得到的哈希值和用git rev-parse看到的是一样的。 12$ git rev-parse HEAD:welcome.txtd7230d74c5f8d61ff3c1adbfd3b035c09cb62c16 最后再来看看树的SHA1哈希值的形成方法。 HEAD对应的树的内容共包含39个字节。 12$ git cat-file tree HEAD^&#123;tree&#125; | wc -c39 在树的内容的前面加上tree 39&lt;null&gt;的内容，然后执行SHA1哈希算法。 12$ (printf &quot;tree 39\000&quot;; git cat-file tree HEAD^&#123;tree&#125;) | sha1sumb79fd13fac802739388af44a81d72b6e1d68da89 *- 上面命令得到的哈希值和用git rev-parse看到的是一样的。 12$ git rev-parse HEAD^&#123;tree&#125;b79fd13fac802739388af44a81d72b6e1d68da89 Git提供了很多方法可以方便的访问Git库中的对象。 采用部分SHA1哈希值。不必写全40位的哈希值，只采用开头的部分，不和现有其他的冲突即可。 使用master代表分支master中最新的提交，使用全称refs/heads/master亦可。 使用HEAD代表版本库中最近的一次提交。 符号^可以用于指代父提交。例如： HEAD^代表版本库中上一次提交，即最近一次提交的父提交。 HEAD^^则代表HEAD^的父提交。 对于一个提交有多个父提交，可以在符号^后面用数字表示是第几个父提交。例如： a5731^2含义是提交a5731的多个父提交中的第二个父提交。 HEAD^1相当于HEAD^含义是HEAD多个父提交中的第一个。 HEAD^^2含义是HEAD^(HEAD父提交)的多个父提交中的第二个。 符号~&lt;n&gt;也可以用于指代祖先提交。下面两个表达式效果等同： 12a5731~5a5731^^^^^ 提交所对应的树对象，可以用类似如下的语法访问。 1a5731^&#123;tree&#125; 某一此提交对应的文件对象，可以用如下的语法访问。 1a5731:path/to/file 暂存区中的文件对象，可以用如下语法访问。 1:path/to/file 下面使用git rev-parse练习下。 12345678910111213141516$ git rev-parse HEAD a67c6fdd0a0e809340944432a3bf7d78e7e10f31$ git cat-file -p a67c6f tree b79fd13fac802739388af44a81d72b6e1d68da89parent d3617dadd10c274e6e2b6caf47635d5771b9034cauthor wanghongbo &lt;270028806@qq.com&gt; 1560174530 +0800committer wanghongbo &lt;270028806@qq.com&gt; 1560174530 +0800哪个版本的数据会被提交？$ git rev-parse a67c6f^&#123;tree&#125;b79fd13fac802739388af44a81d72b6e1d68da89$ git rev-parse a67c6f^^&#123;tree&#125;a070b35c2d55e057a2eead7b8ae1b06c3e4d8e3b]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~工作区、暂存区、HEAD]]></title>
    <url>%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E5%B7%A5%E4%BD%9C%E5%8C%BA%E3%80%81%E6%9A%82%E5%AD%98%E5%8C%BA%E3%80%81HEAD.html</url>
    <content type="text"><![CDATA[首先看一下git-demo的提交日志，使用git log查看提交日志（附加--stat参数可以看到每次提交的文件变更统计）。 1$ git log --stat 通过日志可以看到第一次提交对文件welcome.txt有一行的变更，而第二次提交因为使用了--allow-empty参数进行的空提交，所以提交说明中看不到任何对实质内容的修改。 修改不能直接提交？首先更改welcome.txt文件的内容，在文件后面追加一行。 1$ echo &quot;很高兴见到你。&quot; &gt;&gt; welcome.txt 这时就可以通过git diff命令看到修改后的文件和版本库中文件的差异。实质和本地比较的不是版本库，而是一个中间状态的文件。 1$ git diff 接下来执行提交，看能否提交成功。 1$ git commit -m &quot;追加一行：很高兴见到你。&quot; 提交成功了吗？好像没有。提交没有成功的证据： 先看看提交日志，如果提交成功就会有新的提交记录。 1$ git log --pretty=oneline 使用了精简输出来显示日志，以便更简洁和清晰地看到提交历史。可以看到版本库中只有两个提交，针对刚才修改文件的提交没有成功！ 执行git diff可以看到和之前相同的差异输出，这也说明提交没有成功。 执行git status查看文件状态，可以看到文件处于未提交状态。 执行git status -s可以显示精简格式的状态输出。 提交为什么会失败呢？原因是没有对修改的welcome.txt文件执行git add命令，将修改的文件添加到“提交任务”，然后才能提交。现在就将修改的文件“添加”到提交任务。 1$ git add welcome.txt 现在再执行一些Git命令，看看当执行“添加”后会发生什么变化。 执行git diff没有输出。 执行git diff head或git diff master进行比较会发现有差异，这个差异是正常的，因为还没有提交。 1$ git diff head 执行git status，状态输出和之前不一样了。 1$ git status 对新的Git状态输出做下翻译： 12345位于分支master上下列的修改将被提交： （如果你后悔了，可以使用“git reset HEAD &lt;file&gt;...”命令将下列改动撤出提交任务（提交暂存区，stage）， 否则执行提交命令将会提交） 已修改： welcome.txt 不得不说，Git太人性化了，它把各种情况下可以使用到的命令都告诉了用户，虽然这显得有点啰嗦。如果不要这么啰嗦，可以使用简洁方式： 12$ git status -sM welcome.txt 上面精简状态输出与执行git add之前的精简状态的输出相比，有细微的差别。 虽然都是M(Modified)标识，但是位置不同。在执行git add之前，这个M位于第二列（第一列是个空格），执行完git add之后，字符M位于第一列（第二列是空白）。 位于第一列的字符M的含义：版本库中的文件和处于中间状态–提交任务（提交暂存区，stage）中的文件相比有改动； 位于第二列的字符M的含义：工作区当前的文件和处于中间状态–提交任务（提交暂存区，stage）中的文件相比有改动。这时如果直接提交git commit,加入提交任务的welcome.txt文件的更改就被提交入库了。但是先不忙着提交，再进行一些操作，看看能否被彻底搞糊涂。 继续修改welcome.txt文件（在文件后面追加一行）。 1$ echo &quot;Good-bye&quot; &gt;&gt; welcome.txt 然后执行git status查看一下状态： 1git status 状态输出中居然是之前出现的两种不同状态的输出。 使用简洁模式输出，也会看到两种精简输出的杂合。 1git status -s 上面Git状态的输出可以这么理解：不但版本库中最新提交的文件和处于中间状态（提交暂存区，stage）中文件相比有改动，而且工作区当前的文件和处于中间状态（提交暂存区，stage）中的文件相比也有改动。即现在welcome.txt中有三个不同的版本：一个在工作区，一个在暂存区，一个是版本库中最新版本。通过不同的参数调用git diff命令可以看到不同版本库之间的差异。 不带任何选项和参数调用git diff显示工作区最新改动，即工作区和提交暂存区中相比的差异。 将工作区和HEAD（当前工作分支）相比，会看到更多差异。 通过参数--cached或者--staged参数调用git diff命令，看到的是提交暂存区和版本库中文件的差异。 好了，现在提交下看看。 123$ git commit -m &quot;哪个版本的数据会被提交？&quot;[master a67c6fd] 哪个版本的数据会被提交？ 1 file changed, 1 insertion(+) 这次提交终于成功了，查看下日志： 1234$ git log --pretty=onelinea67c6fdd0a0e809340944432a3bf7d78e7e10f31 (HEAD -&gt; master) 哪个版本的数据会被提交？d3617dadd10c274e6e2b6caf47635d5771b9034c 这是谁提交的？d3e0684a1c510f4effd155b01591019e2c5d7812 初始化的第一次提交 查看精简状态输出： 12$ git status -s M welcome.txt 状态输出中文件名的前面出现了一个字母M，即只位于第二列的字母M。那么第一列的M去哪了？很明显被提交了。即提交任务（提交暂存区，stage）中的内容被提交到版本库，所以第一列因为提交暂存区和版本库中的状态一致，所以显示空白。那提交的welcome.txt是哪个版本呢？通过执行git diff或者git diff head命令查看差异。虽然命令git diff和git diff head的比较过程并不同，但是会看到下面相同的差异输出结果。 12$ git diff$ git diff head 理解Git暂存区（stage）Git暂存区（stage，或称为index）的设计是Git最成功的设计之一，也是最难理解的一个设计。在版本库.git目录下，有一个index文件，下面针对这个文件做个实验。首先执行git checkout命令，撤销工作区中welcome.txt文件尚未提交的修改。 12$ git checkout -- welcome.txt$ git status -s 通过状态输出可以看到工作区已经没有改动了，查看下.git/index文件的时间戳： 2019-06-10 22:00:43 1$ ls --full-time .git/index 再次执行git status命令，然后显示.git/index文件的时间戳：2019-06-10 22:00:43，和上面的一样。 12$ git status -s $ ls --full-time .git/index 现在更改一下welcome.txt文件的时间戳，但不改变它的内容。然后再执行git status命令，然后查看.git/index文件时间戳为：22:06:32 123$ touch welcome.txt$ git status -s $ ls --full-time .git/index 可以看到时间戳改变了。这个实验说明当执行git status或者git diff命令扫描工作区改动的时候，先依据.git/index文件中记录的（工作区跟踪文件）时间戳、长度等信息判断工作区文件是否改变。如果工作区的文件时间戳改变，说明文件的内容可能被改变了，需要打开文件，读取文件内容，和更改前的原始文件相比，判断文件内容是否被更改。如果文件内容没有改变，则将该文件新的时间戳记录到.git/index文件中。因为判断文件是否更改使用的是时间戳、文件长度等信息进行比较，要比通过文件内容比较快的多，所以GIt这样的实现方式可以让工作区状态扫描更快执行，这也是Git高效的因素之一。文件.git/index实际上就是一个包含文件索引的目录树，像是一个虚拟的工作区。在这个虚拟工作区的目录树中，记录了文件名、文件的状态信息（时间戳、文件长度等）。文件的内容并不存储其中，而是保存在Git对象库.git/objects目录中，文件索引建立了文件和对象库中对象实体之间的对应。下面这张图展示了工作区、版本库中的暂存区和版本库之间的关系。 图中左侧为工作区，右侧为版本库。在版本库中标记为index的区域是暂存区(stage，亦称index),标记为master的是master分支所代表的目录树。 图中可以看出此时HEAD实际上是指向master分支的一个“游标”，所以图示的命令中出现HEAD的地方可以用master替换。 图中的objects标识的区域为Git的对象库，实际位于.git/objects目录下。 当对工作区修改（或新增）的文件执行git add命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而对象的ID被记录在暂存区的文件索引中。 当执行提交操作时，暂存区的目录树写到版本库（对象库）中，master分支会做出相应的更新。即master最新指向的目录树就是提交时原暂存区的目录树。 当执行git reset HEAD命令时，暂存区的目录树会被重写，被master分支指向的目录树所替换，但是工作区不受影响。 当执行git rm --cached &lt;file&gt;命令时，会直接从暂存区删除文件，工作区则不做改变。 当执行git checkout . 或者git checkout -- &lt;file&gt;命令时，会用暂存区全部或指定的文件替换工作区的文件，。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行git checkout HEAD .或者git checkout HEAD &lt;file&gt;命令时，会用HEAD指向的master分支中的全部或者部分文件替换暂存区和工作区中的文件。这个命令也极具危险性，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 Git Diff 魔法暂存区目录树浏览 对于HEAD（版本库中当前提交）指向的目录树，可以使用git ls-tree来查看。 12$ git ls-tree -l HEAD 100644 blob d7230d74c5f8d61ff3c1adbfd3b035c09cb62c16 33 welcome.txt 使用-l参数，可以显示文件大小。上面welcome.txt大小33字节。 输出的条目从左至右，第一个字段是文件的属性（rw-r–r–）,第二个字段说明是Git对象库中的一个blob对象（文件），第三个字段则是该文件在对象库中对应的ID–一个40位的SHA1哈希值格式的ID，第四个字段是文件大小，第五个字段是文件名。 在浏览暂存区中的目录树之前，首先清除工作区当中的改动。通过 git clean -fd命令清除当前工作区中没有加入版本库的文件和目录（非跟踪文件和目录），然后执行git checkout .命令，用暂存区刷新工作区。 12$ git clean -fd$ git checkout . 然后在工作区中做出一些修改（修改welcome.txt，增加一个子目录和文件），然后添加到暂存区。最后再对工作区做出修改。 123456$ echo &quot;( ^_^ )/~~拜拜&quot; &gt;&gt; welcome.txt$ mkdir -p a/b/c$ echo &quot;Hello.&quot; &gt;&gt; a/b/c/hello.txt $ git add .$ echo &quot;ヾ(￣▽￣)Bye~Bye~&quot; &gt;&gt; a/b/c/hello.txt $ git status -s 上面的命令运行完毕后，通过精简的状态输出，可以看出工作区、暂存区、版本库当前分支的最新版本（HEAD）各不相同。先来看看工作区中文件的大小： 123$ find . -path ./.git -prune -o -type f -printf &quot;%-20p\t%s\n&quot;./a/b/c/hello.txt 30./welcome.txt 52 要显示暂存区的目录树，可以使用git ls-files命令。 123$ git ls-files -s100644 18832d35117ef2f013c4009f5b2128dfaeff354f 0 a/b/c/hello.txt100644 a2b90cc2992cf3ff4e0d6beb0c9461158124c2b6 0 welcome.txt 这个输出和之前使用git ls-tree命令的输出不一样，如果想要使用git ls-tree命令，需要先将暂存区的目录树写入Git对象库git write-tree命令，然后在针对git write-tree命令写入的tree执行git ls-tree。 12345$ git write-tree 1e9d611d50af21a2f0ec7bce6e270fd170a8f557$ git ls-tree -l 040000 tree 53583ee687fbb2e913d18d508aefd512465b2092 - a100644 blob a2b90cc2992cf3ff4e0d6beb0c9461158124c2b6 50 welcome.txt 从上面的命令可以看出： 到处都是40位的SHA1哈希值格式的ID，可以用于指代文件内容（blob），用于指代目录树(tree)，还可以用于指代提交。 git write-tree的输出就是写入Git对象库中的Tree ID，这个ID将作为下一条命令的输入。 git ls-tree命令中，没有把40位的ID写全，而是使用了前几位，实际上只要不和其他的对象ID冲突，可以随心所欲的使用缩写ID。 git ls-tree的输出显示的第一条是一个tree对象，即刚才创建的一级目录a。 如果想要递归显示目录内容，则使用-r参数调用。使用参数-t可以把递归过程中遇到的每棵树都显示出来，而不是只显示最终的文件。下面执行递归操作显示目录树的内容。 123456$ git write-tree | xargs git ls-tree -l -r -t040000 tree 53583ee687fbb2e913d18d508aefd512465b2092 - a040000 tree 514d729095b7bc203cf336723af710d41b84867b - a/b040000 tree deaec688e84302d4a0b98a1b78a434be1b22ca02 - a/b/c100644 blob 18832d35117ef2f013c4009f5b2128dfaeff354f 7 a/b/c/hello.txt100644 blob a2b90cc2992cf3ff4e0d6beb0c9461158124c2b6 50 welcome.txt 通过使用不同的参数调用git diff命令，可以对工作区、暂存区、HEAD中的内容两两比较。下面的图展示了git diff命令的作用范围。 通过上面的图就不难理解下面命令的输出。 工作区和暂存区比较。 1$ git diff 暂存区和HEAD比较。 1$ git diff --cached 工作区和HEAD比较。 1$ git diff HEAD 不要使用git commit -a实际上Git的提交命令git commit可以带上-a参数，对本地所有变更的文件执行提交操作，包括本地修改的文件，删除的文件，但不包括未被版本库跟踪的文件。这个命令的确可以简化一些操作，但同时会丢掉Git暂存区带给用户最大的好处：对提交内容进行控制的能力。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~初始化]]></title>
    <url>%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E5%88%9D%E5%A7%8B%E5%8C%96.html</url>
    <content type="text"><![CDATA[创建版本库及第一次提交首先看一下当前Git的版本 1$ git --version 在开始Git之前，我们需要设置一下Git的环境变量，这个设置是一次性的工作。即这些设置会在全局文件（用户主目录的 .gitconfig）或系统文件（/etc/gitconfig）中做永久记录。 告诉Git当前用户的姓名和邮件地址，配置的用户名和邮件地址将在版本库提交时作为提交者的用户名和邮件地址。 12$ git config --global user.name &quot;wanghongbo&quot;$ git config --global user.email whb@163.com 设置一些Git别名，以便可以使用更为简洁的子命令。例如：输入 git ci 即相当于 git commit -s ，输入git st 即相当于 git -p status。 如果拥有系统管理员权限，希望注册的命令别名能被所有用户使用，可执行如下命令： 1234$ git config --system alias.br branch$ git config --system alias.ci &quot;commit -s&quot;$ git config --system alias.co checkout$ git config --system alias.st &quot;-p status&quot; - 如果只在本用户使用，执行下面的命令：1234$ git config --global alias.st status$ git config --global alias.ci &quot;commit -s&quot;$ git config --global alias.co checkout$ git config --global alias.br branch 创建Git版本库下面就从一个空目录开始初始化版本库，这个版本库命名为“git-demo”。首先建立一个新的工作目录，进入该目录后，执行git init创建版本库 12345$ cd /d/workspace$ mkdir git-demo$ cd git-demo$ git initInitialized empty Git repository in D:/workspace/git-demo/.git/ 从上面版本库初始化后的输出中，可以看到执行git init命令在工作区创建了隐藏目录.git。 12$ ls -aF./ ../ .git/ 这个隐藏的.git目录就是Git版本库（又叫仓库，repository）。.git版本库目录所在的目录，即/d/workspace/git-demo目录称为工作区，目前工作区除了包含一个隐藏的.git目录外空无一物。 下面在工作区中创建一个文件：welcome.txt，内容就是一行“Hello Git.”。 1$ echo &quot;Hello Git.&quot; &gt;&gt; welcome.txt 为了将这个新建立的文件添加到版本库，需要执行下面的命令： 1$ git add welcome.txt Git和大部分其他版本控制系统都需要再执行一个提交操作，对于Git执行git commit命令完成提交。在提交过程中需要输入提交说明，这个要求对Git是强制性的，不像CVS、SVN等允许空白的提交说明。在Git提交时，如果在命令行不提供提交说明（没有使用 -m 参数），Git会自动打开一个编辑器，要求您在其中输入提交说明，输入完毕保存退出。下面进行提交，为了说明方便，使用 -m 参数直接给出提交说明。 1$ git commit -m &quot;初始化的第一次提交&quot; 从上面的命令及输出可以看出： 通过-m参数设置提交说明为：“初始化的第一次提交”。该提交说明也显示在命令输出的第一行中。 命令输出的第一行还显示了当前处于名为master的分支上，提交ID为e55c54c，且该提交是该分支的第一个提交，即根提交（root-commit）。根提交和其他提交的区别在于没有关联的父提交。 命令输出的第二行开始显示本次提交所做修改的统计：修改了一个文件，包含一行的插入。 思考：Git工作区下为什么有个.git目录？Git及其他分布式版本控制系统的一个显著特点：版本库位于工作区的根目录下。对于Git，版本库位于工作区根目录下的.git目录中，且仅此一处，在工作区的子目录下则没有任何其他跟踪文件或目录。Git为什么要这样设计呢？对于CVS，工作区的根目录及每个子目录下都有一个CVS目录，该目录中包含几个配置文件，建立了对版本库的追踪。如CVS目录下的Entries文件记录了从版本库检出到工作区的文件的名称、版本和时间戳等，这样就可以通过对工作区文件时间戳的改变来判断文件是否更改。这样设计的好处是，可以将工作区移动到任何其他目录，工作区和版本控制服务器的映射关系保持不变，这样工作区依然能正常工作。甚至还将工作区的某个子目录移动到其他位置，形成新的工作区，在新的工作区仍然能完成版本控制相关的操作。但缺点也很多，例如工作区文件修改了，因为没有原始文件做比对，因此向服务器提交修改的时候只能对整个文件进行传输而不能仅传输文件的改动部分。还有一个风险就是信息泄露，通过扫描CVS/Entries文件就能得到目录下的文件列表，造成信息泄露。 对于SVN，工作区的根目录和每一个子目录下都有一个.svn目录，该目录不仅包含了类似CVS的跟踪目录下的配置文件，还包含了当前工作区下每一个文件的拷贝。多出文件的原始拷贝让某些svn命令可以脱离版本库执行，还可以在由客户端向服务器提交时，仅仅对文件改动的内容提交，因此改动的文件可以和原始拷贝进行差异比较。缺点除了像CVS跟踪目录造成信息泄露，还导致加倍占用工作区的空间。再有就是当在工作区目录下针对文件内容进行搜索时，会因为.svn目录下文件的原始拷贝，导致搜索的结果加倍，而出现混乱的搜索结果。 Git的设计，将版本库放在工作区根目录下，所有的版本控制操作（除了和远程版本库之间的相互操作）都是在本地即可完成，不向SVN只有寥寥几个命令才能脱离网络执行。而且Git也不存在安全泄露（只要保护好.git目录），也没有SVN本地文件搜索结果混乱的问题，Git甚至还提供了一条git grep命令来更好地搜索工作区的文件内容。 1$ git grep &quot;Hello&quot; 当工作区中包含子目录，在子目录中执行Git命令时，如何定位版本库？实际上，Git工作区目录下执行操作时，会对目录依次向上递归查找.git目录，找到.git目录就是工作区对应的版本库，.git所在的目录就是工作区的根目录，文件.git/index记录了工作区文件的状态（实际上是暂存区的状态）。 例如，在非Git工作区执行git命令，会因找不到.git目录而报错。 12$ cd /d/workspace/webstrom$ git status 怎样获取Git版本库的位置以及工作区根目录位置？ 先在工作区下建立目录a/b/c，进入该目录中。 12$ mkdir -p a/b/c`$ cd a/b/c 显示版本库.git目录所在的位置。 12$ git rev-parse --git-dirD:/workspace/git-demo/.git 显示工作区根目录 12$ git rev-parse --show-toplevelD:/workspace/git-demo 相对于工作区根目录的相对目录 12$ git rev-parse --show-prefixa/b/c 显示从当前目录（cd）后退（up）到工作区的根的深度。 12$ git rev-parse --show-cdup../../../ 思考：git config 命令参数的区别？在之前使用过的git config命令，有的使用了--global参数，有的使用了--system参数，这两个参数有什么区别？ 执行下面的命令，将打开D:/workspace/git-demo/.git/config文件进行编辑。 12$ cd /d/workspace/git-demo/$ git config -e 执行下面的命令，将打开C:/Users/ASUS/.gitconfig（用户主目录下的.gitconfig文件）全局配置文件进行编辑。 1$ git config -e --global 执行下面的命令，将打开E:/developerTools/git/mingw64/etc/gitconfig系统级配置文件进行编辑。 1$ git config -e --system Git的三个配置文件分别是版本库级别的配置、全局配置（用户主目录下）和系统级配置（Git安装目录下）。其中版本库级别配置文件的优先级最高，全局配置文件次之，系统级配置文件优先级最低。这样的优先级设置可以让版本库.git目录下的config文件中的配置可以覆盖用户主目录下的Git环境配置，而用户主目录下的配置也可以覆盖系统的Git配置文件。 执行之前的三个git config命令，会看到这三个级别配置文件的格式和内容，采用INI文件格式。如下： 12345678$ cat /d/workspace/git-demo/.git/config[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true git config命令可以用来读取和更改INI配置文件的内容。使用git config &lt;section&gt;.&lt;key&gt;，来读取INI配置文件中某个配置的键值。例如读取[core]小节的bare的属性值，命令如下： 12$ git config core.barefalse 如果想要更改或配置INI文件中某个属性的值也很简单，命令格式：git config &lt;section&gt;.&lt;key&gt; &lt;value&gt;。 12$ git config a.b learningGit$ git config x.y.z something 打开.git/config文件会看到增加的内容： 1234[a] b = learningGit[x &quot;y&quot;] z = something 思考：是谁提交的？在一开始我们为Git设置了user.name和user.email全局环境变量，如果不设置会怎样？执行下面的命令，删除Git全局配置文件中关于user.name和user.email的设置： 12$ git config --unset --global user.name$ git config --unset --global user.email 这样关于用户名和邮件的设置都被清空了，执行下面的命令将看不到输出 12$ git config user.name$ git config user.email 下面再进行一次提交，看看提交过程有什么不同，以及提交之后显示的提交者是谁？ 1$ git commit --allow-empty -m &quot;这是谁提交的？&quot; 上面的命令使用了--allow-empty参数，这是因为没有对工作区的文件进行任何修改，Git默认是不会执行提交，使用了--allow-empty参数后，允许执行空白提交。 从提交结果看到，因为没有设置user.name和user.email，提交结果中Git提供了详细的帮助指引来告诉如何设置必须的变量，以及如何修改之前提交中出现的错误的提交者信息。为了保证提交时提交者和作者信息的正确性，重新恢复user.name和user.email的设置。 12$ git config --global user.name &quot;wanghongbo&quot;$ git config --global user.email youreamil@email.com 然后执行下面的命令，重新修改最新的提交，修正提交者的错误信息。 1$ git commit --amend --allow-empty --reset-author 说明： 参数--amend是对刚刚的提交进行修补，这样就可以改正之前错误的提交，而不会产生新的提交； 参数--allow-empty是因为要进行修改的提交实际上是一个空白提交，Git默认不允许空白提交； 参数--reset-author的含义是将提交者的ID重置，否则会影响最新的Commit的ID。这条命令也会重置AuthorDate的信息。 通过日志可以看到提交者的信息已经改正了。 1$ git log --pretty=fuller]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~爱上Git的理由]]></title>
    <url>%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E7%88%B1%E4%B8%8AGit%E7%9A%84%E7%90%86%E7%94%B1.html</url>
    <content type="text"><![CDATA[现场版本控制 现场版本库创建。直接在需要版本控制的目录下执行Git版本库初始化命令。 1git init 添加文件并提交 12git add -Agit commit -m &quot;本次提交的内容描述&quot; 为初始提交建立一个里程碑：”v1” 1git tag v1 然后开始在工作区中工作–修改文件，提交 1git commit -a 当对修改结果满意，想将工作成功保存带走时，可以通过下面的命令，将从v1开始的历次提交逐一导出为补丁文件。转换的补丁文件都包含一个数字前缀，并提取提交日志信息作为文件名，而且补丁文件还提供对二进制文件的支持。 1git format-patch v1..HEAD 通过邮件将补丁文件发出。当然也可以通过其他方式将补丁文件带走。 1git send-email *.patch Git创建的补丁文件使用了Git扩展格式，因此在导入时为了避免数据遗漏，要使用Git提供的命令而不能使用GNU patch命令。即时要导入的不是Git版本库，也可以使用Git命令。 修改提交说明1git commit --amend 这个命令如果不带”-m”参数，会进入提交提交说明编辑界面，修改原来的提交说明，直到满意为止。 如果要修改某个历史提交的提交说明，Git也可以实现，但要用到另一个命令：变基命令。例如要修改所标识提交的提交说明，执行下面的命令，并在弹出的变基索引文件中修改相应提交前面的动作的关键字。 1git rebase -i &lt;commit-id&gt;^ 删除不应提交的文件12git rm --cached 文件名git commit --amend 如果是历史版本，例如是在所标识的提交中引入的文件，则需要使用变基操作。 1git rebase -i &lt;commit-id&gt;^ 更好用的提交列表git add 命令将修改内容加入提交暂存区。git add -u 命令可以将所有修改过的文件加入暂存区。git add -A 命令可以将本地删除文件和新增文件都登记到暂存区。git add -p 命令甚至可以对一个文件内的修改进行有选择性的添加。 一个修改后的文件被登记到提交暂存区后，可以继续修改，继续修改的内容不会被提交，除非再对此文件再执行一次 git add 命令。即一个修改文件可以拥有两个版本，在提交暂存区中有一个版本，在工作区中有另外一个版本。 执行 git commit命令提交，无须设定什么变更列表，直接将登记在暂存区中的内容提交。Git支持对提交的撤销，而且可以撤销任意多次。 工作进度保存如果工作区的修改尚未完成时，忽然有一个紧急的任务，需要从一个干净的工作区开始新的工作，或者要切换到别的分支进行工作，那么如果保存当前尚未完成的工作进度呢？ 1git stash 在切换到新的工作分支之前，执行 git stash 保存工作进度，工作区会变的非常干净，然后就可以切换到新的分支。 12git stash git checkout &lt;new_branch&gt; 新的工作分支修改完毕后，再切换回当前分支，调用 git stash pop 命令则可恢复之前保存的工作进度。 12git checkout &lt;orignal_branch&gt;git stash pop 更好的差异比较Git对差异比较进行了扩展，支持对二进制文件的差异比较，这是对GNU的 diff 和 patch 命令的重要补充。还有Git的差异比较除了支持基于行的差异比较外，还支持在一行内逐字比较的方式，当向 git diff 命令传递 --word-diff 参数时，就会进行逐字比较。在上面介绍了工作区的文件修改可能会有两个不同的版本，一个是在提交暂存区，一个是在工作区。因此在执行 git diff 命令时会遇到令Git新手费解的现象。 修改后的文件在执行 git diff 命令时会看到修改造成的差异。 修改后的文件通过 git add 命令提交到暂存区，再执行 git diff 命令会看不到该文件的差异。 执行 git diff --cached 命令才可以看到添加到暂存区中的文件所做出的修改。 无处不在的分页器分页器默认使用 less命令（less -FRSX）进行分页。下面是在分页器中常用的热键： 字母q：退出分页器； 字母h：显示分页器帮助； 按空格下翻一页，按字母b上翻一页； 字母d和u：分别代表向下翻动半页和向上翻动半页； 字母j和k：分别代表向上翻一行和向下翻一行； 如果行太长被截断，可以用左箭头和右箭头使得窗口内容左右滚动； 输入/pattern：向下寻找和pattern匹配的内容； 输入?pattern：向上寻找和pattern匹配的内容； 字母n或N：代表向前或向后继续寻找； 字母g：跳到第一行； 字母G：跳到最后一行； 输入数字再加字母g：则跳转到对应的行； 输入!：可以执行Shell命令。 对于默认未提供分页器的Git命令，例如 git status 命令，可通过下面任一方法启用分页器： 在 git 和子命令(如：status)之间插入参数-p或--paginate，为命令启用内建分页器。如： 1git -p status -设置Git变量，设置完毕后运行相应的命令，将启用内建分页器。 1git config --global pager.status true Git 命令的分页器支持带颜色的字符输出，对于太长的行则采用截断方式处理（可用左右方向键滚动）。如果不习惯分页器的长行截断模式而希望采用自动折行模式，可通过下面任一方法进行设置： 通过设置LESS环境变量来实现。 1export LESS=FRX -或者通过定义Git配置变量来改变分页器的默认行为。 1git config --global core.pager &apos;less -+$LESS -FRX&apos;]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA使用FindBugs插件]]></title>
    <url>%2FIDEA%E4%BD%BF%E7%94%A8FindBugs%E6%8F%92%E4%BB%B6.html</url>
    <content type="text"><![CDATA[下载安装在Idea中，打开”File”–&gt;”Settings”，或者使用快捷键”Ctrl+Alt+S”打开设置窗口： 在设置窗口找到** plugins *标签页，然后点击下方的 * Browse Repositories **： 在新打开的Browse Repositories窗口搜索findbugs，然后点击Install进行安装，因为我已经安装过了，所以不再显示install按钮： 使用FindBugs 简单说明： 鼠标移动到右边的所有图标，看看每个图标都是什么意思。大概说一下：第一竖列的红色图标是分析当前的这个文件。下面是分析是某一个类，鼠标所在的那个类。再往下是某个包，某个模块，整个项目，所有修改过的文件，等等。第二竖列则是控制分析结果的展示情况。 下面就整个实际找到的代码的问题，单独分析某个service文件，看代码里面的问题。如下图所示： Find Bugs的意思是说代码里面把SimpleDateFormat声明为静态属性，但是SimpleDateFormat是线程不安全的。在多线程使用的时候，可能就会有意想不到的问题。所以就找到个问题啦。根据提示进行修改，如下： 在上图中看到代码里有很多黄色提示，强迫症的人看着很不爽，那怎么把代码里面这些黄色的提示给关掉呢？ 点这个 ** × ** 就以啦，代码就恢复成原来的样子啦。 常见的错误信息 Bad practice 代码中的一些坏习惯 Class names should start with an upper case letter 主要包括类名的命名，以大写字母开头。 Method names should start with a lower case letter 方法名以小写字母开头。 Field names should start with a lower case letter 字段名以小写字母开头。 equals()method does not check for null argument equals()方法应该检查非空。 Class defines equals() and uses Object.hashCode() 一个类覆写了equals方法，没有覆写hashCode方法，使用了Object对象的hashCode方法。 Method ignores exceptional return value 方法忽略返回值的异常信息。 Equals method should not assume anything about the type of its argument equals(Object o)方法不能对参数o的类型做任何的假设。比较此对象与指定的对象。当且仅当该参数不为 null，并且是表示与此对象相同的类型的对象时，结果才为 true。 Comparison of String objects using == or != 用==或者！=去比较String类型的对象。 Method might ignore exception 方法可能忽略异常。 Method invokes System.exit() 在方法中调用System.exit(…)语句，考虑用RuntimeException来代替。 Method ignores result of InputStream.read() InputStream.read方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户读取少量字符请求的情况。 Dodgy code 糟糕的代码 Switch statement found where default case is missing Switch没有默认情况下执行的case语句。 Switch statement found where one case falls through to the next case Switch语句中一个分支执行后又执行了下一个分支。通常case后面要跟break 或者return语句来跳出。 Dead store to local variable 该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。 Write to static field from instance method 在实例方法写入静态字段。 Redundant nullcheck of value known to be non-null 方法中对不为空的值进行为空的判断。 Method uses the same code for two branches 此方法使用相同的代码，以实现两个有条件的分支。检查以确保这是不是一个编码错误。 Exception is caught when Exception is not thrown 在try/catch块中捕获异常，但是异常没有在try语句中抛出而RuntimeException又没有明确的被捕获。 Integral division result cast to double or float 整形数除法强制转换为double或者float类型。 Possible null pointer dereference due to return value of called method 方法的返回值没有进行是否为空的检查就重新赋值，这样可能会出现空指针异常。 Useless object created 对象创建了并没有用。 Unread public/protected field 没有用到的字段。 Internationalization 关于代码国际化相关方面的 Consider using Locale parameterized version of invoked method使用平台默认的编码格式对字符串进行大小写转换，这可能导致国际字符的转换不当。使用以下方式对字符进行转换 ** Performance ** 关于代码性能相关方面的 Boxing/unboxing to parse a primitive 类型转换 比如字符串转换成int 应该使用Integer.parseInt(“”) 代替Integer.valueOf(“”) Method concatenates string using + in aloop每次循环里的字符串+连接，都会新产生一个string对象，在java中，新建一个对象的代价是很昂贵的，特别是在循环语句中，效率较低解决办法：使用StringBuffer或者StringBuilder重用对象。 Private method is never called 私有方法没有被调用 Explicit garbage collection;extremely dubious except in benchmarking code在代码中显式的调用垃圾回收命名，这样做并不能起作用。在过去，有人在关闭操作或者finalize方法中调用垃圾回收方法导致了很多的性能浪费。这样大规模回收对象时会造成处理器运行缓慢。 Unread field:should this field be static? 没有用到的static 字段 should be a static inner class 此内部类应该使用static修饰 ** Experimental ** Method may fail to clean up stream or resource on checked exception这种方法可能无法清除（关闭，处置）一个流，数据库对象，或其他资源需要一个明确的清理行动解决方法：流的关闭都写在finally里面 Malicious code vulnerability 关于恶意破坏代码相关方面的 May expose internal representation by incorporating reference to mutable object此代码把外部可变对象引用存储到对象的内部表示。如果实例受到不信任的代码的访问和没有检查的变化危及对象和重要属性的安全。存储一个对象的副本，在很多情况下是更好的办法。 Field isn’t final but should be 此字段前应该加final Field isn’t final and can’t be protected from malicious code 此字段前应该加final Field should be package protected一个静态字段是可以被恶意代码或其他的包访问修改。可以把这种类型的字段声明为final类型的以防止这种错误。 Multithreaded correctness 关于多线程代码正确性相关方面的 Static DateFormat DateFormat 在多线程中本身就是不安全的，如果在线程范围中共享一个DateFormat的实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。 Call to static DateFormat DateFormats多线程使用本事就是不安全的,改进方法：需要创建多实例或线程同步 Correctness 关于代码正确性相关方面的 Nullcheck of value previously dereferenced 此代码之前废弃null值检查。解决办法 进行null检查 Possible null pointer dereference 可能为null Null pointer dereference 对象赋为null值后 没有被重新赋值 Possible null pointer dereference in method on exception path 在异常null值处理分支调用的方法上，可能存在对象去除引用操作 value is null and guaranteed to be dereferenced on exception path exception分支上，存在引用一个null对象的方法，引发空指针异常。 Self comparison of value with itself 方法中对一个局部变量自身进行比较运算，并可说明错误或逻辑错误。请确保您是比较正确的事情。 An apparent infinite recursive loop 明显的无限迭代循环,将导致堆栈溢出.]]></content>
      <categories>
        <category>IDEA</category>
        <category>插件</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~cherry-pick、revert、reset介绍]]></title>
    <url>%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~cherry-pick%E3%80%81revert%E3%80%81reset%E4%BB%8B%E7%BB%8D.html</url>
    <content type="text"><![CDATA[** gti checkout – filename **git checkout – filename 可以把工作区的某个文件的修改撤回到上一次add或者commit的状态，不过filename不能省略.可以使用 git checkout – 不加文件名来查看当前工作区修改了哪些文件，这个只是针对工作区的问题； ** git reset head filename **git reset HEAD filename 可以把add到缓存区的文件回退到工作区，也就是把add filename这个过程给回退了，这并不会修改文件的内容，只是把缓存区的某个文件变成和HEAD这个当前版本相同，也就是说如果你多次add，这会回退到第一次add的过程，和上面的操作一样，也可以不带上文件名来查看哪些文件被添加到了缓存区； ** git reset –hard head^ **git reset –hard HEAD~【1，2，3，4，5…】这个是大家熟悉的本地版本的回退 ** 某分支上的修改迁移到另一分支 **比如我们在分支a上开发新功能，此时有个紧急bug需要修改，然后切换到了分支b。bug修复完之后忘了切回之前的分支a，而是在分支b上面继续编写本应该是分支a的内容，这样b分支存在了一部分a分支的代码，这个时候需要把这段代码迁移到a分支上，两个思路： 1）如果还没有在b分支上commit的话(add的话没影响，在迁移后，就不会再当前分支的缓存中)。直接切到a分支，此时会提示有没有被commit的代码，切到a分支后，就可以commit这段没有被commit的代码，也就是在b分支上编写的代码正确的被迁移到了a分支。 2）如果已经commit了，可以这么来：git log找到你commit的分支号，然后直接切换到a分支，执行git cherry-pick commit-id，这个commit-id就是那个b分支错误commit的id，这个命令就是把这个commit的修改拿到当前分支来，很简单粗暴而有效。再切换到b分支，使用git revert commit-id把这个错误的分支号移除。 ** revert reset cherry-pick **git revert当我们的某个分支中有了很多版本之后，形成了一条版本链，如果想去除这个线路中的某一版本，但是保留版本链中的其他所有修改，生成一个新的版本链，版本链中的HEAD就是revert最新生成的版本。所以revert是会生成新版本的指令。可以这么想，链就像一个链条，是一环扣一环的，其中的一环就是一个版本，现在想去这个链条中的某一环（某个版本），执行git revert HEAD~2，这个HEAD2就是这个要删除的版本（链条中的一环），就会把这个环解开剔除，把和这个剔除的环（版本）相邻的环连在一起，形成了一个新的链条（少了一环），然后在链条的最后面添加一个新的没有任何修改的环（revert HEAD2 这个新的commit版本）整个过程就像剔除了中间某一个版本，最后加上了一个没有任何修改的新的版本。需要注意的是，不要随意删除中间的版本，因为可能会存在依赖，最好是revert最新的版本，风险会小很多。 git resetgit reset [--hard|soft|mixed|merge|keep] [&lt;commit&gt;或HEAD]是比较常用的指令，其中比较重要的是mode，也就是 –hard、–soft、–mixed。。。比较常见的是–hard和–soft； –hard是指完全重设，会把回退到某版本之后的修改全部删除， –soft这是个回退解体，让版本库回退到某个版本，这个版本之后的修改全部存在缓存区，这个时候在commit的话，又会把会退的部分重新加载到最新版本中； git cherry-pickgit cherry-pick &lt;commit id&gt;用于把另一个本地分支的commit修改应用到当前分支，也是解决之前遇到问题的关键，可以直接把其他的分支上的修改或者是某一个版本直接引过来，可能会存在冲突，这个时候就和正常的冲突一样的解决就好了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建GitHub博客(持续更新)]]></title>
    <url>%2FHexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0).html</url>
    <content type="text"><![CDATA[入门Hexo由于平时自己喜欢看一些技术类文章整理成Word笔记，总感觉这种方式太low，想自己搭建属于自己的博客，在网上查阅了一下，发现Hexo在GitHub或者是码云上搭建博客非常给力。然后自己也搭建了博客，这篇文章就记录了搭建的过程及一些优化。 什么是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown （或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。大家进入 Hexo官网 进行查看。 安装Hexo安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git cnpm 如果npm运行出错就安装cnpm国内镜像所有必备的应用程序安装完成后，即可使用 npm或者cnpm 安装 Hexo。打开Git Bash here，输入： 123$ npm install -g hexo-cli 或者 $ cnpm install -g hexo-cli 检查是否安装Hexo完成,查询是否成功，显示hexo-cli 版本就说明成功了 1$ hexo -V 建站安装一切所需的程序后，就可以开始建站了，就是创建我们的博客,大家也可以进入 建站官网 查看。新建一个文件夹，来管理我们的博客项目，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 运行命令123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ cnpm install 注：&lt;folder&gt;是表示建站的博客项目名打开Git Bash here，输入： 1$ hexo init githubBlog 进入创建的博客项目下，安装 12$ cd githubBlog$ cnpm install 安装之后，整个博客项目目录如下： 访问URL123$ hexo server 或者$ hexo s 访问URL：http://localhost:4000，效果如下图： 到这里已经通过Hexo初步创建博客了，下面再来了解一下如何将我们的博客托管到GitHub服务器上。 托管到GitHubGitHub创建repositories进入GitHub官网中浏览器输入 https://github.com/ ,如果还没有账号就创建一个账号就好了。登录自己的账号。直接new repositories 或者进入You repositories 在new repositories。 进入到创建 repositories 页面后,一定要注意，将新建的repository的名字为: You account name.github.io。其他默认就好了。 配置GitHub的Repository创建好后，在回到本地的Hexo的githubBlog项目中，找到在项目的根目录下_config.yml找到 deploy标签在该文件下面添加 注：repository: https://github.com/whb1990/whb1990.github.io 是自己刚刚创建You account name.github.io 的repository，在Clone with HTTPS里面，复制粘贴就好了，冒号后面记得空格。branch 后面是master就好了。 1234deploy: #部署 type: git repository: https://github.com/whb1990/whb1990.github.io.git branch: master 在_config.yml找到url进行修改为： 1url: http://whb1990.github.io #博客网址 部署到这里就差不到了，接下来需要执行一些命令，将博客部署到GitHub上去。打开Git Bash Here进入githubBlog 根目录下，首先需要安装一下 hexo-deployer-git 不然可能出现错误无法部署成功。 1$ cnpm install hexo-deployer-git --save 然后在执行以下命令: 123$ hexo clean$ hexo generate$ hexo deploy 或者简写 123$ hexo clean$ hexo g$ hexo d 部署成功如下显示: 测试我们进行访问 https://whb1990.github.io/ 和 http://localhost:4000/ 一样的页面说明是已经成功。 站点文件配置在根githubBlog目录下_config.yml文件，我们暂且称为站点配置文件，以便与后面讲到的主题配置文件(Next主题下的_config.yml文件)进行区分。 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 目录 参数 描述 source_dir 资源文件夹，这个文件夹用来存放内容。 public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 tag_dir 标签文件夹 archive_dir 归档文件夹 category_dir 分类文件夹 code_dir Include code 文件夹 i18n_dir 国际化（i18n）文件夹 skip_render 跳过指定文件的渲染，您可使用 glob 来配置路径 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 分类&amp;标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 写作创建文章1$ hexo new [layout] &lt;title&gt; 如：创建hello-world 1$ hexo new hello-world 如果不添加title，默认就是标题title: hello-world。这里注意一下，如果创建带有中文的路径名称时，生成静态页面hexo g可能会报错。 12warning: LF will be replaced by CRLF in xxxxThe file will have its original line endings in your working directory. 这是由于原因是路径中存在 / 的符号转义问题 如：创建文章时命名为中文，一般都出现这个小问题。 解决 在命令行中输入: 1$ git config --global core.autocrlf false 然后重新生成文件部署就好了。 编辑文章创建的文章在source/_posts目录下，打开文件进行编辑，完全支持Markdown语法。 Next主题在 Hexo主题官网 中有许多主题，大家喜欢什么就进行部署和编辑就好了，大致的思路都是差不多的。我选择的 Next主题 ，网上很多也是用的这个主题。 安装在githubBlog根目录下，执行以下命令： 1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 上面的命令是clone最新版本的主题，也可以使用下面的命令clone指定版本的主题 1$ git clone --branch v7.1.1 https://github.com/theme-next/hexo-theme-next themes/next 安装完成之后，在themes下就会有next目录 切换主题在项目根目录下打开_config.yml文件将theme设置为next即可：部署之后查看效果如下，有点丑： 主题配置一般配置都在theme/next/-config.yml文件下配置。 修改整体布局 在theme/next/-config.yml找到menu看看自己博客所需的分类 123456789menu: home: / || home #首页 about: /about/ || user #关于 tags: /tags/ || tags #标签 categories: /categories/ || th #目录 archives: /archives/ || archive #归档 #schedule: /schedule/ || calendar #日程 sitemap: /sitemap.xml || sitemap #站点地图 commonweal: /404/ || heartbeat #公益404 在menu_settings如果设置icon: false则无图标，badges: true则标签都会显示数字 123menu_settings: icons: true badges: false 注:这里需要创建about页面，很简单，同理创建标签tags、归档archives页面一样的方式，所需要创建的名称要与menu相对应，举例说明如下。 12$ hexo new page about #看看menu上还有什么标签没创建就行创建$ hexo new page tags #创建标签等 创建完成之后在自己项目查找，如我的是githubBlog/source/目录下查看新创建好的相关标签页面，里面包含各自的index.md文件，大家可以自行编辑了。 Schemes方案设置 12345# Schemes#scheme: Muse #这是 Nex默认版本，黑白主调，大量留白 #scheme: Mist #Muse 的紧凑版本，整洁有序的单栏外观#scheme: Pisces #双栏 Scheme，小家碧玉似的清新scheme: Gemini #双子座，也是双栏形式，和Pisces类似 自己喜欢什么风格自行选择。 social设置 使用方式: Key: permalink || icon Key表示标签显示，permalink表示URI连接，icon表示图标，自己添加所要显示的， 12345678910111213141516171819social: GitHub: https://github.com/whb1990 || github E-Mail: mailto:whbsurpass@163.com || envelope QQ: 270028806 || qq 微信: yan521bo ||weixin #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skypesocial_icons: #设置图标是否显示这里 enable: true #表示开启 icons_only: false #只显示图片 transition: false 注：图标库来源 [https://fontawesome.com/icons?from=io] ，在scheme: Pisces该效果不显示。 avatar头像设置 12345678910111213avatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.jpg # If true, the avatar would be dispalyed in circle. #圆形框 rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. #头像是否旋转 rotated: true toc边栏中的目录设置 12345678910toc: #边栏设置 enable: true #是否启用边栏 # Automatically add list number to toc. number: true #自动将列表编号添加到toc # If true, all words will placed on next lines if header width longer then sidebar width. wrap: false #true时是当标题宽度很长时，自动换到下一行 # If true, all level of TOC in a post will be displayed, rather than the activated part of it. expand_all: false #折叠 # Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` in Front-matter. max_depth: 6 #最大深度 Creative Commons 4.0国际许可设置 12# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zerocreative_commons: by-nc-sa sidebar侧边栏配置这里选择默认吧 1234567891011121314151617181920212223sidebar: # Sidebar Position, available values: left | right (only for Pisces | Gemini). position: left #position: right # Manual define the sidebar width. If commented, will be default for: # Muse | Mist: 320 # Pisces | Gemini: 240 width: 240 # Sidebar Display, available values (only for Muse | Mist): # - post expand on posts automatically. Default. # - always expand for all pages automatically. # - hide expand only when click on the sidebar toggle icon. # - remove totally remove sidebar including sidebar toggle. display: post # Sidebar offset from top menubar in pixels (only for Pisces | Gemini). offset: 12 # Enable sidebar on narrow view (only for Muse | Mist). onmobile: true # Click any blank part of the page to close sidebar (only for Muse | Mist). dimmer: false save_scroll配置 12# Automatically saving scroll position on each post / page in cookies.save_scroll: false #是否在Cookie中自动保存每个帖子/页面上的滚动位置。 excerpt_description 12# Automatically excerpt description in homepage as preamble text.excerpt_description: false #是否自动摘录主页中的描述作为前导文本。 auto_excerpt配置 123auto_excerpt: enable: true #是否自动摘录。不推荐 length: 150 #这里是说文章开头第一个字到第150个字就显示"阅读全文" codeblock代码块配置 1234567891011121314codeblock: # Code Highlight theme # Available values: normal | night | night eighties | night blue | night bright # See: https://github.com/chriskempson/tomorrow-theme highlight_theme: normal #代码突出显示主题 # Manual define the border radius in codeblock, leave it blank for the default value: 1 border_radius: 1 # Add copy button on codeblock copy_button: enable: true # Show text copy result. show_result: true # Available values: default | flat | mac style: flat wechat_subscriber微信配置 1234wechat_subscriber: enabled: true #是否启动微信订阅 qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg description: ex. subscribe to my blog by scanning my public wechat account footer 底部设置 12345678910111213141516171819202122232425262728footer: # Specify the date when the site was setup. If not defined, current year will be used. since: 2019 #建站开始时间 # Icon between year and copyright info. icon: # Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: heart #设置图标，想修改图标从https://fontawesome.com/v4.7.0/icons获取 # If you want to animate the icon, set it to true. animated: true # Change the color of icon, using Hex Code. color: "#ff0000" # If not defined, `author` from Hexo `_config.yml` will be used. copyright: ©2019 by 王洪博 #版权 powered: # Hexo link (Powered by Hexo). enable: true ##是否显示Hexo link # Version info of Hexo after Hexo link (vX.X.X). version: true #是否显示Hexo版本 theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: true #是否显示NexT主题 # Version info of NexT after scheme info (vX.X.X). version: true #是否显示NexT版本 favicon标签页图标 12345favicon: small: /images/favicon-16x16-next.png #小图标 默认的NexT medium: /images/favicon-32x32-next.png #中图标 默认NexT apple_touch_icon: /images/apple-touch-icon-next.png #苹果触摸图标 safari_pinned_tab: /images/logo.svg #safari固定标签 Math Equations Render Support 数学方程式渲染支持 12345678math: enable: true #默认为false per_page: true engine: mathjax #两种方式 mathjax / katex mathjax: cdn: //cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML #默认 这里大家根据自己需求 katex: cdn: //cdn.jsdelivr.net/npm/katex@0.7.1/dist/katex.min.css #默认 16 .Han Support 支持汉字 设置汉字支持，按照以下步骤： 打开Git Bash Here,进入theme/next目录下 1$ cd themes/next 获取该汉字支持Git module,执行命令以下命令获得 1$ git clone https://github.com/theme-next/theme-next-han source/lib/Han 设置汉字支持 1han: true 更新update 12$ cd themes/next/source/lib/Han$ git pull font字体设置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647font: # Use custom fonts families or not. # Depended options: `external` and `family`. enable: true #默认false 如果要进行字体修改那么设置为true # Uri of fonts host, e.g. //fonts.googleapis.com (Default). host: //fonts.lug.ustc.edu.cn # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: x.x`. Use `em` as unit. Default: 1 (16px) # Global font settings used for all elements inside &lt;body&gt;. global: external: true family: Lato size: # Font settings for site title (.site-title). title: external: true family: size: # Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;). headings: external: true family: Roboto Slab size: # Font settings for posts (.post-body). posts: external: true family: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: Roboto Mono # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: size: 添加图标链接到GitHub一般在右上角或者左上角，如配置右上角Fork_me_on_GitHub,按以下步骤进行 打开 Fork_me_on_GitHub 链接，里面有许多样式，选择自己喜欢的样式，将其复制下来。 打开自己博客项目中的themes/next/layout/_layout.swig文件，搜索&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; 将复制的内容粘贴到&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面，如下： 配置右上角的Fork_me_on_GitHub: 修改文章底部标签在博客项目中找到/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;，将 #号 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 原先#号的样式 修改为图标的样式 设置背景动画样式NexT里面有几种动画背景样式canvas_nest、three_waves、canvas_lines、canvas_sphere等 canvas_nest如下图所示: 按照以下步骤完成 打开Git Bash Here进入自己文件夹下/themes/next文件夹下 1$ cd /themes/next 下载安装 canvas_nest module 执行 1$ git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest 在 /themes/next/source/lib查看会看到canvas_nest文件夹 在/themes/next/_config.yml设置 1canvas_nest: true three_waves如图所示 three_waves 设置步骤，和 canvas_nest 步骤是一样的。下载完成后，在/themes/next/_config.yml设置 12345three_waves: true#ORcanvas_lines: true#ORcanvas_sphere: true canvas_ribbon canvas_ribbon只适合 scheme Pisces 这里不测试了，大家可以进入 canvas_ribbon 安装。 在网站底部添加访问量 进入 \themes\next\layout\_partials\footer.swig 文件顶部第一行添加 1&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 搜索 1&#123;% if theme.footer.powered.enable %&#125; 在这个位置上添加以下代码: 12345&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 注：这里的id值可以选择两种 12busuanzi_value_site_uv #表示用户连续点击n篇文章，只记录1次访客数busuanzi_value_site_pv #表示用户连续点击n篇文章，记录+n次访问量 这里对应的是2上的id值 给每篇文章添加类别和标签在创建的文章都在source/_post目录下找到，每篇文章添加tags、categories 添加进度条添加进度条的话在手机浏览的时候一般情况都有自带的进度条了，例如微信浏览、浏览器浏览等等，这样就出现重复的进度条了，这里看个人是否添加。但是在电脑浏览器浏览却是不错的。本例设置的如下pace-theme-center-circle显示 按照以下步骤进行或者进入这里 Progress配置 查看如何配置 打开Git Bash Here进入自己文件夹下/themes/next文件夹下 1$ cd /themes/next 下载安装 Progress module 执行 1$ git clone https://github.com/theme-next/theme-next-pace source/lib/pace 在 /themes/next/source/lib查看会看到pace文件夹 在/themes/next/_config.yml设置 123456pace: enable: true # Themes list: # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal theme: minimal #任选一种 添加站内搜索由于可能需要快速查找相关文章，那么就需要添加站内搜索。 按以下步骤进行或者进入 NexT配置站内搜索 文档查看如何配置 安装站内搜索插件 123$ npm install hexo-generator-searchdb --save或者$ cnpm install hexo-generator-searchdb --save 在根目录下的_config.yml添加 123456#表示站内搜索search: path: search.xml field: post format: html limit: 10000 在themes/next/_config.yml文件中搜索local_search,进行设置 12345local_search: enable: true #设置为true trigger: auto # auto / manual，auto 自动搜索、manual：按回车[enter ]键手动搜索 top_n_per_article: 1 unescape: true 添加打赏NexT主要提供三种打赏方式分别是微信、支付宝、比特币在themes/next搜索Reward： 123456reward_settings: # If true, reward would be displayed in every article by default. # You can show or hide reward in a specific article throuth `reward: true | false` in Front-matter. enable: true #启用打赏 animation: true #启用动画效果 comment: 捐赠作者请点击下方的“打赏”按钮 #内容 友情链接12345678# Blog rolls #友情链接links_icon: linklinks_title: 友情链接links_layout: block#links_layout: inlinelinks: Eirunye: http://eirunye.github.io/ #所需添加的友情链接 Title是表示友情链接的博客名称或者随意你取，后面是链接，冒号后面记得空格 程晓明: https://www.infoq.cn/profile/1278512 添加阅读统计给每篇文章进行添加阅读统计，效果如下图: 进入 leancloud 创建应用 进入设置页面获取应用Key 将App ID、App Key 配置到next/_config.yml中leancloud_visitors 1234567leancloud_visitors: enable: true 设置为true 默认为false app_id: #你的App ID，注意冒号后面空格 app_key: #你的App Key，注意冒号后面空格 Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security #设置依赖 security: true #如果您不关心lc计数器中的安全性并且只想直接使用它（没有hexo-leancloud-counter-security插件），请将`security`设置为`false`。 betterPerformance: true#更好的性能 在leancloud存储的位置创建Class,必须命名为Counter 查看后台统计数据 添加评论我的博客选择的是Valine。 在next/_config.yml搜索Valine,进入 Valine 官网，也是 leancloud 官网，进入leancloud 控制台,没有账号密码就进行设置。 创建应用参考上面 添加阅读统计 的创建应用。 进入设置页面获取应用key参考上面 添加阅读统计 的进入设置页面获取应用key。 在next/_config.yml进行配置。 1234567891011valine: enable: true # 设置为true，默认为false appid: # 将应用key的App ID设置在这里 appkey: # 将应用key的App Key设置在这里 notify: true# 邮箱通知 , https://github.com/xCss/Valine/wiki，默认为false verify: true# 验证码 默认为false placeholder: Just go go ^_^ # 初始化评论显示，根据自己修改，这里默认， avatar: wavatar # 头像风格，默认为mm，可进入网址：https://valine.js.org/visitor.html查看头像设置，这里有许多头像风格，进行设置 guest_info: nick,mail,link # 自定义评论标题 pageSize: 10 # 分页大小，10页就自动分页 visitor: true # 是否允许游客评论 ，进入官网查看设置：https://valine.js.org/visitor.html 显示结果 这样就完成了valine评论的配置了，接下来就可以进行评论了，我们还可以在后台查看评论信息。 在后台查看评论数据 在valine后台，存储位置中的数据里面创建Class，名称必须为命名为Comment参考上面 添加阅读统计 的创建Class。 注：选择valine评论系统是因为支持国内网络，不需要连接外网（翻墙）就可以进行显示评论系统，而且很好管理，页面简单。 添加RSS效果如下图： 实现方法： 切换到你的blog根目录下，然后安装 Hexo 插件：(这个插件会放在node_modules这个文件夹里) 1$ cnpm install --save hexo-generator-feed 然后在根目录的站点配置文件_config.yml下进行配置 12## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed # RSS订阅 然后打开next主题文件夹里面的_config.yml,在里面配置为如下： 1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 点击出现桃心效果效果如下图： 实现方法 打开浏览器，输入： http://7u2ss1.com1.z0.glb.clouddn.com/love.js 然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。 将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 修改文章内链接文本样式效果如下图： 实现方法 修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 在每篇文章末尾统一添加“本文结束”标记效果如下图： 实现方法 在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml),在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 修改``代码块自定义样式效果如下： 实现方法打开\themes\next\source\css\_custom\custom.styl,向里面加入：(颜色可以自己定义) 123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 主页文章添加阴影效果效果如下图： 实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 添加热度效果如下图： 实现方法 next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig,在画红线的区域添加℃： 然后打开，/themes/next/languages/zh-Hans.yml,将画红框的改为热度就可以了: 网站底部字数统计效果如下图： 实现方法 切换到根目录下，然后运行如下代码 1$ cnpm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上： 1234&lt;div class="theme-info"&gt; &lt;div class="powered-by"&gt;&lt;/div&gt; &lt;span class="post-count"&gt;站点总字数&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。 在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为 1skip_render: README.md 保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。 实现统计功能效果如下图： 实现方法 在根目录下安装 hexo-wordcount,运行： 1$ cnpm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true #字数统计 min2read: true #阅读时长预计 totalcount: true #总字数统计 separated_meta: true 添加顶部加载条效果如下图： 实现方法 打开/themes/next/layout/_partials/head.swig文件，添加红框上的代码 12&lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;&lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 在文章底部增加版权信息效果如下图： 实现方法 在目录 next/layout/_macro/下添加 my-copyright.swig： 1234567891011121314151617181920212223242526272829303132&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;"&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125; 的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;" title="&#123;&#123; page.title &#125;&#125;"&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125;" aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;!-- &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; --&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard('.fa-clipboard'); $(".fa-clipboard").click(function()&#123; clipboard.on('success', function()&#123; swal(&#123; title: "", text: '复制成功', icon: "success", showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'wechat-subscriber.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 如下图： 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import "my-post-copyright" 保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 123456789101112---title: Java并发-ReentrantLockcopyright: truedate: 2019-08-26 14:59:12updated:tags: - Java - J.U.Ccategories: - Java - J.U.C--- 如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加： 1copyright: true 这样每次hexo new &quot;你的内容&quot;之后，生成的md文件会自动把copyright:true加到里面去。 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,隐藏或删除如下代码，如下图： 修改打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下： 123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 文章加密访问效果如下图： 实现方法 打开themes/next/layout/_partials/head/head.swig文件,在以下位置插入这样一段代码： 12345678910&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误！'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似这样： 添加鼠标点击显示字体效果效果如下图： 实现方法 在 /themes/next/source/js 下新建文件 click_show_text.js，在 click_show_text.js 文件中添加以下代码： 123456789101112131415161718192021222324252627282930313233var a_idx = 0;jQuery(document).ready(function($) &#123; $("body").click(function(e) &#123; var a = new Array ("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善"); var $i = $("&lt;span/&gt;").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css(&#123; "z-index": 5, "top": y - 20, "left": x, "position": "absolute", "font-weight": "bold", "color": "#FF0000" &#125;); $("body").append($i); $i.animate(&#123; "top": y - 180, "opacity": 0 &#125;, 3000, function() &#123; $i.remove(); &#125;); &#125;); setTimeout('delay()', 2000);&#125;);function delay() &#123; $(".buryit").removeAttr("onclick");&#125; 其中的社会主义核心价值观可以根据你自己的创意替换为其他文字，然后在 \themes\next\layout\_layout.swing 文件末尾添加以下代码： 12&lt;!--单击显示文字--&gt;&lt;script type="text/javascript" src="/js/click_show_text.js"&gt;&lt;/script&gt; 添加鼠标点击烟花爆炸效果效果如下图： 实现方法 在 \themes\next\source\js 目录下新建一个 fireworks.js 的文件，里面写入以下代码： 1"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;; 然后在 \themes\next\layout\layout.swing 文件中写入以下代码： 123&lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/fireworks.js"&gt;&lt;/script&gt; 自定义鼠标指针样式在 \themes\next\source\css\_custom\custom.styl 文件 body 样式里写入如下代码： 12345/*自定义鼠标样式*/body &#123; cursor: url("/images/mouse.cur"),auto; background-color: @theme_background;&#125; 鼠标指针可以用 Axialis CursorWorkshop 这个软件自己制作，不同主题具体放的文件有所不同，确保在博客主体 body 的 CSS 文件中即可，其中的鼠标指针链接可替换成自己的，首先尝试加载mouse.cur ，如果该文件不存在或由于其他原因无效，那么 auto 会被使用，也就是自动默认效果，图片格式为.ico、.ani、.cur，建议使用.cur，如果使用.ani或者其他格式无效，原因是浏览器兼容问题。 添加彩色滚动变换字体在你想要添加彩色滚动变换字体的地方写入以下代码即可，其中文字可自行更改： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id="binft"&gt;&lt;/div&gt; &lt;script&gt; var binft = function (r) &#123; function t() &#123; return b[Math.floor(Math.random() * b.length)] &#125; function e() &#123; return String.fromCharCode(94 * Math.random() + 33) &#125; function n(r) &#123; for (var n = document.createDocumentFragment(), i = 0; r &gt; i; i++) &#123; var l = document.createElement("span"); l.textContent = e(), l.style.color = t(), n.appendChild(l) &#125; return n &#125; function i() &#123; var t = o[c.skillI]; c.step ? c.step-- : (c.step = g, c.prefixP &lt; l.length ? (c.prefixP &gt;= 0 &amp;&amp; (c.text += l[c.prefixP]), c.prefixP++) : "forward" === c.direction ? c.skillP &lt; t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = "backward", c.delay = a) : c.skillP &gt; 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % o.length, c.direction = "forward")), r.textContent = c.text, r.appendChild(n(c.prefixP &lt; l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d) &#125; var l = "", o = ["青青陵上柏，磊磊涧中石。", "人生天地间，忽如远行客。","斗酒相娱乐，聊厚不为薄。", "驱车策驽马，游戏宛与洛。","洛中何郁郁，冠带自相索。","长衢罗夹巷，王侯多第宅。","两宫遥相望，双阙百余尺。","极宴娱心意，戚戚何所迫？"].map(function (r) &#123; return r + "" &#125;), a = 2, g = 1, s = 5, d = 75, b = ["rgb(110,64,170)", "rgb(150,61,179)", "rgb(191,60,175)", "rgb(228,65,157)", "rgb(254,75,131)", "rgb(255,94,99)", "rgb(255,120,71)", "rgb(251,150,51)", "rgb(226,183,47)", "rgb(198,214,60)", "rgb(175,240,91)", "rgb(127,246,88)", "rgb(82,246,103)", "rgb(48,239,130)", "rgb(29,223,163)", "rgb(26,199,194)", "rgb(35,171,216)", "rgb(54,140,225)", "rgb(76,110,219)", "rgb(96,84,200)"], c = &#123; text: "", prefixP: -s, skillI: 0, skillP: 0, direction: "forward", delay: a, step: g &#125;; i() &#125;; binft(document.getElementById('binft')); &lt;/script&gt; 我是放在了侧边栏头像的下边，描述的位置\themes\next\layout\_macro\sidebar.swing： 浏览器网页标题恶搞效果如下图： 实现方法 在目录 \themes\next\source\js 下新建一个 FunnyTitle.js 文件，在里面填写如下代码： 1234567891011121314151617&lt;!--浏览器搞笑标题--&gt; var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel="icon"]').attr('href', "/img/trhx2.png"); document.title = 'ヽ(●-`Д´-)ノ你丑你就走！'; clearTimeout(titleTime); &#125; else &#123; $('[rel="icon"]').attr('href', "/img/trhx2.png"); document.title = 'ヾ(Ő∀Ő3)ノ你帅就回来！' + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125; &#125;); 然后在 \themes\next\layout\layout.swing 文件中写入以下代码： 12&lt;!--浏览器搞笑标题--&gt;&lt;script type="text/javascript" src="\js\FunnyTitle.js"&gt;&lt;/script&gt; 再次部署博客后就可以看见标题搞笑的效果了。 添加网站雪花飘落效果效果如下图： 实现方法 在 \themes\next\source\js 目录下新建一个 snow.js 文件，粘贴以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142/*样式一*/(function($)&#123; $.fn.snow = function(options)&#123; var $flake = $('&lt;div id="snowbox" /&gt;').css(&#123;'position': 'absolute','z-index':'9999', 'top': '-50px'&#125;).html('&amp;#10052;'), documentHeight = $(document).height(), documentWidth = $(document).width(), defaults = &#123; minSize : 10, maxSize : 20, newOn : 1000, flakeColor : "#AFDAEF" /* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */ &#125;, options = $.extend(&#123;&#125;, defaults, options); var interval= setInterval( function()&#123; var startPositionLeft = Math.random() * documentWidth - 100, startOpacity = 0.5 + Math.random(), sizeFlake = options.minSize + Math.random() * options.maxSize, endPositionTop = documentHeight - 200, endPositionLeft = startPositionLeft - 500 + Math.random() * 500, durationFall = documentHeight * 10 + Math.random() * 5000; $flake.clone().appendTo('body').css(&#123; left: startPositionLeft, opacity: startOpacity, 'font-size': sizeFlake, color: options.flakeColor &#125;).animate(&#123; top: endPositionTop, left: endPositionLeft, opacity: 0.2 &#125;,durationFall,'linear',function()&#123; $(this).remove() &#125;); &#125;, options.newOn); &#125;;&#125;)(jQuery);$(function()&#123; $.fn.snow(&#123; minSize: 5, /* 定义雪花最小尺寸 */ maxSize: 50,/* 定义雪花最大尺寸 */ newOn: 300 /* 定义密集程度，数字越小越密集 */ &#125;);&#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/*样式二*//* 控制下雪 */function snowFall(snow) &#123; /* 可配置属性 */ snow = snow || &#123;&#125;; this.maxFlake = snow.maxFlake || 200; /* 最多片数 */ this.flakeSize = snow.flakeSize || 10; /* 雪花形状 */ this.fallSpeed = snow.fallSpeed || 1; /* 坠落速度 */&#125;/* 兼容写法 */requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) &#123; setTimeout(callback, 1000 / 60); &#125;;cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame;/* 开始下雪 */snowFall.prototype.start = function()&#123; /* 创建画布 */ snowCanvas.apply(this); /* 创建雪花形状 */ createFlakes.apply(this); /* 画雪 */ drawSnow.apply(this)&#125;/* 创建画布 */function snowCanvas() &#123; /* 添加Dom结点 */ var snowcanvas = document.createElement("canvas"); snowcanvas.id = "snowfall"; snowcanvas.width = window.innerWidth; snowcanvas.height = document.body.clientHeight; snowcanvas.setAttribute("style", "position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;"); document.getElementsByTagName("body")[0].appendChild(snowcanvas); this.canvas = snowcanvas; this.ctx = snowcanvas.getContext("2d"); /* 窗口大小改变的处理 */ window.onresize = function() &#123; snowcanvas.width = window.innerWidth; /* snowcanvas.height = window.innerHeight */ &#125;&#125;/* 雪运动对象 */function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) &#123; this.x = Math.floor(Math.random() * canvasWidth); /* x坐标 */ this.y = Math.floor(Math.random() * canvasHeight); /* y坐标 */ this.size = Math.random() * flakeSize + 2; /* 形状 */ this.maxSize = flakeSize; /* 最大形状 */ this.speed = Math.random() * 1 + fallSpeed; /* 坠落速度 */ this.fallSpeed = fallSpeed; /* 坠落速度 */ this.velY = this.speed; /* Y方向速度 */ this.velX = 0; /* X方向速度 */ this.stepSize = Math.random() / 30; /* 步长 */ this.step = 0 /* 步数 */&#125;flakeMove.prototype.update = function() &#123; var x = this.x, y = this.y; /* 左右摆动(余弦) */ this.velX *= 0.98; if (this.velY &lt;= this.speed) &#123; this.velY = this.speed &#125; this.velX += Math.cos(this.step += .05) * this.stepSize; this.y += this.velY; this.x += this.velX; /* 飞出边界的处理 */ if (this.x &gt;= canvas.width || this.x &lt;= 0 || this.y &gt;= canvas.height || this.y &lt;= 0) &#123; this.reset(canvas.width, canvas.height) &#125;&#125;;/* 飞出边界-放置最顶端继续坠落 */flakeMove.prototype.reset = function(width, height) &#123; this.x = Math.floor(Math.random() * width); this.y = 0; this.size = Math.random() * this.maxSize + 2; this.speed = Math.random() * 1 + this.fallSpeed; this.velY = this.speed; this.velX = 0;&#125;;// 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render = function(ctx) &#123; var snowFlake = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size); snowFlake.addColorStop(0, "rgba(255, 255, 255, 0.9)"); /* 此处是雪花颜色，默认是白色 */ snowFlake.addColorStop(.5, "rgba(255, 255, 255, 0.5)"); /* 若要改为其他颜色，请自行查 */ snowFlake.addColorStop(1, "rgba(255, 255, 255, 0)"); /* 找16进制的RGB 颜色代码。 */ ctx.save(); ctx.fillStyle = snowFlake; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore();&#125;;/* 创建雪花-定义形状 */function createFlakes() &#123; var maxFlake = this.maxFlake, flakes = this.flakes = [], canvas = this.canvas; for (var i = 0; i &lt; maxFlake; i++) &#123; flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed)) &#125;&#125;/* 画雪 */function drawSnow() &#123; var maxFlake = this.maxFlake, flakes = this.flakes; ctx = this.ctx, canvas = this.canvas, that = this; /* 清空雪花 */ ctx.clearRect(0, 0, canvas.width, canvas.height); for (var e = 0; e &lt; maxFlake; e++) &#123; flakes[e].update(); flakes[e].render(ctx); &#125; /* 一帧一帧的画 */ this.loop = requestAnimationFrame(function() &#123; drawSnow.apply(that); &#125;);&#125;/* 调用及控制方法 */var snow = new snowFall(&#123;maxFlake:60&#125;);snow.start(); 然后在 \themes\next\layout\layout.swing 文件中写入以下代码： 12&lt;!-- 雪花特效 --&gt;&lt;script type="text/javascript" src="\js\snow.js"&gt;&lt;/script&gt; 如果没效果，请确认网页是否已载入JQurey，如果没有请在下雪代码之前引入JQ即可： 12&lt;script type="text/javascript" src="http://libs.baidu.com/jquery/1.8.3/jquery.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="http://libs.baidu.com/jquery/1.8.3/jquery.min.js"&gt;&lt;/script&gt; 添加背景动态彩带效果效果如下图： 实现方法 在 \themes\next\layout\layout.swing 文件中写入以下代码： 12345&lt;!-- 样式一（鼠标点击更换样式） --&gt;&lt;script src="https://g.joyinshare.com/hc/ribbon.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;!-- 样式二（飘动的彩带） --&gt;&lt;script src="https://g.joyinshare.com/hc/piao.js" type="text/javascript"&gt;&lt;/script&gt; 添加背景代码雨特效效果如下图： 实现方法 在 \themes\next\source\js 目录下新建一个 DigitalRain.js 文件，粘贴以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657window.onload = function()&#123; //获取画布对象 var canvas = document.getElementById("canvas"); //获取画布的上下文 var context =canvas.getContext("2d"); var s = window.screen; var W = canvas.width = s.width; var H = canvas.height; //获取浏览器屏幕的宽度和高度 //var W = window.innerWidth; //var H = window.innerHeight; //设置canvas的宽度和高度 canvas.width = W; canvas.height = H; //每个文字的字体大小 var fontSize = 12; //计算列 var colunms = Math.floor(W /fontSize); //记录每列文字的y轴坐标 var drops = []; //给每一个文字初始化一个起始点的位置 for(var i=0;i&lt;colunms;i++)&#123; drops.push(0); &#125; //运动的文字 var str ="WELCOME TO WWW.ITRHX.COM"; //4:fillText(str,x,y);原理就是去更改y的坐标位置 //绘画的函数 function draw()&#123; context.fillStyle = "rgba(238,238,238,.08)";//遮盖层 context.fillRect(0,0,W,H); //给字体设置样式 context.font = "600 "+fontSize+"px Georgia"; //给字体添加颜色 context.fillStyle = ["#33B5E5", "#0099CC", "#AA66CC", "#9933CC", "#99CC00", "#669900", "#FFBB33", "#FF8800", "#FF4444", "#CC0000"][parseInt(Math.random() * 10)];//randColor();可以rgb,hsl, 标准色，十六进制颜色 //写入画布中 for(var i=0;i&lt;colunms;i++)&#123; var index = Math.floor(Math.random() * str.length); var x = i*fontSize; var y = drops[i] *fontSize; context.fillText(str[index],x,y); //如果要改变时间，肯定就是改变每次他的起点 if(y &gt;= canvas.height &amp;&amp; Math.random() &gt; 0.99)&#123; drops[i] = 0; &#125; drops[i]++; &#125; &#125;; function randColor()&#123;//随机颜色 var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); return "rgb("+r+","+g+","+b+")"; &#125; draw(); setInterval(draw,35);&#125;; 然后在 \themes\next\source\css\_custom\custom.styl 中写入样式： 12345678910canvas &#123; position: fixed; right: 0px; bottom: 0px; min-width: 100%; min-height: 100%; height: auto; width: auto; z-index: -1;&#125; 在 \themes\next\layout\layout.swing 文件中写入以下代码： 123&lt;!-- 代码雨 --&gt; &lt;canvas id="canvas" width="1440" height="900" &gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="/js/DigitalRain.js"&gt;&lt;/script&gt; 代码块复制功能效果如下图： 实现方法 下载 clipboard.js clipboard.js clipboard.min.js 推荐 保存文件clipboard.js / clipboard.min.js 到路径\themes\next\source\js\src下。 使用clipboard.js 也是在 \themes\next\source\js\src 目录下，创建clipboard-use.js，文件内容如下： 12345678910111213141516/*页面载入完成后，创建复制按钮*/!function (e, t, a) &#123; /* code */ var initCopyCode = function()&#123; var copyHtml = ''; copyHtml += '&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'; copyHtml += ' &lt;i class="fa fa-globe"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(".highlight .code pre").before(copyHtml); new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); &#125; initCopyCode(); 在\themes\next\source\css\_custom\custom.styl样式文件中添加下面代码： 123456789101112131415161718192021222324252627282930313233343536//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125; 引用 在\themes\next\layout\_layout.swig文件中，添加引用（注：在 swig 末尾或 body 结束标签（&lt;/body&gt;）之前添加）： 123&lt;!-- 代码块复制功能 --&gt; &lt;script type="text/javascript" src="/js/src/clipboard.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/clipboard-use.js"&gt;&lt;/script&gt; Hexo文章中图片点击实现全屏查看使用图片浏览放大功能fancybox插件。 切换到lib目录 1$ cd next/source/lib 下载插件 1$ git clone https://github.com/theme-next/theme-next-fancybox3 fancybox 更改主题配置文件 1fancybox: true 3D动态标签云 安装标签云hexo-tag-cloud插件 1$ cnpm install hexo-tag-cloud@^2.* --save 配置sidebar.swig文件 打开next/layout/_macro/sidebar.swig，输入： 1234567891011&#123;% if site.tags.length &gt; 1 %&#125;&lt;script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"&gt;&lt;/script&gt;&lt;div class="widget-wrap"&gt; &lt;div id="myCanvasContainer" class="widget tagcloud"&gt; &lt;canvas width="250" height="250" id="resCanvas" style="width=100%"&gt; &#123;&#123; list_tags() &#125;&#125; &lt;/canvas&gt; &lt;/div&gt;&lt;/div&gt;&#123;% endif %&#125; 根据自己的需要放在合适的位置。重新hexo s一下，就可以出现刚刚那个3d标签云了! 添加卡通人物效果如下图： 实现方法 下载 live2d 1$ cnpm install --save hexo-helper-live2d 下载模型 1$ cnpm install live2d-widget-model-z16 更多模型选择请 点击此处，各个模型的预览请 点击此处 修改站点配置文件 12345678910111213141516171819202122232425262728293031323334#添加萌宠，以下任选一个#live2d-widget-model-chitose#live2d-widget-model-epsilon2_1#live2d-widget-model-gf#live2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)#live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)#live2d-widget-model-haruto#live2d-widget-model-hibiki#live2d-widget-model-hijiki#live2d-widget-model-izumi#live2d-widget-model-koharu#live2d-widget-model-miku#live2d-widget-model-ni-j#live2d-widget-model-nico#live2d-widget-model-nietzsche#live2d-widget-model-nipsilon#live2d-widget-model-nito#live2d-widget-model-shizuku#live2d-widget-model-tororo#live2d-widget-model-tsumiki#live2d-widget-model-unitychan#live2d-widget-model-wanko#live2d-widget-model-z16live2d: enable: true scriptFrom: local model: use: live2d-widget-model-z16 display: position: right #模型位置 width: 140 #模型宽度 height: 260 #模型高度 mobile: show: false #是否在手机端显示 卡通人物升级版效果如下图： 能说话、能换装、能玩游戏、能拍照、还能自定义。 实现方法 下载 张书樵 大神的项目，解压到本地博客目录的themes/next/source下，修改autoload.js文件，如下：将 1234const live2d_path = "https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/";改为const live2d_path = "/live2d-widget/"; 在/themes/next/layout/_layout.swing中,新增如下内容： 1&lt;script src="/live2d-widget/autoload.js"&gt;&lt;/script&gt; 在主题配置文件 中,新增如下内容： 12live2d: enable: true 想修改看板娘大小、位置、格式、文本内容等，可查看并修改 waifu-tips.js 、 waifu-tips.json 和 waifu.css。 去掉顶部黑线打开themes\next\source\css\_custom\custom.styl添加以下代码： 1.headband &#123;display:none;&#125; 修改主题页面布局为圆角方法一在/themes/next/source/css/_variables/custom.styl文件种添加如下代码（以Gemini风格为例）： 123456789101112131415// 修改主题页面布局为圆角// Variables of Gemini scheme// =================================================@import "Pisces.styl";// Settings for some of the most global styles.// --------------------------------------------------$body-bg-color = #eee// Borders.// --------------------------------------------------$box-shadow-inner = 0 2px 2px 0 rgba(0,0,0,.12), 0 3px 1px -2px rgba(0,0,0,.06), 0 1px 5px 0 rgba(0,0,0,.12)$box-shadow = 0 2px 2px 0 rgba(0,0,0,.12), 0 3px 1px -2px rgba(0,0,0,.06), 0 1px 5px 0 rgba(0,0,0,.12), 0 -1px .5px 0 rgba(0,0,0,.09)$border-radius-inner = initial$border-radius = initial$border-radius-inner = 15px 15px 15px 15px;$border-radius = 15px; 方法二在\themes\next\source\css\_variables\Gemini.styl文件中直接添加： 123// 修改主题页面布局为圆角$border-radius-inner = 15px 15px 15px 15px;$border-radius = 15px; 效果如下图：]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~安装]]></title>
    <url>%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E5%AE%89%E8%A3%85.html</url>
    <content type="text"><![CDATA[最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。后来有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。 要使用Git，第一步当然是安装Git了。根据你使用的操作系统如下： Linux上安装Git首先，你可以试着输入git，看看系统有没有安装Git： 123$ gitThe program &apos;git&apos; is currently not installed. You can install it by typing:sudo apt-get install git 像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。 如果你用的是Debian或Ubuntu Linux，通过 sudo apt-get install git 就可以直接完成Git的安装，非常简单。 老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。 如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。 Mac OS X上安装Git 有两种安装Git的方法: 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档。 第二种方法更简单，直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！ Windows上安装Git在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 安装完成后，还需要最后一步设置，在命令行输入： 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 Git可以安装在哪些操作系统上？ Linux macOS Solaris Windows Raspberry Pi Submit]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~合并指定文件或Commits到另一分支]]></title>
    <url>%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E5%90%88%E5%B9%B6%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E6%88%96Commits%E5%88%B0%E5%8F%A6%E4%B8%80%E5%88%86%E6%94%AF.html</url>
    <content type="text"><![CDATA[刚使用git进行版本管理的时候，由于成员间的代码有的需要上线，有的不需要上线，如果直接merge，经常会把别人不需要上线的代码合并的master，导致问题从生。所以，最稳妥的是只合并你需要的那些commits，不需要的commits就不合并进去。那么如何从一个分支合并特定的文件或者Commits到另一个分支这个问题急待解。 合并某个分支上的单个commit首先，用git log或sourcetree工具查看你想选择哪些commits进行合并，例如： 比如dev-w 分支上的commit 2aeefdacad6ed1586a1e035fb8860f11533db23c 非常重要，它含有一个紧急bug的修复或是其他内容。无论什么原因，你现在只需要将 2aeefdacad6ed1586a1e035fb8860f11533db23c 合并到master，而不合并dev-w上的其他commits，所以我们用git cherry-pick命令来做： 123git checkout master git cherry-pick 2aeefdacad6ed1586a1e035fb8860f11533db23c 这样 2aeefdacad6ed1586a1e035fb8860f11533db23c 就被合并到master分支，并在master中添加了commit（作为一个新的commit）。cherry-pick 和merge比较类似，如果git不能合并代码改动（比如遇到合并冲突），git需要你自己来解决冲突并手动添加commit。 这里git cherry-pick每次合并过来会显示文件冲突(其实并没有代码冲突部分，只需手动解决既可) 合并某个分支上的一系列commits在一些特定情况下，合并单个commit并不够，你需要合并一系列相连的commits。这种情况下就不要使用cherry-pick了，rebase 更适合。假设你需要合并dev-w分支的commit 76cada ~62ecb3 到master分支。 首先需要基于dev-w创建一个新的分支，并指明新分支的最后一个commit： 12git checkout dev-w git checkout -b newbranch 62ecb3 然后，rebase这个新分支的commit到master（–ontomaster）。76cada^ 指明你想从哪个特定的commit开始。 1git rebase --ontomaster 76cada^ 得到的结果就是dev-w分支的commit 76cada ~ 62ecb3 都被合并到了master分支。 另外如果只想将dev-w分支的某个文件Test.java合并到master分支上。 12git checkout dev-wgit checkout --patch master Test.java 第一个命令： 切换到dev-w分支；第二个命令：合并master分支上Test.java文件到dev-w分支上，将master分支上 Test.java 文件追加补丁到dev-w分支上 Test.java文件。你可以接受或者拒绝补丁内容。 如果只是简单的将dev-w分支的文件Test.java copy到master分支上； 12git checkout mastergit checkout dev-w Test.java 分支test上有一个文件A，你在test1分支上， 此时如果想用test分支上的A文件替换test1分支上的文件的话，可以使用git checkout test1, 然后git checkout test – A 在feature分支commit 切换至release分支 从feature分支检出相应文件 12345678#branch featuregit commit -a -m &quot;msg&quot;git checkout release#branch releasegit checkout feature file-01git checkout feature file-x...git commit -a -m &quot;msg&quot;]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL中的函数总结]]></title>
    <url>%2FMySQL%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[CONCAT()函数CONCAT（）函数用于将多个字符串连接成一个字符串。使用数据表sys_user作为示例，sql如下： SELECT user_id as id,zwxm as name FROM sys_user LIMIT 1; 返回结果如下： 12345+----+--------+| id | name |+----+--------+| 1 | 张三 |+----+--------+ 1、语法及使用特点： CONCAT(str1,str2,…)返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。可以有一个或多个参数。 2、使用示例： SELECT CONCAT(user_id, ‘，’, zwxm) AS con FROM sys_user LIMIT 1;返回结果如下： 12345+----------+| con |+----------+| 1,张三 |+----------+ SELECT CONCAT(‘My’, NULL, ‘QL’); 返回结果如下： 12345+--------------------------+| CONCAT(&apos;My&apos;, NULL, &apos;QL&apos;) |+--------------------------+| NULL |+--------------------------+ CONCAT_WS()函数使用语法为：· CONCAT_WS(separator,str1,str2,…) ·CONCAT_WS() 代表 CONCAT With Separator ，是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为 NULL，则结果为 NULL。函数会忽略任何分隔符参数后的 NULL 值。但是CONCAT_WS()不会忽略任何空字符串。 (然而会忽略所有的 NULL）。 示例1： SELECT CONCAT_WS(&#39;_&#39;,user_id,zwxm) AS con_ws FROM sys_user LIMIT 1; 返回结果： 12345+----------+| con_ws |+----------+| 1_张三 |+----------+ 示例2： SELECT CONCAT_WS(&#39;,&#39;,&#39;First name&#39;,NULL,&#39;Last Name&#39;); 返回结果： 12345+----------------------------------------------+| CONCAT_WS(&apos;,&apos;,&apos;First name&apos;,NULL,&apos;Last Name&apos;) |+----------------------------------------------+| First name,Last Name |+----------------------------------------------+ GROUP_CONCAT()函数语法如下： group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段] [Separator ‘分隔符’]) 基本查询： 123456789101112mysql&gt; select * from test; +------+------+ | id| name | +------+------+ |1 | 10 | |1 | 20 | |1 | 20 | |2 | 20 | |3 | 200 | |3 | 500 | +------+------+ 6 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔(默认) 123456789mysql&gt; select id,group_concat(name) from test group by id; +------+--------------------+ | id | group_concat(name) | +------+--------------------+ |1 | 10,20,20 | |2 | 20 | |3 | 200,500 | +------+--------------------+ 3 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，分号分隔 123456789mysql&gt; select id,group_concat(name separator &apos;;&apos;) from test group by id; +------+----------------------------------+ | id | group_concat(name separator &apos;;&apos;) | +------+----------------------------------+ |1 | 10;20;20 | |2 | 20 | |3 | 200;500 | +------+----------------------------------+ 3 rows in set (0.00 sec) 以id分组，把去冗余的name字段的值打印在一行，逗号分隔 123456789mysql&gt; select id,group_concat(distinct name) from test group by id; +------+-----------------------------+ | id | group_concat(distinct name) | +------+-----------------------------+ |1 | 10,20 | |2 | 20 | |3 | 200,500 | +------+-----------------------------+ 3 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔，以name排倒序 123456789mysql&gt; select id,group_concat(name order by name desc) from test group by id; +------+---------------------------------------+ | id | group_concat(name order by name desc) | +------+---------------------------------------+ |1 | 20,20,10 | |2 | 20 | |3 | 500,200 | +------+---------------------------------------+ 3 rows in set (0.00 sec) 使用group_concat_max_len系统变量，你可以设置允许的最大长度。 程序中进行这项操作的语法如下，其中 val 是一个无符号整数：SET [SESSION | GLOBAL] group_concat_max_len = val;若已经设置了最大长度， 则结果被截至这个最大长度。将环境变量group_concat_max_len 增大。默认是1024.我就设置了session级的环境变量将其变为2048（不够用再加大）]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-03之-Thread中start()和run()的区别]]></title>
    <url>%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-03%E4%B9%8B-Thread%E4%B8%ADstart-%E5%92%8Crun-%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[start()和run()方法的区别start(): 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。 run(): run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！ 下面以代码来进行说明。 123456class MyThread extends Thread&#123; public void run()&#123; ... &#125; &#125;;MyThread mythread = new MyThread(); mythread.start()会启动一个新线程，并在新线程中运行run()方法。而mythread.run()则会直接在当前线程中运行run()方法，并不会启动一个新线程来运行run()。 start()和run()方法示例下面，通过一个简单示例演示它们之间的区别。源码如下： 12345678910111213141516171819202122class TestThread extends Thread &#123; public TestThread(String name) &#123; super(name); &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + " is running"); &#125;&#125;;public class ThreadMethodDemo &#123; public static void main(String[] args) &#123; Thread mythread = new TestThread("testThread"); System.out.println(Thread.currentThread().getName() + " call testThread.run()"); mythread.run(); System.out.println(Thread.currentThread().getName() + " call testThread.start()"); mythread.start(); &#125;&#125; 运行结果： 1234main call testThread.run()main is runningmain call testThread.start()testThread is running 结果说明： 1) Thread.currentThread().getName()是用于获取“当前线程”的名字。当前线程是指正在cpu中调度执行的线程。2) testThread.run()是在“主线程main”中调用的，该run()方法直接运行在“主线程main”上。3) testThread.start()会启动“线程testThread”，“线程testThread”启动之后，会调用run()方法；此时的run()方法是运行在“线程testThread”上。 start()和run()源码说明（基于JDK1.8.0_171） Thread.java中start()方法源码如下： 12345678910111213141516171819202122232425262728public synchronized void start() &#123; /** * 如果线程不是"新建状态"，则抛出异常 * 状态值0 对应"新建" */ if (threadStatus != 0) throw new IllegalThreadStateException(); /** 将线程添加到ThreadGroup中 */ group.add(this); boolean started = false; try &#123; /** 通过start0()启动线程 */ start0(); /** 设置started标记 */ started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125;&#125; 说明： start()实际上是通过本地方法start0()启动线程的。而start0()会新运行一个线程，新线程会调用run()方法。 1private native void start0(); Thread.java中run()方法源码如下： 12345public void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 说明： target是一个Runnable对象。run()就是直接调用Thread线程的Runnable成员的run()方法，并不会新建一个线程。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-02之 多线程实现方式]]></title>
    <url>%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-02%E4%B9%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[实现多线程的几种方式 继承Thread类 实现Runnable接口 通过Callable和Future 通过线程池 Thread和Runnable简介RunnableRunnable是一个接口库，该接口只包含了一个run()方法，定义如下： 123public interface Runnable &#123; public abstract void run();&#125; Runnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；然后，通过new Thread(new A())等方式新建线程。 ThreadThread 是一个类。Thread本身就实现了Runnable接口。它的声明如下： 1public class Thread implements Runnable &#123;&#125; Thread和Runnable的异同点Thread 和 Runnable 的相同点：都是“多线程的实现方式”。Thread 和 Runnable 的不同点：Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。通常，建议通过“Runnable”实现多线程！ Thread和Runnable的多线程示例Thread的多线程示例123456789101112131415161718192021222324public class ThreadTest &#123; public static void main(String[] args) &#123; // 启动3个线程t1,t2,t3；每个线程各卖10张票！ MyThread t1 = new MyThread(); MyThread t2 = new MyThread(); MyThread t3 = new MyThread(); t1.start(); t2.start(); t3.start(); &#125;&#125;class MyThread extends Thread &#123; private int ticket = 10; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if (this.ticket &gt; 0) &#123; System.out.println(this.getName() + " 卖票：ticket" + this.ticket--); &#125; &#125; &#125;&#125;; 运行结果： 123456789101112131415161718192021222324252627282930Thread-2 卖票：ticket10Thread-1 卖票：ticket10Thread-0 卖票：ticket10Thread-1 卖票：ticket9Thread-2 卖票：ticket9Thread-1 卖票：ticket8Thread-0 卖票：ticket9Thread-1 卖票：ticket7Thread-2 卖票：ticket8Thread-1 卖票：ticket6Thread-0 卖票：ticket8Thread-1 卖票：ticket5Thread-2 卖票：ticket7Thread-1 卖票：ticket4Thread-0 卖票：ticket7Thread-1 卖票：ticket3Thread-2 卖票：ticket6Thread-1 卖票：ticket2Thread-0 卖票：ticket6Thread-1 卖票：ticket1Thread-2 卖票：ticket5Thread-0 卖票：ticket5Thread-2 卖票：ticket4Thread-0 卖票：ticket4Thread-2 卖票：ticket3Thread-0 卖票：ticket3Thread-2 卖票：ticket2Thread-0 卖票：ticket2Thread-2 卖票：ticket1Thread-0 卖票：ticket1 结果说明： (01) MyThread继承于Thread，它是自定义个线程。每个MyThread都会卖出10张票。(02) 主线程main创建并启动3个MyThread子线程。每个子线程都各自卖出了10张票。 Runnable的多线程示例1234567891011121314151617181920212223242526class MyThread2 implements Runnable &#123; private int ticket = 10; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if (this.ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + " 卖票：ticket" + this.ticket--); &#125; &#125; &#125;&#125;;public class RunnableTest &#123; public static void main(String[] args) &#123; MyThread2 mt = new MyThread2(); // 启动3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！ Thread t1 = new Thread(mt); Thread t2 = new Thread(mt); Thread t3 = new Thread(mt); t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果： 12345678910Thread-0 卖票：ticket10Thread-0 卖票：ticket7Thread-0 卖票：ticket6Thread-0 卖票：ticket5Thread-2 卖票：ticket8Thread-1 卖票：ticket9Thread-1 卖票：ticket2Thread-1 卖票：ticket1Thread-2 卖票：ticket3Thread-0 卖票：ticket4 结果说明： (01) 和上面“MyThread继承于Thread”不同；这里的MyThread实现了Thread接口。(02) 主线程main创建并启动3个子线程，而且这3个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-01之-基本概念]]></title>
    <url>%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-01%E4%B9%8B-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</url>
    <content type="text"><![CDATA[线程状态图 线程状态解析 1. 新建状态(New): 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。 2. 就绪状态(Runnable): 也被称为“可执行状态”，处于就绪状态的线程，随时可能被CPU调度执行。 调用线程的start()方法，此线程进入就绪状态。 当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。 当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。 锁池里的线程拿到对象锁后，进入就绪状态。 3. 运行状态(Running):线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。 4. 阻塞状态(Blocked): 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种： 等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。 同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。 其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 5. 死亡状态(Dead): 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。线程一旦终止了，就不能复生。在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。 说明这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。Object类，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。Thread类，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。synchronized，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。 几个方法的比较 1. Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。 2. Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。 3. t.join()/t.join(long millis)，当前线程里调用其它线程t的join方法，当前线程进入WAITING/TIMED_WAITING状态，当前线程不会释放已经持有的对象锁。线程t执行完毕或者millis时间到，当前线程进入就绪状态。 4. obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout) timeout时间到自动唤醒。 5. obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL性能优化]]></title>
    <url>%2FMySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[啦啦啦啦啦啦啦啦啦]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java - 面试题总结]]></title>
    <url>%2FJava%20-%20%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[Java里面所有的不变的属性需要用final修饰吗 答：没必要。你可以实现相同的功能通过以下操作：设为非final的private 变量，且只有在构造函数中才能修改。不设set方法，如果是一个可变对象，不要泄露任何指向这个对象的引用。 设置一个引用变量为final 只能确保这个变量不会被赋予一个不同的引用，但是你仍然可以改变引用变量的属性值。 String的subString()实现原理 答：substring取原来string的一部分创建一个新的对象。这个问题主要想问substring可能导致的内存泄露风险。 直到Java1.7， substring 拥有原来的字符数组的引用，这意味着即使是五字符这么小的字符串，也可能会导致一个1GB字符数组无法被垃圾回收，因为有一个强引用。 这个问题在Java1.7中已经被修复，原来的字符数组不会被引用，但是会导致创建substring耗时会有点长，以前时间复杂度是 O(1), Java 7之后时间复杂度是 O(n)。 Java中如何处理写存储过程或者读存储过程时遇到的错误 答： 一个存储过程应该在操作错误时返回错误码，但是如果存储过程本身出问题，捕获 SQLException 是唯一选择。 工厂模式和抽象工厂模式有什么区别 答：抽象工场模式提供一个多层级的抽象。考虑不同的工厂继承自同一个抽象工厂，代表基于工厂的不同对象结构的创建，例如， AutomobileFactory,UserFactory,RoleFactory等都继承自 AbstractFactory。每一个独立的工厂代表那种类型物体的创造器。 下面是一个工厂模式和抽象工厂模式的UML图： 什么时候重写 hashCode()和 equals()方法 答：当需要通过业务逻辑校验两个对象是否相等，而不是通过两个对象是否执行同一地址。例如两个员工对象在 emp_id 相等的时候相等，即使它们是通过不同的代码创建出来的两个不同对象。 另外，如果你使用一个对象作为 HashMap的key，你必须重写这两个方法。 作为java equals-hashcode约束的一部分，当你重写equals的时候，必须重写hashcode. 否则你不能在Set，Map这样的类里面使用，因为他们通过equals()方法来保证逻辑正确性。 双引号直接创建字符串和使用new()创建字符串有什么区别 答: 使用new()创建String对象，实例被创建在堆中, 不会被添加到String常量池中，当通过字面量创建时，会被放到堆中的永久区的String常量池中。 Stringstr = newString(“Test”) 不会把str放到String常量池中，需要调用String.intern()方法，才会把它放到String常量池中。 当使用String字面量创建String对象时，如通过String s = “Test”, java会自动放入String常量池中。 另外，如果把”Test”这样的String字面量传进去，也会创建另外一个对象:”Test” 在String常量池。 什么是不可变对象，如何写一个不可变类 答：不可变对象是指Java类的对象一单被创建，不能被修改。任何不可变对象对象的修改在创建时候就已经完成，例如，Java中String是不可变的。 大多数不可变类是final的, 这样可以防止因子类重写方法而导致不可变失效。 你也可以实现相同的功能通过让成员非final但是private，且除了构造方法任何其他方法无法修改。 另外，要确保没有暴露不可变对象的内部，尤其是它包含可变成员的时候。 同时，当你从客户端接收到可变的对象时，例如 java.util.Date, 使用clone() 方法 来获取一个独立的拷贝，防止恶意修改可变对象带来的风险。 相同的优化需要在返回一个可变成员时执行。返回另一个独立拷贝给客户端；不要返回可变对象的原始引用。]]></content>
      <categories>
        <category>面试题</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试题总结]]></title>
    <url>%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[多线程的优缺点优点： 多线程技术使程序的响应速度更快。 当前没有进行处理的任务可以将处理器时间让给其它任务。 占用大量处理时间的任务可以定期将处理器时间让给其它任务。 可以随时停止任务。 可以分别设置各个任务的优先级以及优化性能。 缺点 等候使用共享资源时造成程序的运行速度变慢。 对线程进行管理要求额外的cpu开销。 可能出现线程死锁情况。即较长时间的等待或资源竞争以及死锁等症状。 在java中守护线程和本地线程区别 java中的线程分为两种：守护线程（Daemon）和用户线程（User）。 任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(bool on)；true则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。 两者的区别： 唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经撤离，Daemon 没有可服务的线程，JVM撤离。也可以理解为守护线程是JVM自动创建的线程（但不一定），用户线程是程序创建的线程；比如JVM的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动离开。 扩展：Thread Dump打印出来的线程信息，含有daemon字样的线程即为守护进程，可能会有：服务守护进程、编译守护进程、windows下的监听Ctrl+break的守护进程、Finalizer守护进程、引用处理守护进程、GC守护进程。 线程与进程的区别 进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。一个程序至少有一个进程,一个进程至少有一个线程。 什么是多线程中的上下文切换 多线程会共同使用一组计算机上的CPU，而线程数大于给程序分配的CPU数量时，为了让各个线程都有执行的机会，就需要轮转使用CPU。不同的线程切换使用CPU发生的切换数据等就是上下文切换。 死锁与活锁的区别，死锁与饥饿的区别 死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。 产生死锁的必要条件： 互斥条件：所谓互斥就是进程在某一时间内独占资源。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。 饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。 Java中导致饥饿的原因： 高优先级线程吞噬所有的低优先级线程的CPU时间。 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。 线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的wait方法)，因为其他线程总是被持续地获得唤醒。 start()方法和run()方法的区别start()方法： 用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。 通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到CPU时间片，就开始执行run()方法。 run()方法： run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条。 总结： 调用start方法方可启动线程。 run方法只是thread的一个普通方法调用，还是在主线程里执行。 把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用run()方法，这是由jvm的内存机制规定的。 run()方法必须是public访问权限，返回值类型为void。 Runnable接口和Callable接口的相同点和不同点相同点： Callable和Runnable都是接口； Callable和Runnable都一科应用于Executors； 不同点： Callable要实现call()方法，Runnable要实现run()方法； call()方法可以有返回值，run()方法不能有返回值； call(0方法可以抛出Checked Exception，run()方法不可以； Runnable接口在Jdk1.1中就有了，Callable在JDK1.5才有； voliate关键字的作用 多线程使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据。 Java代码执行中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率。 CyclicBarrier和CountDownLatch的区别 CountDownLatch CyclicBarrier 减计数方式 加计数方式 计数为0时唤醒所有等待的线程 计数达到指定值时唤醒所有等待的线程 计数为0无法重置 计数达到指定值时，计数置为0重新开始 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没有影响 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 不能重复利用 可重复使用 voliate和synchronized对比 volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住。 volatile仅能使用在变量级别,synchronized则可以使用在变量,方法以及类级别。 volatile仅能实现变量的修改可见性,而synchronized则可以保证变量的修改可见性和原子性。 volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞。 怎么唤醒一个阻塞的线程 如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它； 如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。 sleep方法和wait方法的相同点和不同点相同点： 二者都可以让线程处于阻塞； 不同点： 首先sleep方法是Thread类中定义的方法，而wait方法是Object类中定义的方法。 sleep方法必须人为地为其指定休眠时间。wait方法既可以指定时间，也可以不指定时间。 sleep方法时间到了，线程处于临时阻塞状态或者运行状态。wait方法如果没有被设置时间，就必须要通过notify或者notifyAll来唤醒。 sleep方法不一定非要定义在同步中。wait方法必须定义在同步中。 当二者都定义在同步中时，线程执行到sleep，不会释放锁。线程执行到wait，会释放锁。 生产者和消费者模型的作用 通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用。 解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约。 Executor.submit()和Executor.execute()的区别 前者返回一个 Future对象，可以用于找到工作线程的运行结果。 在异常处理上也不一样，在任务抛出异常时，如果是通过 execute()提交的，会抛出无需捕获的异常（如果你没有特殊处理，会打印错误栈道System.err）。如果是通过 submit()提交的，任何异常，无论是不是checked exception，都是返回的一部分，Future.get将把异常包在 ExecutionExeption中，向上层抛出。 ThreadLocal的作用 ThreadLocal用来解决多线程程序的并发问题。 ThreadLocal并不是一个Thread,而是Thread的局部变量,当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,所以每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本。 从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。 线程局部变量并不是Java的新发明,Java没有提供在语言级支持(语法上),而是变相地通过ThreadLocal的类提供支持。 wait方法和notify/notifyAll方法在放弃对象监视器时的区别 wait()方法立即释放对象监视器； notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。 Lock和synchronized对比 Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现； synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断； 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 Lock可以提高多个线程进行读操作的效率。 在JDK1.5中，synchronized是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞式的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java提供的Lock对象，性能更高一些。但是，JDK1.6，发生了变化，对synchronize加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在JDK1.6上synchronize的性能并不比Lock差。因此。提倡优先考虑使用synchronized来进行同步。 ReadWriteLock是什么 ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。 FutureTask是什么 FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。 Java中用到的线程调度算法 抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。 乐观锁和悲观锁 乐观锁：对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-设置这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。悲观锁：对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，直接对操作资源上了锁。 编写一个死锁程序死锁现象描述：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。 死锁的实现步骤： 两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁； 线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，100毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁; 线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的这样，线程1″睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。 代码实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class DeadLock &#123; public void run() &#123; TestDeadLock tl = new TestDeadLock(); new Thread(tl, "线程A").start(); new Thread(tl, "线程B").start(); &#125; class TestDeadLock implements Runnable &#123; private Object objA = new Object(); private Object objB = new Object(); private boolean flag = true; @Override public void run() &#123; if (flag) &#123; flag = false; synchronized (objA) &#123; System.out.println(Thread.currentThread().getName() + "锁住资源A，等待资源B"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (objB) &#123; System.out.println(Thread.currentThread().getName() + "获得资源B"); &#125; &#125; &#125; else &#123; flag = true; synchronized (objB) &#123; System.out.println(Thread.currentThread().getName() + "锁住资源B，等待资源A"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (objA) &#123; System.out.println(Thread.currentThread().getName() + "获得资源A"); &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; new DeadLock().run(); &#125;&#125;输出结果是：线程A锁住资源A，等待资源B线程B锁住资源B，等待资源A Java中如何避免死锁 死锁发生是因为两个线程试图获取被对方持有的资源。但是要想发生这种情况，必须满足以下四个条件： 相互排斥 —— 至少一个进程必须处于非共享模式； 保持并等待 —— 必须有一个进程持有一个资源并等待另一个资源； 没有抢占 —— 资源不能被抢占； 循环等待 —— 存在进程集合。通过中断循环等待可以避免死锁。可以通过在代码中指定获取和释放锁的顺序来达到这一目的。 如果多个锁通过一致的顺序被获取和释放，不会有互相等待对方释放锁的情况。 为什么使用Executor框架 每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。 调用 new Thread()创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。 直接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。 能复用已存在并空闲的线程从而减少线程对象的创建从而减少了消亡线程的开销。 可有效控制最大并发线程数，提高系统资源使用率，同时避免过多资源竞争。 框架中已经有定时、定期、单线程、并发数控制等功能。 在Java Concurrency API中有哪些原子类 原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference 原子数组：AtomicIntegerArray,AtomicLongArray，AtomicReferenceArray 原子属性更新器：AtomicLongFieldUpdater,AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater 解决ABA问题的原子类：AtomicMarkableReference(通过引入一个boolean来反映中间有没有变过）,AtomicStampedReference（通过引入一个int来累加来反映中间有没有变过） Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。 它的优势有： 可以使锁更公平 可以使线程在等待锁的时候响应中断 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间 可以在不同的范围，以不同的顺序获取和释放锁 整体上来说Lock是synchronized的扩展版，Lock提供了无条件的、可轮询的(tryLock方法)、定时的(tryLock带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition方法)锁操作。另外Lock的实现类基本都支持非公平锁(默认)和公平锁，synchronized只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。 什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。 这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。 阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。 JDK7提供了7个阻塞队列。分别是： ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。 LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。 PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。 DelayQueue：一个使用优先级队列实现的无界阻塞队列。 SynchronousQueue：一个不存储元素的阻塞队列。 LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 Java 5之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait ,notify,notifyAll,sychronized这些关键字。而在java 5之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。 BlockingQueue接口是Queue的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向BlockingQueue放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中放入元素，取出元素，它可以很好的控制线程之间的通信。 阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。 什么叫线程安全？servlet是线程安全吗? 线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。 Servlet不是线程安全的，servlet是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。 Struts2的action是多实例多线程的，是线程安全的，每个请求过来都会new一个新的action分配给这个请求，请求完成后销毁。 SpringMVC的Controller是线程安全的吗？不是的，和Servlet类似的处理流程 Struts2好处是不用考虑线程安全问题；Servlet和SpringMVC需要考虑线程安全问题，但是性能可以提升不用处理太多的gc，可以使用ThreadLocal来处理多线程的问题。 Java中interrupted 和 isInterrupted方法的区别interrupt interrupt方法用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。 注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。 interrupted 查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用interrupted则返回true，第二次和后面的就返回false了。 isInterrupted 仅仅是查询当前线程的中断状态。]]></content>
      <categories>
        <category>面试题</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法画流程图]]></title>
    <url>%2FMarkdown-%E8%AF%AD%E6%B3%95%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE.html</url>
    <content type="text"><![CDATA[添加支持Hexo 默认是不支持流程图的 Markdown 语法的，需要添加支持： 1npm install --save hexo-filter-flowchart 演示一个简单的流程图语法如下： 12345678910···flow #由于渲染问题，请自行将 · 替换为 `st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op··· 效果如下： 一个稍复杂的流程图语法如下： 12345678910111213···flow #由于渲染问题，请自行将 · 替换为 `st=&gt;start: Start:&gt;http://www.google.com[blank]e=&gt;end:&gt;http://www.google.comop1=&gt;operation: My Operationsub1=&gt;subroutine: My Subroutinecond=&gt;condition: Yesor No?:&gt;http://www.google.comio=&gt;inputoutput: catch something...st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1··· 效果如下： 语法详解Hexo中的流程图是依赖于flowchart.js 实现的。以上面那个稍复杂的流程图为例： 1234567891011121314···flow #由于渲染问题，请自行将 · 替换为 `//定义部分st=&gt;start: Start:&gt;http://www.google.com[blank]e=&gt;end:&gt;http://www.google.comop1=&gt;operation: My Operationsub1=&gt;subroutine: My Subroutinecond=&gt;condition: Yes or No?:&gt;http://www.google.comio=&gt;inputoutput: catch something...//判断和位置控制st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1··· 例如这一句： st=&gt;start: Start|past:&gt;http://www.google.com[blank] 其中，st是变量名，start是指操作模块名，冒号后面就是内容了。需要注意的是，** 冒号后要加空格才能识别 ** 操作模块语法 操作模块 说明 start 开始 end 结束 operation 普通操作块 condition 判断块 subroutine 子任务块 inputoutput 输入输出块 判断和位置控制```markdown流程控制st-&gt;op1-&gt;e -&gt; 作为控制流程的操作符，就是指向下一步要操作的。 每一条都算是一条流程 你也可以断开写，怎么方便怎么来，如：下面两个是一样的。 分着写st-&gt;op1op1-&gt;e 合着写st-&gt;op1-&gt;e 判断cond(yes)-&gt;io-&gt;e #yes的时候到io，再到e 位置指定cond(no)-&gt;sub1(right)-&gt;op1 #no的时候到到 sub1，再从sub1的右侧到op1还可以这样 cond1(no,right)```st=>start: 开始 e=>end: 结束 op=>operation: 我的操作 cond=>condition: 确认？ st->op->cond cond(yes)->e cond(no)->op{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);st=>start: Start:>http://www.google.com[blank] e=>end:>http://www.google.com op1=>operation: My Operation sub1=>subroutine: My Subroutine cond=>condition: Yes or No?:>http://www.google.com io=>inputoutput: catch something... st->op1->cond cond(yes)->io->e cond(no)->sub1(right)->op1{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-1", options);]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法糖]]></title>
    <url>%2FMarkdown%E8%AF%AD%E6%B3%95%E7%B3%96.html</url>
    <content type="text"><![CDATA[前言Markdown 是一种轻量级的标记语言，其用简单的标记语法便可达到排版的目的，可以使我们更加专注于内容的编写，而不需过多关注排版。本文主要整理了 Markdown 中的常用的标记语法，以便自己与他人以后查用。 优点 纯文本，所以兼容性极强，可以用所有文本编辑器打开。 让你专注于文字而不是排版。 格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。 Markdown 的标记语法有极好的可读性。 缺点 需要记一些语法（当然，是很简单。五分钟学会）。 有些平台不支持Markdown编辑模式。 基本语法标题在想要设置为标题的文字前面加#来表示，一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：#与文字之间要有一个空格。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 字体星号或者下划线都可以，单是斜体，双是粗体，符号可以跨行，符号可加空格。 加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来 示例： 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用。 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 分割线三个或者三个以上的 - 或者 * 都可以。 示例： 1234-------******** 效果如下：可以看到，显示效果是一样的。 图片语法： 1234![图片alt](图片地址 ''图片title'')图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 1![一脸懵逼](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1558179968948&amp;di=1c8a7432843fdaafb91e9cbffacd1557&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201608%2F02%2F20160802213915_x23St.thumb.700_0.jpeg "一脸懵逼") 效果如下： 超链接语法： 12[超链接名](超链接地址 "超链接title")title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下：简书百度注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href="超链接地址" target="_blank"&gt;超链接名&lt;/a&gt;示例&lt;a href="https://www.jianshu.com/u/1f5ac0cf6a8b" target="_blank"&gt;简书&lt;/a&gt; 索引超链接示例： 12[百度][1][1]:http://www.baidu.com 效果如下：[百度][1][1]:http://www.baidu.com 自动链接语法：使用尖括号。 示例： 12&lt;http://www.baidu.com&gt;&lt;1111111@qq.com&gt; 效果如下：http://www.baidu.com&#x31;&#x31;&#x31;&#x31;&#49;&#x31;&#x31;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d; 列表无序列表语法：无序列表用 - + * 任何一种都可以。 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表语法：数字加点。 123451. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 嵌套列表语法：上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 注意：在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2019.5.18 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了。如所示：示例： 12019\.5\.18 效果如下：2019.5.18 表格Markdown表格语法： 1234567891011|表头|表头|表头||---|:---:|---:||内容|内容|内容||内容|内容|内容|第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例1： 12345| 法号 | 本领 | 排行 || :--------: | :-----: | :----: || 悟空 | 72变 | 大师兄|| 悟能 | 36变 | 二师哥|| 悟净 | 18变 | 三师弟| 效果如下： 法号 本领 排行 悟空 72变 大师兄 悟能 36变 二师哥 悟净 18变 三师弟 示例2： 1234567891011121314151617181920212223242526272829表头1 | 表头2------------- | -------------Content Cell | Content CellContent Cell | Content Cell| 表头1 | 表头2|| ------------- | ------------- || Content Cell | Content Cell || Content Cell | Content Cell || 名字 | 描述 || ------------- | ----------- || Help | Display the help window.|| Close | Closes a window |表格中也可以使用普通文本的删除线，斜体等效果| 名字 | 描述 || ------------- | ----------- || Help | ~~Display the~~ help window.|| Close | _Closes_ a window |表格可以指定对齐方式| 左对齐 | 居中 | 右对齐 || :------------ |:---------------:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 效果如下： 表头1 表头2 Content Cell Content Cell Content Cell Content Cell 表头1 表头2 Content Cell Content Cell Content Cell Content Cell 名字 描述 Help Display the help window. Close Closes a window 名字 描述 Help Display the help window. Close Closes a window 左对齐 居中 右对齐 col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 HTML表格语法： 1234567891011121314151617181920&lt;table&gt; &lt;tr&gt; &lt;th&gt;项目1&lt;/th&gt; &lt;th&gt;项目2&lt;/th&gt; &lt;th&gt;项目3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;a1&lt;/td&gt; &lt;td colspan="2"&gt;a2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan="2"&gt;b1&lt;/td&gt; &lt;td&gt;b2&lt;/td&gt; &lt;td&gt;b3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;c2&lt;/td&gt; &lt;td&gt;c3&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果： 项目1 项目2 项目3 a1 a2 b1 b2 b3 c2 c3 需要注意的一点是，在markdown中使用html代码来实现表格的效果，需要在表格的外面套上： 1&lt;escape&gt;&lt;/escape&gt; （转义），防止markdown直接将代码中的行进行转义成回车，不然会出现表格前空了一大块空白。 但同时，引入html会使得markdown的易读易写的特性降低。除非必要，还是推荐使用markdown本身的表格语法。那么，我们如何在使用html表格的时候，偷懒不用打这段表格呢？ http://www.tablesgenerator.com/ 安利这个网站，它可以实现你的需求，包括合并单元格等。 代码单行代码语法：代码之间分别用一个反引号包起来。 1`代码内容` 示例： 1`create database hero;` 效果如下： create database hero; 代码块语法：代码之间分别用三个反引号包起来，且两边的反引号单独占一行。 12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 123456(```) function fun()&#123; echo "这是一句非常牛逼的代码"; &#125; fun();(```) 效果如下： 1234function fun()&#123; echo "这是一句非常牛逼的代码";&#125;fun(); 注释语法：用html的注释 1&lt;!-- 用html的注释 --&gt; 转义字符Markdown中的转义字符为\，转义的有： 123456789101112\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号 效果如下：\ 反斜杠` 反引号* 星号_ 下划线{} 大括号[] 中括号() 小括号# 井号+ 加号- 减号. 英文句号! 感叹号 其他特殊字符示例： 1234567891011&amp;#10084&amp;#10003&amp;#9728&amp;#9733&amp;#9730&amp;#9775&amp;#9762&amp;#9742&amp;#8734&amp;#10052&amp;#9835 效果如下： &amp;#10084&amp;#10003&amp;#9728&amp;#9733&amp;#9730&amp;#9775&amp;#9762&amp;#9742&amp;#8734&amp;#10052&amp;#9835 想知道字符对应的Unicode码，可以看这个网站：https://unicode-table.com/cn/ 流程图效果如下： 段落与换行Markdown中段落指连续的一段文字，编写时段落之间至少一个空行隔开，段落内多个空格被视为一个空格，段首不支持缩进。如何想要在显示时显示多个空行，可以插入实现，注意的是，插入的应与前后的段落中间至少空一行。 段落缩进（空格）示例： 1234半方大的空白&amp;ensp;或&amp;#8194;看，飞碟全方大的空白&amp;emsp;或&amp;#8195;看，飞碟不断行的空白格&amp;nbsp;或&amp;#160;看，飞碟&amp;emsp;&amp;emsp;段落从此开始。 效果如下：半方大的空白&ensp;或&#8194;看，飞碟全方大的空白&emsp;或&#8195;看，飞碟不断行的空白格&nbsp;或&#160;看，飞碟&emsp;&emsp;段落从此开始。 字体、字号、颜色、背景色示例： 1234567&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;&lt;font color=#00ffff size=3&gt;null&lt;/font&gt;&lt;font color=gray size=5&gt;gray&lt;/font&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF4500&gt;这里的背景色是：OrangeRed， 十六进制颜色值：#FF4500， rgb(255, 69, 0)&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果如下：我是黑体字我是微软雅黑我是华文彩云黑体nullgray 这里的背景色是：OrangeRed， 十六进制颜色值：#FF4500， rgb(255, 69, 0) 快捷键 功能 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y GitHub特有特性复选框列表在列表符号后面加上[]或者[x]代表选中或者未选中情况。示例： 1234567+ [x] C+ [x] C+++ [x] Java+ [x] Qt+ [x] Android+ [ ] C#+ [ ] .NET 效果如下： C C++ Java Qt Android C# .NET emoji表情符号emoji表情使用:EMOJICODE:的格式，详细列表可见：https://www.webpagefx.com/tools/emoji-cheat-sheet/当然现在很多markdown工具或者网站都不支持。 下面列出几个平台的对比： 工具/网站 emoji 简书 否 github 是 有道云笔记 否 st=>start: 开始 op=>operation: My Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改GitHub项目语言显示问题]]></title>
    <url>%2F%E4%BF%AE%E6%94%B9GitHub%E9%A1%B9%E7%9B%AE%E8%AF%AD%E8%A8%80%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[概述当我们上传项目到GitHub上，有时候项目显示的语言并非是我们自己项目所示的语言，这就导致我们在快速检索，或者外部访问者访问时不能够搜索到我们的项目，所以，此时就很有必要修改下语言。 修改GitHub语言1、在本地项目中或者GitHub项目中新建一个 .gitattributes的文件，输入以下内容： 12345*.yml linguist-language=Java *.html linguist-language=Java *.js linguist-language=Java *.xml linguist-language=Java*.css linguist-language=Java 需要说明的是，假如我们的项目中有很多的诸如.html、.js等文件，在GitHub上会显示为HTML、JavaScript，所以.gitattributes文件内容的意思就是将忽略.xx什么什么文件，然后将其语言更改为Java，如果你的项目是其他语言，诸如C++等就将Java修改为C++等。当然了，这样修改也许还不能将你的项目语言修改成功，所以你需要去查询你项目中所有尽可能的后缀名文件影响语言的情况考虑，要根据GitHub给你当前项目设定的是什么语言，就从什么语言去考虑就好了。所以在.gitattributes文件中添加多一些属性就解决了。如下： 123456789*.md linguist-language=Java *.yml linguist-language=Java *.html linguist-language=Java *.js linguist-language=Java *.xml linguist-language=Java*.css linguist-language=Java *.sql linguist-language=Java*.uml linguist-language=Java *.cmd linguist-language=Java]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的SpringBoot启动banner（持续更新）]]></title>
    <url>%2F%E6%9C%89%E8%B6%A3%E7%9A%84SpringBoot%E5%90%AF%E5%8A%A8banner%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89.html</url>
    <content type="text"><![CDATA[千里马123456789101112131415161718192021 _(\_/) ,((((^`\ (((( (6 \ ,((((( , \ ,,,_ ,((((( /"._ ,`, ((((\\ ,... ,(((( / `-.-' ))) ;' `"'"'""(((( ( ((( / ((( \ )) | |(( | . ' |)) \ _ ' `t ,.')( | y;- -,-""'"-.\ \/ ) / ./ ) / `\ \ |./ ( ( / /' || \\ //'| || \\ _//'|| || )) |_/ || \_\ |_/ || `'" \_\ `'" 文字兔12345678910111213141516171819202122232425262728293031323334353637/*** * 瓦瓦 十 * 十齱龠己 亅瓦車己 * 乙龍龠毋日丶 丶乙己毋毋丶 * 十龠馬鬼車瓦 己十瓦毋毋 * 鬼馬龠馬龠十 己己毋車毋瓦 * 毋龠龠龍龠鬼乙丶丶乙車乙毋鬼車己 * 乙龠龍龍鬼龍瓦 十瓦毋乙瓦龠瓦亅 * 馬齱龍馬鬼十丶日己己己毋車乙丶 * 己齱馬鬼車十十毋日乙己己乙乙 * 車馬齱齱日乙毋瓦己乙瓦日亅 * 亅車齺龖瓦乙車龖龍乙乙十 * 日龠龠十亅車龍毋十十 * 日毋己亅 己己十亅亅 * 丶己十十乙 丶丶丶丶丶 * 亅己十龍龖瓦 丶 丶 乙十 * 亅己十龠龖毋 丶丶 丶己鬼鬼瓦亅 * 十日十十日亅丶亅丶 丶十日毋鬼馬馬車乙 * 十日乙十亅亅亅丶 十乙己毋鬼鬼鬼龍齺馬乙 * 丶瓦己乙十十亅丶亅乙乙乙己毋鬼鬼鬼龍齱齺齺鬼十 * 乙乙十十十亅乙瓦瓦己日瓦毋鬼鬼龠齱齱龍龍齱齱毋丶 * 亅十十十十乙瓦車毋瓦瓦日車馬龠龍龍龍龍龍龠龠龠馬亅 * 十十十十己毋車瓦瓦瓦瓦鬼馬龠龍龠龠龍龠龠龠馬龠車 * 亅十十日毋瓦日日瓦鬼鬼鬼龠龠馬馬龠龍龍龠馬馬車 * 亅亅亅乙瓦瓦毋車車車馬龍龠鬼鬼馬龠龍龍龠馬馬鬼 * 丶丶乙亅亅乙車鬼鬼鬼毋車龍龍龠鬼馬馬龠龍齱齱龍馬鬼 * 亅己十十己十日鬼鬼車瓦毋龠龍龠馬馬龠龠龠齱齺齺齱龠鬼 * 亅乙乙乙十車馬車毋馬齱齱龍龠龠龠馬龠龍齱龍龠龠鬼瓦 * 丶毋龠鬼車瓦車馬龠龍龠龠龍齱齱龠馬馬鬼毋日 * 十乙己日十 丶己鬼龍齱齺齱龍馬馬馬車毋己 * 丶十己乙亅丶 亅瓦馬龠龍龠龠馬毋瓦乙 * 丶十十乙亅十 亅己瓦車馬龠鬼車瓦乙 * 丶十乙十十丶 丶丶亅十瓦鬼車瓦己 * 丶亅亅丶 亅日瓦日 * 丶 */ 狗头1123456789101112131415161718192021222324252627282930313233343536373839/*** * .,:,,, .::,,,::. * .::::,,;;, .,;;:,,....:i: * :i,.::::,;i:. ....,,:::::::::,.... .;i:,. ......;i. * :;..:::;::::i;,,:::;:,,,,,,,,,,..,.,,:::iri:. .,:irsr:,.;i. * ;;..,::::;;;;ri,,,. ..,,:;s1s1ssrr;,.;r, * :;. ,::;ii;:, . ................... .;iirri;;;,,;i, * ,i. .;ri:. ... ............................ .,,:;:,,,;i: * :s,.;r:... ....................................... .::;::s; * ,1r::. .............,,,.,,:,,........................,;iir; * ,s;........... ..::.,;:,,. ...............,;1s * :i,..,. .,:,,::,. .......... .......;1, * ir,....:rrssr;:, ,,.,::. .r5S9989398G95hr;. ....,.:s, * ;r,..,s9855513XHAG3i .,,,,,,,. ,S931,.,,.;s;s&amp;BHHA8s.,..,..:r: * :r;..rGGh, :SAG;;G@BS:.,,,,,,,,,.r83: hHH1sXMBHHHM3..,,,,.ir. * ,si,.1GS, sBMAAX&amp;MBMB5,,,,,,:,,.:&amp;8 3@HXHBMBHBBH#X,.,,,,,,rr * ;1:,,SH: .A@&amp;&amp;B#&amp;8H#BS,,,,,,,,,.,5XS, 3@MHABM&amp;59M#As..,,,,:,is, * .rr,,,;9&amp;1 hBHHBB&amp;8AMGr,,,,,,,,,,,:h&amp;&amp;9s; r9&amp;BMHBHMB9: . .,,,,;ri. * :1:....:5&amp;XSi;r8BMBHHA9r:,......,,,,:ii19GG88899XHHH&amp;GSr. ...,:rs. * ;s. .:sS8G8GG889hi. ....,,:;:,.:irssrriii:,. ...,,i1, * ;1, ..,....,,isssi;, .,,. ....,.i1, * ;h: i9HHBMBBHAX9: . ...,,,rs, * ,1i.. :A#MBBBBMHB##s ....,,,;si. * .r1,.. ,..;3BMBBBHBB#Bh. .. ....,,,,,i1; * :h;.. .,..;,1XBMMMMBXs,.,, .. :: ,. ....,,,,,,ss. * ih: .. .;;;, ;;:s58A3i,.. ,. ,.:,,. ...,,,,,:,s1, * .s1,.... .,;sh, ,iSAXs;. ,. ,,.i85 ...,,,,,,:i1; * .rh: ... rXG9XBBM#M#MHAX3hss13&amp;&amp;HHXr .....,,,,,,,ih; * .s5: ..... i598X&amp;&amp;A&amp;AAAAAA&amp;XG851r: ........,,,,:,,sh; * . ihr, ... . .. ........,,,,,;11:. * ,s1i. ... ..,,,..,,,.,,.,,.,.. ........,,.,,.;s5i. * .:s1r,...................... ..............;shs, * . .:shr:. .... ..............,ishs. * .,issr;,... ...........................,is1s;. * .,is1si;:,....................,:;ir1sr;, * ..:isssssrrii;::::::;;iirsssssr;:.. * .,::iiirsssssssssrri;;:. */ 狗头212345678910111213141516171819202122232425262728293031323334353637383940/*** * ii. ;9ABH, * SA391, .r9GG35&amp;G * &amp;#ii13Gh; i3X31i;:,rB1 * iMs,:,i5895, .5G91:,:;:s1:8A * 33::::,,;5G5, ,58Si,,:::,sHX;iH1 * Sr.,:;rs13BBX35hh11511h5Shhh5S3GAXS:.,,::,,1AG3i,GG * .G51S511sr;;iiiishS8G89Shsrrsh59S;.,,,,,..5A85Si,h8 * :SB9s:,............................,,,.,,,SASh53h,1G. * .r18S;..,,,,,,,,,,,,,,,,,,,,,,,,,,,,,....,,.1H315199,rX, * ;S89s,..,,,,,,,,,,,,,,,,,,,,,,,....,,.......,,,;r1ShS8,;Xi * i55s:.........,,,,,,,,,,,,,,,,.,,,......,.....,,....r9&amp;5.:X1 * 59;.....,. .,,,,,,,,,,,... .............,..:1;.:&amp;s * s8,..;53S5S3s. .,,,,,,,.,.. i15S5h1:.........,,,..,,:99 * 93.:39s:rSGB@A; ..,,,,..... .SG3hhh9G&amp;BGi..,,,,,,,,,,,,.,83 * G5.G8 9#@@@@@X. .,,,,,,..... iA9,.S&amp;B###@@Mr...,,,,,,,,..,.;Xh * Gs.X8 S@@@@@@@B:..,,,,,,,,,,. rA1 ,A@@@@@@@@@H:........,,,,,,.iX: * ;9. ,8A#@@@@@@#5,.,,,,,,,,,... 9A. 8@@@@@@@@@@M; ....,,,,,,,,S8 * X3 iS8XAHH8s.,,,,,,,,,,...,..58hH@@@@@@@@@Hs ...,,,,,,,:Gs * r8, ,,,...,,,,,,,,,,..... ,h8XABMMHX3r. .,,,,,,,.rX: * :9, . .:,..,:;;;::,.,,,,,.. .,,. ..,,,,,,.59 * .Si ,:.i8HBMMMMMB&amp;5,.... . .,,,,,.sMr * SS :: h@@@@@@@@@@#; . ... . ..,,,,iM5 * 91 . ;:.,1&amp;@@@@@@MXs. . .,,:,:&amp;S * hS .... .:;,,,i3MMS1;..,..... . . ... ..,:,.99 * ,8; ..... .,:,..,8Ms:;,,,... .,::.83 * s&amp;: .... .sS553B@@HX3s;,. .,;13h. .:::&amp;1 * SXr . ...;s3G99XA&amp;X88Shss11155hi. ,;:h&amp;, * iH8: . .. ,;iiii;,::,,,,,. .;irHA * ,8X5; . ....... ,;iihS8Gi * 1831, .,;irrrrrs&amp;@ * ;5A8r. .:;iiiiirrss1H * :X@H3s....... .,:;iii;iiiiirsrh * r#h:;,...,,.. .,,:;;;;;:::,... .:;;;;;;iiiirrss1 * ,M8 ..,....,.....,,::::::,,... . .,;;;iiiiiirss11h * 8B;.,,,,,,,.,..... . .. .:;;;;iirrsss111h * i@5,:::,,,,,,,,.... . . .:::;;;;;irrrss111111 * 9Bi,:,,,,...... ..r91;;;;;iirrsss1ss1111 */ 滑稽笑脸12345678910111213141516171819202122232425262728293031323334/*** * .,, .,:;;iiiiiiiii;;:,,. .,, * rGB##HS,.;iirrrrriiiiiiiiiirrrrri;,s&amp;##MAS, * r5s;:r3AH5iiiii;;;;;;;;;;;;;;;;iiirXHGSsiih1, * .;i;;s91;;;;;;::::::::::::;;;;iS5;;;ii: * :rsriii;;r::::::::::::::::::::::;;,;;iiirsi, * .,iri;;::::;;;;;;::,,,,,,,,,,,,,..,,;;;;;;;;iiri,,. * ,9BM&amp;, .,:;;:,,,,,,,,,,,hXA8: ..,,,. * ,;&amp;@@#r:;;;;;::::,,. ,r,,,,,,,,,,iA@@@s,,:::;;;::,,. .;. * :ih1iii;;;;;::::;;;;;;;:,,,,,,,,,,;i55r;;;;;;;;;iiirrrr,.. * .ir;;iiiiiiiiii;;;;::::::,,,,,,,:::::,,:;;;iiiiiiiiiiiiri * iriiiiiiiiiiiiiiii;;;::::::::::::::::;;;iiiiiiiiiiiiiiiir; * ,riii;;;;;;;;;;;;;:::::::::::::::::::::::;;;;;;;;;;;;;;iiir. * iri;;;::::,,,,,,,,,,:::::::::::::::::::::::::,::,,::::;;iir: * .rii;;::::,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,::::;;iri * ,rii;;;::,,,,,,,,,,,,,:::::::::::,:::::,,,,,,,,,,,,,:::;;;iir. * ,rii;;i::,,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,,::i;;iir. * ,rii;;r::,,,,,,,,,,,,,:,:::::,:,:::::::,,,,,,,,,,,,,::;r;;iir. * .rii;;rr,:,,,,,,,,,,,,,,:::::::::::::::,,,,,,,,,,,,,:,si;;iri * ;rii;:1i,,,,,,,,,,,,,,,,,,:::::::::,,,,,,,,,,,,,,,:,ss:;iir: * .rii;;;5r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,sh:;;iri * ;rii;:;51,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.:hh:;;iir, * irii;::hSr,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,sSs:;;iir: * irii;;:iSSs:.,,,,,,,,,,,,,,,,,,,,,,,,,,,..:135;:;;iir: * ;rii;;:,r535r:...,,,,,,,,,,,,,,,,,,..,;sS35i,;;iirr: * :rrii;;:,;1S3Shs;:,............,:is533Ss:,;;;iiri, * .;rrii;;;:,;rhS393S55hh11hh5S3393Shr:,:;;;iirr: * .;rriii;;;::,:;is1h555555h1si;:,::;;;iirri:. * .:irrrii;;;;;:::,,,,,,,,:::;;;;iiirrr;, * .:irrrriiiiii;;;;;;;;iiiiiirrrr;,. * .,:;iirrrrrrrrrrrrrrrrri;:. * ..,:::;;;;:::,,. */ 键盘1234567891011121314151617/*** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ */ 佛祖保佑123456789101112131415161718192021222324/*** * _ooOoo_ * o8888888o * 88" . "88 * (| -_- |) * O\ = /O * ____/`---'\____ * . ' \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| ''\---/'' | | * \ .-\__ `-` ___/-. / * ___`. .' /--.--\ `. . __ * ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-'====== * `=---=' * * ............................................. * 佛祖保佑 永无BUG */ 佛曰123456789101112/*** * 佛曰: * 写字楼里写字间，写字间里程序员； * 程序人员写程序，又拿程序换酒钱。 * 酒醒只在网上坐，酒醉还来网下眠； * 酒醉酒醒日复日，网上网下年复年。 * 但愿老死电脑间，不愿鞠躬老板前； * 奔驰宝马贵者趣，公交自行程序员。 * 别人笑我忒疯癫，我笑自己命太贱； * 不见满街漂亮妹，哪个归得程序员？ */ 佛祖瘫痪1234567891011121314151617181920212223/*** * _ooOoo_ * o8888888o * 88" . "88 * (| -_- |) * O\ = /O * ___/`---'\____ * . ' \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| ''\---/'' | | * \ .-\__ `-` ___/-. / * ___`. .' /--.--\ `. . __ * ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-'====== * `=---=' * ............................................. * 佛曰：bug泛滥，我已瘫痪！ */ Fuck Bug12345678910111213/*** * * █████▒█ ██ ▄████▄ ██ ▄█▀ ██████╗ ██╗ ██╗ ██████╗ * ▓██ ▒ ██ ▓██▒▒██▀ ▀█ ██▄█▒ ██╔══██╗██║ ██║██╔════╝ * ▒████ ░▓██ ▒██░▒▓█ ▄ ▓███▄░ ██████╔╝██║ ██║██║ ███╗ * ░▓█▒ ░▓▓█ ░██░▒▓▓▄ ▄██▒▓██ █▄ ██╔══██╗██║ ██║██║ ██║ * ░▒█░ ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄ ██████╔╝╚██████╔╝╚██████╔╝ * ▒ ░ ░▒▓▒ ▒ ▒ ░ ░▒ ▒ ░▒ ▒▒ ▓▒ ╚═════╝ ╚═════╝ ╚═════╝ * ░ ░░▒░ ░ ░ ░ ▒ ░ ░▒ ▒░ * ░ ░ ░░░ ░ ░ ░ ░ ░░ ░ * ░ ░ ░ ░ ░ */ 哭脸神兽12345678910111213141516171819202122232425/*** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ ─┬┘ └┬─ │ * │ │ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! */ 害羞神兽12345678910111213141516171819202122232425/*** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ &gt; &lt; │ * │ │ * │ ... ⌒ ... │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! */ 墨镜神兽12345678910111213141516171819202122232425/*** * ┌─┐ ┌─┐ + + * ┌──┘ ┴───────┘ ┴──┐++ * │ │ * │ ─── │++ + + + * ███████───███████ │+ * │ │+ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ + + * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ + + + + * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ + + + + * 神兽保佑 * 代码无BUG! */ 蝙蝠123456789101112131415161718192021/*** * ___====-_ _-====___ * _--^^^#####// \\#####^^^--_ * _-^##########// ( ) \\##########^-_ * -############// |\^^/| \\############- * _/############// (@::@) \\############\_ * /#############(( \\// ))#############\ * -###############\\ (oo) //###############- * -#################\\ / VV \ //#################- * -###################\\/ \//###################- * _#/|##########/\######( /\ )######/\##########|\#_ * |/ |#/\#/\#/\/ \#/\##\ | | /##/\#/ \/\#/\#/\#| \| * ` |/ V V ` V \#\| | | |/#/ V ' V V \| ' * ` ` ` ` / | | | | \ ' ' ' ' * ( | | | | ) * __\ | | | | /__ * (vvv(VVV)(VVV)vvv) * 神兽保佑 * 代码无BUG! */ 飞天龙123456789101112131415161718192021222324/*** * * * __----~~~~~~~~~~~------___ * . . ~~//====...... __--~ ~~ * -. \_|// |||\\ ~~~~~~::::... /~ * ___-==_ _-~o~ \/ ||| \\ _/~~- * __---~~~.==~||\=_ -_--~/_-~|- |\\ \\ _/~ * _-~~ .=~ | \\-_ '-~7 /- / || \ / * .~ .~ | \\ -_ / /- / || \ / * / ____ / | \\ ~-_/ /|- _/ .|| \ / * |~~ ~~|--~~~~--_ \ ~==-/ | \~--===~~ .\ * ' ~-| /| |-~\~~ __--~~ * |-~~-_/ | | ~\_ _-~ /\ * / \ \__ \/~ \__ * _--~ _/ | .-~~____--~-/ ~~==. * ((-&gt;/~ '.|||' -_| ~~-/ , . _|| * -_ ~\ ~~---l__i__i__i--~~_/ * _-~-__ ~) \--______________--~~ * //.-~~~-~_--~- |-------~~~~~~~~ * //.-~~~--\ * 神兽保佑 * 代码无BUG! */ 猪123456789101112131415/*** _ * _._ _..._ .-', _.._(`)) * '-. ` ' /-._.-' ',/ * ) \ '. * / _ _ | \ * | a a / | * \ .-. ; * '-('' ).-' ,' ; * '-; | .' * \ \ / * | 7 .__ _.-\ \ * | | | ``/ /` / * /,_| | /,_/ / * /,_/ '`-' */ 骷髅头123456789101112131415161718192021222324/*** ************************************************************** * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * | ______ | * * | .-" "-. | * * | / \ | * * | _ | | _ | * * | ( \ |, .-. .-. ,| / ) | * * | &gt; "=._ | )(__/ \__)( | _.=" &lt; | * * | (_/"=._"=._ |/ /\ \| _.="_.="\_) | * * | "=._"(_ ^^ _)"_.=" | * * | "=\__|IIIIII|__/=" | * * | _.="| \IIIIII/ |"=._ | * * | _ _.="_.="\ /"=._"=._ _ | * * | ( \_.="_.=" `--------` "=._"=._/ ) | * * | &gt; _.=" "=._ &lt; | * * | (_/ \_) | * * | | * * '-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=' * * * * LASCIATE OGNI SPERANZA, VOI CH'ENTRATE * ************************************************************** */ 妈妈再爱我一次123456789101112131415161718192021222324252627282930313233/*** * ,s555SB@@&amp; * :9H####@@@@@Xi * 1@@@@@@@@@@@@@@8 * ,8@@@@@@@@@B@@@@@@8 * :B@@@@X3hi8Bs;B@@@@@Ah, * ,8i r@@@B: 1S ,M@@@@@@#8; * 1AB35.i: X@@8 . SGhr ,A@@@@@@@@S * 1@h31MX8 18Hhh3i .i3r ,A@@@@@@@@@5 * ;@&amp;i,58r5 rGSS: :B@@@@@@@@@@A * 1#i . 9i hX. .: .5@@@@@@@@@@@1 * sG1, ,G53s. 9#Xi;hS5 3B@@@@@@@B1 * .h8h.,A@@@MXSs, #@H1: 3ssSSX@1 * s ,@@@@@@@@@@@@Xhi, r#@@X1s9M8 .GA981 * ,. rS8H#@@@@@@@@@@#HG51;. .h31i;9@r .8@@@@BS;i; * .19AXXXAB@@@@@@@@@@@@@@#MHXG893hrX#XGGXM@@@@@@@@@@MS * s@@MM@@@hsX#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;, * :GB@#3G@@Brs ,1GM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B, * .hM@@@#@@#MX 51 r;iSGAM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8 * :3B@@@@@@@@@@@&amp;9@h :Gs .;sSXH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: * s&amp;HA#@@@@@@@@@@@@@@M89A;.8S. ,r3@@@@@@@@@@@@@@@@@@@@@@@@@@@r * ,13B@@@@@@@@@@@@@@@@@@@5 5B3 ;. ;@@@@@@@@@@@@@@@@@@@@@@@@@@@i * 5#@@#&amp;@@@@@@@@@@@@@@@@@@9 .39: ;@@@@@@@@@@@@@@@@@@@@@@@@@@@; * 9@@@X:MM@@@@@@@@@@@@@@@#; ;31. H@@@@@@@@@@@@@@@@@@@@@@@@@@: * SH#@B9.rM@@@@@@@@@@@@@B :. 3@@@@@@@@@@@@@@@@@@@@@@@@@@5 * ,:. 9@@@@@@@@@@@#HB5 .M@@@@@@@@@@@@@@@@@@@@@@@@@B * ,ssirhSM@&amp;1;i19911i,. s@@@@@@@@@@@@@@@@@@@@@@@@@@S * ,,,rHAri1h1rh&amp;@#353Sh: 8@@@@@@@@@@@@@@@@@@@@@@@@@#: * .A3hH@#5S553&amp;@@#h i:i9S #@@@@@@@@@@@@@@@@@@@@@@@@@A. * * * 又看源码，看你妹妹呀！ */ 初音12345678910111213141516171819202122232425/*** *_______________#########_______________________ *______________############_____________________ *______________#############____________________ *_____________##__###########___________________ *____________###__######_#####__________________ *____________###_#######___####_________________ *___________###__##########_####________________ *__________####__###########_####_______________ *________#####___###########__#####_____________ *_______######___###_########___#####___________ *_______#####___###___########___######_________ *______######___###__###########___######_______ *_____######___####_##############__######______ *____#######__#####################_#######_____ *____#######__##############################____ *___#######__######_#################_#######___ *___#######__######_######_#########___######___ *___#######____##__######___######_____######___ *___#######________######____#####_____#####____ *____######________#####_____#####_____####_____ *_____#####________####______#####_____###______ *______#####______;###________###______#________ *________##_______####________####______________ */ 攻城湿123456789101112131415161718192021/*** * ,%%%%%%%%, * ,%%/\%%%%/\%% * ,%%%\c "" J/%%% * %. %%%%/ o o \%%% * `%%. %%%% _ |%%% * `%% `%%%%(__Y__)%%' * // ;%%%%`\-/%%%' * (( / `%%%%%%%' * \\ .' | * \\ / \ | | * \\/ ) | | * \ /_ | |__ * (___________))))))) 攻城湿 * * _ _ * __ _(_)_ _(_) __ _ _ __ * \ \ / / \ \ / / |/ _` |'_ \ * \ V /| |\ V /| | (_| | | | | * \_/ |_| \_/ |_|\__,_|_| |_| */ 掘金1234567891011121314151617181920212223/*** * https://gold.xitu.io/ * １１１ １ * １１１ １１１１１１１１１１１１ １１１ * １１ １１１１１１１１１１１１ １１１１１ * １１ １１１ １１ １１１１１１１ * １１１１ １ １１１１１１１１１１１ １１１ １１１１ * １１１１１１ １１１１１１１１１１１ １１１１ １１１１１ * １１１１１１ １１ １１１１ １１１１１１ * １１ １１１１１１１１ １１ １１１１１１１１１１１１１１１１１１ * １１ １１１１１１１１１１１ １１１１１１１１１１１１１１１１１１１ * １１１１１１１１１ １１ １１ １１ １１ * １１１１１１１１１１１１１１１１１１ １１ * １１１１ １１１１１１１１１１１１ １１１１１１１１１１１１１１ * １１１１ １１ １１ １１１１１１１１１１１１１１ * １１ １１ １１ １１ １１１ １１ １１ １１１ * １１ １１ １１ １１ １１ １１１ １１ １１１ * １１ １１１ １１ １１ １１ １１１ １１ １１１ * １１１１ １１１ １１１１１１１１１ １１ １１１ １１ １１１１１１１ * １１１１１１ １１１１１１１１１１ １１１１１１１１１１１１１１１１１ * １１ １１１ １１１ １１１１１１１１１１１１１１１１１ */ 知乎123456789101112131415161718192021222324/*** * https://www.zhihu.com/ * _____ _____ _____ _____ * /\ \ /\ \ /\ \ /\ \ * /::\____\ /::\ \ /::\ \ /::\ \ * /:::/ / \:::\ \ /::::\ \ /::::\ \ * /:::/ / \:::\ \ /::::::\ \ /::::::\ \ * /:::/ / \:::\ \ /:::/\:::\ \ /:::/\:::\ \ * /:::/____/ \:::\ \ /:::/__\:::\ \ /:::/__\:::\ \ * /::::\ \ /::::\ \ /::::\ \:::\ \ /::::\ \:::\ \ * /::::::\ \ _____ ____ /::::::\ \ /::::::\ \:::\ \ /::::::\ \:::\ \ * /:::/\:::\ \ /\ \ /\ \ /:::/\:::\ \ /:::/\:::\ \:::\____\ /:::/\:::\ \:::\ \ * /:::/ \:::\ /::\____\/::\ \/:::/ \:::\____\/:::/ \:::\ \:::| |/:::/__\:::\ \:::\____\ * \::/ \:::\ /:::/ /\:::\ /:::/ \::/ /\::/ |::::\ /:::|____|\:::\ \:::\ \::/ / * \/____/ \:::\/:::/ / \:::\/:::/ / \/____/ \/____|:::::\/:::/ / \:::\ \:::\ \/____/ * \::::::/ / \::::::/ / |:::::::::/ / \:::\ \:::\ \ * \::::/ / \::::/____/ |::|\::::/ / \:::\ \:::\____\ * /:::/ / \:::\ \ |::| \::/____/ \:::\ \::/ / * /:::/ / \:::\ \ |::| ~| \:::\ \/____/ * /:::/ / \:::\ \ |::| | \:::\ \ * /:::/ / \:::\____\ \::| | \:::\____\ * \::/ / \::/ / \:| | \::/ / * \/____/ \/____/ \|___| \/____/ */ freebuf1234567891011121314151617181920212223242526272829/*** * http://www.freebuf.com/ * _.._ ,------------. * ,' `. ( We want you! ) * / __) __` \ `-,----------' * ( (`-`(-') ) _.-' * /) \ = / ( * /' |--' . \ * ( ,---| `-.)__` * )( `-.,--' _`-. * '/,' ( Uu", * (_ , `/,-' ) * `.__, : `-'/ /`--' * | `--' | * ` `-._ / * \ ( * /\ . \. freebuf * / |` \ ,-\ * / \| .) / \ * ( ,'|\ ,' : * | \,`.`--"/ &#125; * `,' \ |,' / * / "-._ `-/ | * "-. "-.,'| ; * / _/["---'""] * : / |"- ' * ' | / * ` | */ Alibaba12345678910111213141516171819202122232425262728293031323334353637/*** * https://campus.alibaba.com/ * `:::::::::::, * `::;:::::::;:::::::, ` * `::;;:::::::@@@@;:::::::` * ,:::::::::::::@ #@':::::` * :::::::::::::::'@@ @;:::: * ::::::::::::'@@@@'``` .+:::` * ::::::::::;@@@#. ,:::, * .::::::::+@#@` :::: * :::::::+@@' :::: * `:::::'@@: `:::. * ,::::@@: ` :::: * ;::::::@ .:::; * :;:::::;@` ` :::; * :::::::::@` @ ;:::: * :::::::::#` @` ,:::: * :::::::::@` +@ @ .::::` * .::::::'@@` `@@' @ ::::, * :::::::++@@@@@@@@@@. ::::; * ;:::::::+, `..` ::::: * ,::::::::', ::::: * :::::::::+, :::::` * :::::::::+@. ,::::.` `, * ::::::;;@+ .::;:: `; * :::::::@@ `:::;: `::`` * ::::::#@ ;:::: .::` * :::::;@ :::::` .;::` * :::::@ `:;::: `::::; * :::::# :::::. `,;::::: * :::::: ` ::::::,.,::::::::::. * ,::::::` .:: ::::::::::::::::;` * ;::::::::,````.,:::::, ::::::::::::::. * :::::::::::::::::: ` `::::::::::` * `::::::::::::, .:::. * `..` */ 小老鼠123456789101112131415/*** * http://www.flvcd.com/ * .--, .--, * ( ( \.---./ ) ) * '.__/o o\__.' * &#123;= ^ =&#125; * &gt; - &lt; * / \ * // \\ * //| . |\\ * "'\ /'"_.-~^`'-. * \ _ /--' ` * ___)( )(___ * (((__) (__))) 高山仰止,景行行止.虽不能至,心向往之。 */ 顶12345678910111213141516/*** * 頂頂頂頂頂頂頂頂頂 頂頂頂頂頂頂頂頂頂 * 頂頂頂頂頂頂頂 頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂頂 * 頂頂 頂頂 頂頂 頂頂 * 頂頂頂頂 頂頂頂頂頂 頂頂頂頂頂 * 頂頂頂頂 頂頂頂頂 頂頂頂頂 */ 单身狗的凝视123456789101112131415/*** * ░░░░░░░░░░░░░░░░░░░░░░░░▄░░ * ░░░░░░░░░▐█░░░░░░░░░░░▄▀▒▌░ * ░░░░░░░░▐▀▒█░░░░░░░░▄▀▒▒▒▐ * ░░░░░░░▐▄▀▒▒▀▀▀▀▄▄▄▀▒▒▒▒▒▐ * ░░░░░▄▄▀▒░▒▒▒▒▒▒▒▒▒█▒▒▄█▒▐ * ░░░▄▀▒▒▒░░░▒▒▒░░░▒▒▒▀██▀▒▌ * ░░▐▒▒▒▄▄▒▒▒▒░░░▒▒▒▒▒▒▒▀▄▒▒ * ░░▌░░▌█▀▒▒▒▒▒▄▀█▄▒▒▒▒▒▒▒█▒▐ * ░▐░░░▒▒▒▒▒▒▒▒▌██▀▒▒░░░▒▒▒▀▄ * ░▌░▒▄██▄▒▒▒▒▒▒▒▒▒░░░░░░▒▒▒▒ * ▀▒▀▐▄█▄█▌▄░▀▒▒░░░░░░░░░░▒▒▒ * 单身狗就这样默默地看着你，一句话也不说。 */ 埃及法老1234567891011121314151617181920212223242526272829303132333435/*** * /88888888888888888888888888\ * |88888888888888888888888888/ * |~~____~~~~~~~~~"""""""""| * / \_________/"""""""""""""\ * / | \ \ * / | 88 88 \ \ * / | 88 88 \ \ * / / \ | * / | ________ \ | * \ | \______/ / | * /"\ \ \____________ / | * | |__________\_ | | / / * /""""\ \_------' '-------/ -- * \____/,___________\ -------/ * ------* | \ * || | \ * || | ^ \ * || | | \ \ * || | | \ \ * || | | \ \ * \| / /"""\/ / * ------------- | | / * |\--_ \____/___/ * | |\-_ | * | | \_ | * | | \ | * | | \_ | * | | ----___ | * | | \----------| * / | | ----------""\ * /"\--"--_| | | \ * |_______/ \______________/ ) * \___/ */ 耶123456789101112131415161718192021222324252627282930313233343536/*** * d*##$. * zP"""""$e. $" $o * 4$ '$ $" $ * '$ '$ J$ $F * 'b $k $&gt; $ * $k $r J$ d$ * '$ $ $" $~ * '$ "$ '$E $ * $ $L $" $F ... * $. 4B $ $$$*"""*b * '$ $. $$ $$ $F * "$ R$ $F $" $ * $k ?$ u* dF .$ * ^$. $$" z$ u$$$$e * #$b $E.dW@e$" ?$ * #$ .o$$# d$$$$c ?F * $ .d$$#" . zo$&gt; #$r .uF * $L .u$*" $&amp;$$$k .$$d$$F * $$" ""^"$$$P"$P9$ * JP .o$$$$u:$P $$ * $ ..ue$" "" $" * d$ $F $ * $$ ....udE 4B * #$ """"` $r @$ * ^$L '$ $F * RN 4N $ * *$b d$ * $$k $F * $$b $F * $"" $F * '$ $ * $L $ * '$ $ * $ $ */ 台式电脑1234567891011121314151617181920/*** * ,----------------, ,---------, * ,-----------------------, ," ,"| * ," ,"| ," ," | * +-----------------------+ | ," ," | * | .-----------------. | | +---------+ | * | | | | | | -==----'| | * | | I LOVE DOS! | | | | | | * | | Bad command or | | |/----|`---= | | * | | C:\&gt;_ | | | ,/|==== ooo | ; * | | | | | // |(((( [33]| ," * | `-----------------' |," .;'| |(((( | ," * +-----------------------+ ;; | | |," * /_)______________(_/ //' | +---------+ * ___________________________/___ `, * / oooooooooooooooo .o. oooo /, \,"----------- * / ==ooooooooooooooo==.o. ooo= // ,`\--&#123;)B ," * /_==__==========__==_ooo__ooo=_/' /___________," * */ 书本123456789101112/*** * .-~~~~~~~~~-._ _.-~~~~~~~~~-. * __.' ~. .~ `.__ * .'// \./ \\`. * .'// | \\`. * .'// .-~"""""""~~~~-._ | _,-~~~~"""""""~-. \\`. * .'//.-" `-. | .-' "-.\\`. * .'//______.============-.. \ | / ..-============.______\\`. * .'______________________________\|/______________________________`. * */ 人生12345678910111213141516171819202122/** * 出生 * || * || * \ / * \/ * 青年 * （年龄 = rand(20,25))） 《============== * || || * || || * || 祝福所有开发工作者 || * || 永远年轻 || * || || * \ / || * \/ || *（ 20 &lt;= 年龄 &lt;= 25） =============== * || * || * \ / * \/ * 等死状态 */ 比克大魔王12345678910111213141516171819202122232425/* _.---..._ ./^ ^-._ ./^C===. ^\. /\ .|' \\ _ ^|.^.| ___.--'_ ( ) . ./ /|| /.---^T\ , | / /||| C' ._`| ._ / __,-/ / /-,|| \ \/ ; /O / _ |) )|, i \./^O\./_,-^/^ ,;-^,' \ |`--/ ..-^^ |_-^ `| \^- /|: i. .-- / '|. i ==' /' |\._ _./`._ // |. ^-ooo.._ _.oo../' | ^-.__./X/ . `| |#######b d#### |' ^^^^ / | _\####### #####b ^^^^^^^^--. ...--^--^^^^^^^_.d###### ######b._ Y _.d######### ##########b._ | _.d############# "Piccolo" no. 2 (from Dragonball Z) --- Steven J. Simmons */ Fuck you123456789101112131415161718192021/* * .::::. * .::::::::. * ::::::::::: FUCK YOU * ..:::::::::::' * '::::::::::::' * .:::::::::: * '::::::::::::::.. * ..::::::::::::. * ``:::::::::::::::: * ::::``:::::::::' .:::. * ::::' ':::::' .::::::::. * .::::' :::: .:::::::'::::. * .:::' ::::: .:::::::::' ':::::. * .::' :::::.:::::::::' ':::::. * .::' ::::::::::::::' ``::::. * ...::: ::::::::::::' ``::. * ```` ':. ':::::::::' ::::.. * '.:::::' ':'````.. */ 围棋12345678910111213141516171819202122232425262728293031323334 // _______________________________________ // / ___________________________________ \// _--""""--_ / /_/_/_/_/_|_|_|_|_|_|_|_|_|_\_\_\_\_\ \// / \ / /_/_/_/_J__L_L_L_|_|_|_J_J_J__L_\_\_\_\ \// /\ /\ / /_/_/_J__L_J__L_L_|_|_|_J_J__L_J__L_\_\_\ \// L ""-____-"" J / /_/_J__L_J__L_J_J__L_|_J__L_L_J__L_J__L_\_\ \// \ / / /_/__L_/__L_J__L_J__L_|_J__L_J__L_J__\_J__\_\ \// \_ _/ / /_J__/_J__/__L_J__|__L_|_J__|__L_J__\__L_\__L_\ \// _--"""""--_" / / F / F J J | F J | F J | F F J \ J \ \// / \ / /--/-J--/--L--|--L-J--J--|--L--L-J--|--J--\--L-\--\ \///\ /\ / /__/__L_J__J___L_J__J__|__|__|__L__L_J___L__L_J__\__\ \//L ""-_____-"" J / / / / F F J J | | | | | F F J J \ \ \ \//\ / / /--/--/--/--J---L--|--|--|--o--|--|--|--J---L--\--\--\--\ \// \_ _/ / /__/__J__J___L__J___L__L__L__|__J__J__J___L__J___L__L__\__\ \// "--___--" / / / F F J F J J F | J F F J F J J \ \ \// / /--/---/--J---L--J---L--|--J---|---L--|--J---L--J---L--\---\--\ \// / /__J___/___L__/___L__J___L__J___|___L__J___L__J___\__J___\___L__\ \// / / F J / J J | J J | F F | F F \ F J \ \// / /---/---L--J---L---L---L--|---|---|---|---|--J---J---J---L--J---\---\ \// / /___/___/___L__J___J___J___|___|___|___|___|___L___L___L__J___\___\___\ \// / / / / / F F F F F | J J J J J \ \ \ \ \// / /___/___J___J___J___J___J____L___L___|___J___J____L___L___L___L___L___\___\ \// / / / F F F | | J F | J F | | J J J \ \ \// / /___J____/___/___J____L___L___|___J____|____L___|___J___J____L___\___\____L___\ \// / / F / J F J J | J | F | F F J F \ J \ \// / /____/___J____L___/____L___|____L___|____|____|___J____|___J____\___J____L___\____\ \// / / / F / J J F J F | J F J F F \ J \ \ \// / /____/____/___J____L____|____L___J____L____|____J____L___J____|____J____L___\____\____\ \// / \///_______________________________________________________________________________________________\//| |//| hs |//|_______________________________________________________________________________________________| 居中的佛祖1234567891011121314151617181920212223/* _ooOoo_ o8888888o 88" . "88 (| -_- |) O\ = /O ____/`---'\____ .' \\| |// `. / \\||| : |||// \ / _||||| -:- |||||- \ | | \\\ - /// | | | \_| ''\---/'' | | \ .-\__ `-` ___/-. / ___`. .' /--.--\ `. . __ ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"". | | : `- \`.;`\ _ /`;.`/ - ` : | | \ \ `-. \_ __\ /__ _/ .-` / /======`-.____`-.___\_____/___.-`____.-'====== `=---='^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG*/ windows图标123456789101112131415161718/* __ ,-~¨^ ^¨-, _, / / ;^-._...,¨/ / / / / / / / / / / / / /,.-:''-,_ / / / _,.-:--._ ^ ^:-._ __../ /^ / /¨:.._¨__.; / / / ^ / / / / / / / / / /_,.--:^-._/ / /^ ^¨¨-.___.:^ (R) - G33K */ 七龙珠比克1234567891011121314151617181920212223242526/* /^_.-^ _ --^=_ ./'-^__ _&gt;=\^^==^-. |'/^^_/ /^ \ \.^\\\/\ ,|/| ' /' _____\ `\|.^.| |'/ /_--^^ . ^^-./ /|| |/,--^ , | / /||' ._|/ \ / __,-/ / /-,|| \ '/ ; /O / _ |) )|, i \./^O\./_,-^/^ ,;-^,' \ |`--/ ..-^^ |_-^ `| \^-_,/^Y\ | ^^\ _i. \".--V_/ /| \. ^\._____...--.&gt;^^^^^^-------...._ / i ^--^^ /'|' |\. |./' | ;___...----/^^^^---|. `._\ /^ /' |'_/' \ `| |' ,/' |' \ _|^-.__./'__.^^\ .| ,| _.-^ `\ ,|`_./^^-----^^._ ` ./ / /^ _.-^^/ |' ^ /-^ ./^ /\ `\_ __.-&lt; _,/ ./' |' `\. `i ^^--/._____...--^ . ./ |. `| | / / `| "Piccolo" (from Dragonball Z) --- Steven J. Simmons */ 七龙珠悟空123456789101112131415161718192021222324252627282930313233/* _ \"-._ _.--"~~"--._ \ " ^. ___ / \.-~_.-~ .-----' /\/"\ /~-._ / / __ _/\-.__\L_.-/\ "-. /.-" \ ( ` \_o&gt;"&lt;o_/ \ .--._\ /' \ \: " :/_/ "` / /\ "\ ~ /~" \ I \/]"-._ _.-"[ ___ \|___/ ./ l \___ ___ .--v~ "v` ( `-.__ __.-' ) ~v" ~v--. .-&#123; | : \_ "~" _/ : | &#125;-. / \ | ~-.,___,.-~ | / \ ] \ | | / [ /\ \| : : |/ /\ / ^._ _K.___,^ ^.___,K_ _.^ \ / / "~/ "\ /" \~" \ \ / / / \ _ : _ / \ \ \ .^--./ / Y___________l___________Y \ \.--^. [ \ / | [/ ] | \ / ] | "v" l________[____/]________j -Row &#125;r" / &#125;------t / \ /`-. / | | Y Y / "-._/ &#125;-----v' | : | 7-. / | |_| | l | / . "-._/ l .[_] : \ : r[]/_. / \_____] "--. "-.____/ "Dragonball Z" ---Row */ 超级赛亚人123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/* MMMMM MMMMMM MMMMMMM MMMMMMMM . MMMMMMMMM HMMMMMMMMMM MMMMMMMMMMMM M MMMMMMMMMMMMM M MMMMMMMMMMMMM M MMMMMMMMMMMMM: oMMMMMMMMMMMMMM .MMMMMMMMMMMMMMo MMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMM. oMMMMMMMMMMMMMMM.M MMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM oMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM: H MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM . MMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM M MMMMMM .MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM M MMMMMMMMMM MM. MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM M MMMMMMMMMMMM MM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM .MMMMMMMMMMMMMM MM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM .MMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMM.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM HMMMMMMMMMMMMMMMMMMMMM.MMMMMMMMM.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMM MMM.oMMMMMMM..MMMMMMMMM:MMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMM MM..MMMMMMM...MMMMMMM. MMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMM ..MMMMMM...MMMMMM ..MMMMMMMMMMMMMMMMMMM MMMMMMM:M.MMM.M.. MMMMM M..MMMMM...MMMMMMMMMMMMMMMMMM MMM MMMM. .M..MM.M...MMMMMM..MMMMM.. MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM . MMMM..M....M.....:MMM .MMMMMM..MMMMMMM...MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMM.M.. ...M......MM.MMMMM.......MHM.M .MMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMM..MM. . MMM.....MMMMMM.M.....M ..MM..M MMMMMMMMMMMMMMMMMMM .MMMMMHMM. ..MMMM. MMM............o..... . .MMMMMMMMMMMMMMM MMM. M... .........................M..:.MMMMMMMMMMMM oMMM............ .................M.M.MMMMMMMMM .....MM........................ . MMMMMM M.....M.....................o.MM.MMMMMMMM. M........................M.. ...MMMMMMMMMMMMMo :....MMM..............MMM..oMMMMMMM M...MMM.............MMMMMMM .............:MMMMMMMM M..... MMM.....M M M............. ................M ooM.................MM MoMMMMMoooM MMoooM......................MoooooooH..oMM MHooooMoM.....................MMooooooM........M oooooooMoooM......... o........MoooooooM............ Mooooooooooo.......M.........Moooooooo:..............M MooMoooooooooM...M........:Mooooooooooo:..............M M..oooooooooooo .........Mooooooooooooooo..............M M...Mooo:oooooooo.M....ooooooooooooooooooo..M...........M ...oooooMoooooooM..Mooooooooooooo:oooooooM.M...........M. M...ooooooMoo:ooooMoooooooooooooHoooooooooH:M. ...........: M..MoooooooMoooooooooooooooooo:ooooooMooooMoM..............M M..ooooooooooMooooooooooooooHoooooooMooHooooM...............M ...ooooooooooooooooooo:MooooooooooooooMoMoooM................ M...oooooooooooooooooooooooooooooooooooooMooMM................M ...MooooooooooooooooooooooooooooooooooooooooMo ................ ...MooooooooooooooooooooooooooooooooooooooooM M................M M...ooooooooooooooooooooooooooooooooooooooooM ................M ...MoooooooooooooooooooooooooooooooooooooooMM .:............... .....MooooooooooooooooooooooooooooooooooooMoo .............M M...... ooooooooooooooooooooooooooooooooooooM M..............M M........MooooMMM MM MM MMMMMMMMMooooooooM M...............M .........HM M: MM :MMMMMM M M............... M..........M M MoM M M................M M.........:M MoH M M M MooooHoooMM. M M...............M M..........Moooo MMooM oooooMooooooooM M..............H M.........MooooM Mooo : ooooooMooooMoooM M........ . .o.M H.. .....ooooo oooo M MooooooooooooooM M... MMMMMMMMMMM MMMMMMMMMMooooM M oooo . ooooooMooooooooM .MMMMMMMMMMMMMMM MMMMMMMMMMooooH : ooooH oooooooooooooooo MMMMMMMMMMMMMMM MMMMMMMMMMoooo ooooM Moooooooooooooooo .MMMMMMMMMMMMMMM MMMMMMMMMMoooo ooooM MooooooooooooooooM MMMMMMMMMMMMMMM MMMMMMMMMMoooM ooooM ooooooooooooooooo MMMMMMMMMMM:M MMMMMMMMMMoooM MooooM oooooooooooMoooooo MH........... . ......Mooo. MooooM oooooooooooooooooo M............M M.M......oooo MooooM Moooooooooooooooooo: .........M..... M.M.....Moooo MooooM ooooooooooooooooooM .M............ .......MooooH MooooM oooooooooMoooooooooo M..o...M..o....M .o....HMooooM MooooH MooooooooMooooooooooM .:M...M.......M M..M.....MoooM :oooo: .MooooooooHooMoooooooooM M M... ..oM.M M...M.:.Mooo. MMMMooooo oooooooooooMoooooooooooooM ....M. M M:M..o.Moooooooooooooo MooooooooooooooMooooooooooooM .Mo MooooooooooooooMooooooooooooMoMoooooooooooooo Mooooooooooooooo:ooooooooooooooooooooooooooooo ooooooooooooooooMooooooooooMoooooooooooooooooo ooooooooooooooooMoooooooooooMooooooooooooooooHo ooMooooooooooooooMoooooooooooooooooooooooooooMoM MooMoooooooooooooo.ooooooooooooooooooooooooooo:oM MoooooooooooooooooooooooooooooooooooooooooooooooM MoooMooooooooooooooMooooooooooooooooooooooooooooo. MoooMooooooooooooooMoooooooooooooooooooooooooMooooM MooooooooooooooooooMoooooooooooooooooooooooooMoooooM MooooMoooooooooooooMoooooooooooooooooooooooooMoHooooM ooooooMooooooooooooooooooooooooooooooooooooooooMoMoooM MooooooooooooooooooooMooooooooooooooooooooooooooMoooooH: MoooooooMooooooooooooMoooooooooooooooooooooooooooooHoooM MooooooooMoooooooooooMoooooooooooooooooooooooooMoooMooooM Moooooooooooooooooooooooooooooooooooooooooooooo.oooMooooo MoooooooooooooooooooooooooooooooooooooooooooooMoooooooooM MooooooooooooooooooooMoooooooooooooooooooooooooooooooooM MooooooooooooooooooooMHooooooooooooooooooooMoooo:ooooo MMooooooooooooooooooMoMHoooooooooooooooooooooooMooooo MMoooooooooooooooMMooo MMooooooooooooooooooooooooooM MMMoooooooooooooMooooo oooooooooooooooooooooMooooo MooMMoooooooooMoooMMoM ooooHooooooooooooooooMooooM MooooMooooooMooooMoooM MoooooMoooooooooooooMooooo ooooooMMooooooooMooooM MoooooooooMooooooooooooooM HooooooMoooooooMooooM HoooooooHooMooooooooooooo oooMoooooooooHoooM MoooooooooMoooooooooM HooooooooooooHM MooooooooMMoooooooM MMMMMMMMMMMMMM Moooooo:MooooHMM MMMMMMM: ... MMMMMMMMMMMMMM M............M MMMMMMMMM .... M.MM.......... M.............M M ..............MM M.............. MMMMM............MMMM ..MMMMMMMM ....M MMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMM...M .MMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMM :MMMMMMMMMMMMMMMMMMH MMMMMMMMMMMMMMMMMMM By EBEN Jérôme MMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMM HMMMMMM */ 皮卡丘123456789101112131415161718192021222324252627282930313233343536373839404142/*quu..__ $$$b `---.__ "$$b `--. ___.---uuudP `$$b `.__.------.__ __.---' $$$$" . "$b -' `-.-' $$$" .'| ". d$" _.' | `. / ..." .' | `./ ..::-' _.' | / .:::-' .-' .' : ::''\ _.' | .' .-. .-. `. .' | : /'$$| .@"$\ `. .' _.-' .'|$u$$| |$$,$$| | &lt; _.-' | `:$$:' :$$$$$: `. `. .-' : `"--' | `-. \ :##. == .###. `. `. `\ |##: :###: | &gt; &gt; |#' `..'`..' `###' x: / / \ xXX| / ./ \ xXXX'| / ./ /`-. `. / / : `- ..........., | / .' | ``:::::::' . |&lt; `. | ``` | x| \ `.:``. | .' /' xXX| `:`M`M':. | | ; /:' xXXX'| -'MMMMM:' `. .' : /:' |-'MMMM.-' | | .' /' .'MMM.-' `'`' : ,' |MMM&lt; | `' |tbap\ \ :MM.-' \ | .'' \. `. / / .:::::::.. : / | .:::::::::::`. / | .:::------------\ / / .'' &gt;::' / `',: : .' `:.:' */]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkdownPad发生HTML渲染组件出错]]></title>
    <url>%2FMarkdownPad%E5%8F%91%E7%94%9FHTML%E6%B8%B2%E6%9F%93%E7%BB%84%E4%BB%B6%E5%87%BA%E9%94%99.html</url>
    <content type="text"><![CDATA[在安装破解MarkdownPad之后，新建一个文档准备练习下MarkdownPad的使用，结果，很不幸地出现了下面的错误： 根据它的提示跳转到官网上查看了一番，表示很懵逼…. 最终还是借助强大的百度搜到其他小伙伴也遇到过这个问题，现将解决方案总结如下。 下载这个东东： Awesomium 1.6.6 SDK 下载完成后双击exe安装文件开始安装，点击Next： 勾选“I accept the terms in the License Agreement”，点击Next 勾选“Yes,remove the older version.”，点击Next 安装路径可以使用默认的安装路径，也可以更改安装路径，然后选择Typical标准套餐 点击Install开始安装 安装完成Finsh 然后重启MarkdownPad，问题解决。]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkdownPad正版破解与汉化]]></title>
    <url>%2FMarkdownPad%E6%AD%A3%E7%89%88%E7%A0%B4%E8%A7%A3%E4%B8%8E%E6%B1%89%E5%8C%96.html</url>
    <content type="text"><![CDATA[下载先去官网：http://markdownpad.com/ 下载MarkdownPad，如下图： 安装安装过程很简单，一路NexT下去，可使用默认的安装目录，也可以自定义安装目录，这里不做截图展示。 汉化安装完成后，启动MarkdownPad，在工具栏上面点击Tools-Options，如下图： 在打开的页面下方有个languages的选项，点击English的选项卡弹出选择窗，选中文，点击save and close按钮后就可以看到中文效果，并弹窗“需要重新启动 MarkdownPad”的提示。如下图： 破解注册码1GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 邮箱地址Soar360@live.com 使用方式点击帮助-专业版激活在弹出的小窗口输入邮箱Soar360@live.com 授权密钥粘贴上面的注册码.点击确定就激活。现在是2019年5月18日，目前依然有效。]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
