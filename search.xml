<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis为什么这么快]]></title>
    <url>%2F2019%2F08%2F09%2FRedis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB.html</url>
    <content type="text"><![CDATA[前言Redis本质上是一个基于键值对(Key-Value)类型的内存数据库，Redis的Value可以由String，hash，list，set，zset，Bitmaps，HyperLogLog等多种数据结构和算法组成。整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。可用于缓存、事件发布或订阅、高速队列等场景。该数据库使用ANSI C语言编写，支持网络，提供字符串、哈希、列表、队列、集合结构直接存取，基于内存，可持久化。Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。官方给出的性能可以达到10W+qps，那么Redis到底快在哪呢？ 开发语言现在我们都用高级语言来编程，比如Java、python等。也许你会觉得C语言很古老，但是它真的很有用，毕竟unix系统就是用C实现的，所以C语言是非常贴近操作系统的语言。Redis就是用C语言开发的，所以执行会比较快。 纯内存访问Redis将所有数据放在内存中，非数据同步正常工作中，是不需要从磁盘读取数据的，0次IO。内存响应时间大约为100纳秒，这是Redis速度快的重要基础。 单线程第一，单线程简化算法的实现，并发的数据结构实现不但困难且测试也麻烦。第二，单线程避免了线程切换以及加锁释放锁带来的消耗，对于服务端开发来说，锁和线程切换通常是性能杀手。 当然了，单线程也会有它的缺点，也是Redis的噩梦：阻塞。如果执行一个命令过长，那么会造成其他命令的阻塞，对于Redis是十分致命的，所以Redis是面向快速执行场景的数据库。 除了Redis之外，Node.js也是单线程，Nginx也是单线程，但他们都是服务器高性能的典范。 非阻塞多路I/O复用机制先说一下传统的阻塞I/O是如何工作的：当使用read或者write对某一文件描述符（File Descriptor FD）进行读写的时候，如果数据没有收到，那么该线程会被挂起，直到收到数据。阻塞模型虽然易于理解，但是在需要处理多个客户端任务的时候，不会使用阻塞模型。 I/O多路复用实际上是指多个连接的管理可以在同一进程。多路是指网络连接，复用只是同一个线程。在网络服务中，I/O多路复用起的作用是一次性把多个连接的事件通知业务代码处理，处理的方式由业务代码来决定。在I/O多路复用模型中，最重要的函数调用就是I/O 多路复用函数，该方法能同时监控多个文件描述符（fd）的读写情况，当其中的某些fd可读/写时，该方法就会返回可读/写的fd个数。 Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll的read、write、close等都转换成事件，不在网络I/O上浪费过多的时间。实现对多个FD读写的监控，提高性能。 举个例子:比如一个tcp服务器处理20个客户端socket。A方案：顺序处理，如果第一个socket因为网卡读数据处理慢了，一阻塞，后面都玩蛋去。 B方案：每个socket请求都创建一个分身子进程来处理，不说每个进程消耗大量系统资源，光是进程切换就够操作系统累的了。 C方案（I/O复用模型，epoll）：将用户socket对应的fd注册进epoll（实际上服务器和操作系统之间传递的不是socket的fd而是fd_set的数据结构），然后epoll只告诉哪些需要读/写的socket，只需要处理那些活跃的、有变化的socket fd的就好了。这样，整个过程只在调用epoll的时候才会阻塞，收发客户消息是不会阻塞的。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Spring中的注解]]></title>
    <url>%2F2019%2F08%2F09%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3.html</url>
    <content type="text"><![CDATA[概述Spring中的注解大概可以分为两类： Spring的bean容器相关的注解，或者说bean工厂相关的注解； Springmvc相关的注解。 Spring的bean容器相关的注解有：@Required,@Autowired,@PostConstruct,@PreDestory,还有Spring3.0开始支持的JSR-330标准javax.inject.*中的注解：@Inject,@Named,@Qualifer,@Provider,@Scope,@Singleton。 Springmvc相关的注解有：@Controller,@RequestMapping,@RequestParam,@ResponseBody等等。 要理解Spring中的注解，先要理解Java中的注解。 Java中的注解@OverrideJdk1.5开始引入注解，最熟悉常见的应该是@Override，它的定义如下：12345678910111213141516171819/** * Indicates that a method declaration is intended to override a * method declaration in a supertype. If a method is annotated with * this annotation type compilers are required to generate an error * message unless at least one of the following conditions hold: * The method does override or implement a method declared in a * supertype. * The method has a signature that is override-equivalent to that of * any public method declared in Object. * * @author Peter von der Ah&amp;eacute; * @author Joshua Bloch * @jls 9.6.1.4 @Override * @since 1.5 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 从注释可以看出，@Override的作用是，提示编译器，使用了@Override注解的方法必须override父类或者java.lang.Object中的一个同名方法。我们看到@Override的定义中使用到了 @Target, @Retention，它们就是所谓的“元注解”——就是定义注解的注解，或者说注解注解的注解。 @Retention看下@Retention注解定义：12345678910111213141516/** * Indicates how long annotations with the annotated type are to * be retained. If no Retention annotation is present on * an annotation type declaration, the retention policy defaults to * RetentionPolicy.CLASS. */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; /** * Returns the retention policy. * @return the retention policy */ RetentionPolicy value();&#125; @Retention用于提示注解被保留多长时间，有三种取值：12345678910111213141516171819public enum RetentionPolicy &#123; /** * Annotations are to be discarded by the compiler. */ SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * @see java.lang.reflect.AnnotatedElement */ RUNTIME&#125; RetentionPolicy.SOURCE 保留在源码级别，被编译器抛弃(@Override就是此类)；RetentionPolicy.CLASS被编译器保留在编译后的类文件级别，但是被虚拟机丢弃；RetentionPolicy.RUNTIME保留至运行时，可以被反射读取。 @Target1234567891011121314151617181920212223package java.lang.annotation;/** * Indicates the contexts in which an annotation type is applicable. The * declaration contexts and type contexts in which an annotation type may be * applicable are specified in JLS 9.6.4.1, and denoted in source code by enum * constants of java.lang.annotation.ElementType * @since 1.5 * @jls 9.6.4.1 @Target * @jls 9.7.4 Where Annotations May Appear */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; /** * Returns an array of the kinds of elements an annotation type * can be applied to. * @return an array of the kinds of elements an annotation type * can be applied to */ ElementType[] value();&#125; @Target用于提示该注解使用的地方，取值有：12345678910111213141516171819202122232425262728public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * @since 1.8 */ TYPE_USE&#125; 分别表示该注解可以被使用的地方： 1) 类,接口,注解,enum;2) 属性域；3）方法；4）参数；5）构造函数；6）局部变量；7）注解类型；8）包。 所以：1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; 表示 @Override 只能使用在方法上，保留在源码级别，被编译器处理，然后抛弃掉。 @Documented12345678910111213/** * Indicates that annotations with a type are to be documented by javadoc * and similar tools by default. This type should be used to annotate the * declarations of types whose annotations affect the use of annotated * elements by their clients. If a type declaration is annotated with * Documented, its annotations become part of the public API * of the annotated elements. */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125; 表示注解是否能被 javadoc 处理并保留在文档中。 使用 元注解 来自定义注解 和 处理自定义注解有了元注解，就可以使用它来自定义我们需要的注解。结合自定义注解和AOP或者过滤器，十分强大。比如可以使用注解来实现权限的细粒度的控制——在类或者方法上使用权限注解，然后在AOP或者过滤器中进行拦截处理。下面是一个关于登录的权限的注解的实现：12345678/** * 不需要登录注解 */@Target(&#123; ElementType.METHOD, ElementType.TYPE &#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface NoLogin &#123;&#125; 自定义了一个注解 @NoLogin, 可以被用于 方法 和 类 上，注解一直保留到运行期，可以被反射读取到。该注解的含义是：被 @NoLogin 注解的类或者方法，即使用户没有登录，也是可以访问的。下面就是对注解进行处理了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 检查登录拦截器 * 如不需要检查登录可在方法或者controller上加上@NoLogin */public class CheckLoginInterceptor implements HandlerInterceptor &#123; private static final Logger logger = Logger.getLogger(CheckLoginInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if (!(handler instanceof HandlerMethod)) &#123; logger.warn(&quot;当前操作handler不为HandlerMethod=&quot; + handler.getClass().getName() + &quot;,req=&quot; + request.getQueryString()); return true; &#125; HandlerMethod handlerMethod = (HandlerMethod) handler; String methodName = handlerMethod.getMethod().getName(); // 判断是否需要检查登录 NoLogin noLogin = handlerMethod.getMethod().getAnnotation(NoLogin.class); if (null != noLogin) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;当前操作methodName=&quot; + methodName + &quot;不需要检查登录情况&quot;); &#125; return true; &#125; noLogin = handlerMethod.getMethod().getDeclaringClass().getAnnotation(NoLogin.class); if (null != noLogin) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;当前操作methodName=&quot; + methodName + &quot;不需要检查登录情况&quot;); &#125; return true; &#125; if (null == request.getSession().getAttribute(CommonConstants.SESSION_KEY_USER)) &#123; logger.warn(&quot;当前操作&quot; + methodName + &quot;用户未登录,ip=&quot; + request.getRemoteAddr()); response.getWriter().write(JsonConvertor.convertFailResult(ErrorCodeEnum.NOT_LOGIN).toString()); // 返回错误信息 return false; &#125; return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 上面我们定义了一个登录拦截器，首先使用反射来判断方法上是否被 @NoLogin 注解： NoLogin noLogin = handlerMethod.getMethod().getAnnotation(NoLogin.class);然后判断类是否被 @NoLogin注解： noLogin = handlerMethod.getMethod().getDeclaringClass().getAnnotation(NoLogin.class); 如果被注解了，就返回 true，如果没有被注解，就判断是否已经登录，没有登录则返回错误信息给前台和false.这是一个简单的使用 注解 和 过滤器 来进行权限处理的例子。扩展开来，那么我们就可以使用注解，来表示某方法或者类，只能被具有某种角色，或者具有某种权限的用户所访问，然后在过滤器中进行判断处理。 Spring的bean容器相关的注解 @Autowired 是我们使用得最多的注解，其实就是 autowire=byType 就是根据类型的自动注入依赖（基于注解的依赖注入），可以被使用在属性域，方法，构造函数上。 @Qualifier 就是 autowire=byName, @Autowired注解判断多个bean类型相同时，就需要使用 @Qualifier(&quot;xxBean&quot;) 来指定依赖的bean的id： 123456@Controller@RequestMapping(&quot;/user&quot;)public class HelloController &#123; @Autowired @Qualifier(&quot;userService&quot;) private UserService userService; @Resource 属于JSR-250标准，用于属性域和方法上。也是 byName 类型的依赖注入。使用方式：@Resource(name=&quot;xxBean&quot;). 不带参数的 @Resource 默认值类名首字母小写。 JSR-330标准javax.inject.*中的注解(@Inject, @Named, @Qualifier, @Provider, @Scope, @Singleton)。@Inject就相当于@Autowired, @Named 就相当于 @Qualifier, 另外 @Named 用在类上还有 @Component的功能。 @Component, @Controller, @Service, @Repository, 这几个注解不同于上面的注解，上面的注解都是将被依赖的bean注入进来，而这几个注解的作用都是生产bean, 这些注解都是注解在类上，将类注解成spring的bean工厂中一个一个的bean。@Controller, @Service, @Repository基本就是语义更加细化的@Component。 @PostConstruct 和 @PreDestroy 不是用于依赖注入，而是bean 的生命周期。类似于 init-method(InitializeingBean)和destory-method(DisposableBean)。 Spring中注解的处理spring中注解的处理基本都是通过实现接口 BeanPostProcessor 来进行的：1234public interface BeanPostProcessor &#123; Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;&#125; 相关的处理类有：AutowiredAnnotationBeanPostProcessor，CommonAnnotationBeanPostProcessor，PersistenceAnnotationBeanPostProcessor，RequiredAnnotationBeanPostProcessor。 这些处理类，可以通过 &lt;context:annotation-config/&gt; 配置 隐式的配置进spring容器。这些都是依赖注入的处理，还有生产bean的注解(@Component， @Controller, @Service, @Repository)的处理： &lt;context:component-scan base-package=&quot;net.aazj.service,net.aazj.aop&quot; /&gt; 这些都是通过指定扫描的基包路径来进行的，将他们扫描进spring的bean容器。注意 &lt;context:component-scan/&gt; 也会默认将 AutowiredAnnotationBeanPostProcessor，CommonAnnotationBeanPostProcessor 配置进来。所以&lt;context:annotation-config/&gt;是可以省略的。另外&lt;context:component-scan/&gt;也可以扫描@Aspect风格的AOP注解，但是需要在配置文件中加入 &lt;aop:aspectj-autoproxy/&gt;进行配合。 Spring注解和JSR-330标准注解的区别]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL-索引结构]]></title>
    <url>%2F2019%2F08%2F08%2FMySQL-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.html</url>
    <content type="text"><![CDATA[BTree索引BTree（多路搜索树，并不是二叉的）是一种常见的数据结构。 不适合： 单列索引的列不能包含null的记录，复合索引的各个列不能包含同时为null的记录，否则会全表扫描；索引失效很多时候是因为这列有null，空值不适合键值较少的列（重复数据较多的列）；假如你建立了，会发生什么情况呢？查询反而会变慢前导模糊查询不能利用索引(like ‘%XX’或者like ‘%XX%’)，该类sql语句导致索引失效 Hash散列索引Hash散列索引是根据HASH算法来构建的索引。 适合： 精确查找非常快（包括= &lt;&gt; 和in），其检索效率非常高，索引的检索可以一次定位，不像BTree 索引需要从根节点到枝节点，所以 Hash 索引的查询效率要远高于 B-Tree 索引。 不适合： 不适合模糊查询和范围查询（包括like，&gt;，&lt;，between……and等），由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样；不适合排序，数据库无法利用索引的数据来提升排序性能，同样是因为Hash值的大小不确定；复合索引不能利用部分索引字段查询，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。同样不适合键值较少的列（重复值较多的列）； Bitmap位图索引就是用位图表示的索引，对列的每个键值建立一个位图。相对于BTree索引，占用的空间非常小，创建和使用非常快。位图索引由于只存储键值的起止Rowid和位图,占用的空间非常少。 适合 适合决策支持系统；当select count(XX) 时,可以直接访问索引中一个位图就快速得出统计数据；当根据键值做and，or或 in(x,y,..)查询时，直接用索引的位图进行或运算,快速得出结果行数据。 不适合 不适合键值较多的列（重复值较少的列）；不适合update、insert、delete频繁的列，代价很高。到底是什么代价呢？update,insert,delete的时候会锁住键值一样的行。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴连接池DruidDataSource的一个bug]]></title>
    <url>%2F2019%2F08%2F08%2F%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E8%BF%9E%E6%8E%A5%E6%B1%A0DruidDataSource%E7%9A%84%E4%B8%80%E4%B8%AAbug.html</url>
    <content type="text"><![CDATA[问题使用阿里巴巴的数据库连接池Druid，当应用程序连接数据库，老是报错：caused by wait mills 5000,active 0,maxactive 20连接数据库超时，但是使用单独的jdbc连接却是可以连接的。 解决经过反复测试，发现问题所在，原来是连接池参数&lt;property name=&quot;validationQuery&quot; value=&quot;select 1&quot;&gt;配置错误。虽然是配置错误，但是连接池版本是1.0.10，太旧，导致没有把真正的报错提示出来ora-00923 未找到要求的关键字from，而是报这个错：caused by wait mills 5000,active 0,maxactive 20。也就是说，本来是因为配置错误导致的，但是因为阿里巴巴连接池DruidDataSource的bug，把这个错误隐藏起来了，一直没有把真正的错误报出来。 总结将Druid版本升级到最新的稳定版本，DruidDataSource配置成如下：123456789&lt;property name=&quot;minIdle&quot; value=&quot;1&quot; /&gt;&lt;property name=&quot;validationQuery&quot; value=&quot;SELECT 1 FROM DUAL&quot; /&gt;&lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt;&lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot; /&gt;&lt;property name=&quot;initialSize&quot; value=1 /&gt; 参数说明 validationQuery SQL查询,用来验证从连接池取出的连接,在将连接返回给调用者之前.如果指定, 则查询必须是一个SQL SELECT并且必须返回至少一行记录。 testOnBorrow true–指明是否在从池中取出连接前进行检验,如果检验失败, 则从池中去除连接并尝试取出另一个。 注意: 设置为true后如果要生效,validationQuery参数必须设置为非空字符串 。 testOnReturn false–指明是否在归还到池中前进行检验。 注意: 设置为true后如果要生效,validationQuery参数必须设置为非空字符串 。 testWhileIdle false–指明连接是否被空闲连接回收器(如果有)进行检验.如果检测失败, 则连接将被从池中去除。 注意: 设置为true后如果要生效,validationQuery参数必须设置为非空字符串 timeBetweenEvictionRunsMillis -1–在空闲连接回收器线程运行期间休眠的时间值,以毫秒为单位. 如果设置为非正数,则不运行空闲连接回收器线程。 numTestsPerEvictionRun 3–在每次空闲连接回收器线程(如果有)运行时检查的连接数量 。 minEvictableIdleTimeMillis 1000 60 30–连接在池中保持空闲而不被空闲连接回收器线程(如果有)回收的最小时间值，单位毫秒。]]></content>
      <categories>
        <category>druid</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>druid</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库、缓存不一致问题]]></title>
    <url>%2F2019%2F08%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[只要用缓存，就可能会涉及到缓存与数据库双存储双写，只要是双写，就一定会有数据一致性问题，如何保证缓存与数据库的双写一致性？ 读写串行化一般来说，如果允许缓存可以稍微跟数据库偶尔有不一致，也就是说系统不是严格要求缓存+数据库必须保持一致性的话，可以采用读写请求串行化：即读请求和写请求串到一个内存队列里去，从而达到防止并发请求导致数据错乱的问题。值得注意的是，串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低。 代码实现大致如下（网上找的）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 请求异步处理的service实现 * @author Administrator * */@Service(&quot;requestAsyncProcessService&quot;) public class RequestAsyncProcessServiceImpl implements RequestAsyncProcessService &#123; @Override public void process(Request request) &#123; try &#123; // 先做读请求的去重 RequestQueue requestQueue = RequestQueue.getInstance(); Map&lt;Integer, Boolean&gt; flagMap = requestQueue.getFlagMap(); if(request instanceof ProductInventoryDBUpdateRequest) &#123; // 如果是一个更新数据库的请求，那么就将那个productId对应的标识设置为true flagMap.put(request.getProductId(), true); &#125; else if(request instanceof ProductInventoryCacheRefreshRequest) &#123; Boolean flag = flagMap.get(request.getProductId()); // 如果flag是null if(flag == null) &#123; flagMap.put(request.getProductId(), false); &#125; // 如果是缓存刷新的请求，那么就判断，如果标识不为空，而且是true，就说明之前有一个这个商品的数据库更新请求 if(flag != null &amp;&amp; flag) &#123; flagMap.put(request.getProductId(), false); &#125; // 如果是缓存刷新的请求，而且发现标识不为空，但是标识是false // 说明前面已经有一个数据库更新请求+一个缓存刷新请求了，大家想一想 if(flag != null &amp;&amp; !flag) &#123; // 对于这种读请求，直接就过滤掉，不要放到后面的内存队列里面去了 return; &#125; &#125; // 做请求的路由，根据每个请求的商品id，路由到对应的内存队列中去 ArrayBlockingQueue&lt;Request&gt; queue = getRoutingQueue(request.getProductId()); // 将请求放入对应的队列中，完成路由操作 queue.put(request); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取路由到的内存队列 * @param productId 商品id * @return 内存队列 */ private ArrayBlockingQueue&lt;Request&gt; getRoutingQueue(Integer productId) &#123; RequestQueue requestQueue = RequestQueue.getInstance(); // 先获取productId的hash值 String key = String.valueOf(productId); int h; int hash = (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); // 对hash值取模，将hash值路由到指定的内存队列中，比如内存队列大小8 // 用内存队列的数量对hash值取模之后，结果一定是在0~7之间 // 所以任何一个商品id都会被固定路由到同样的一个内存队列中去的 int index = (requestQueue.queueSize() - 1) &amp; hash; System.out.println(&quot;===========日志===========: 路由内存队列，商品id=&quot; + productId + &quot;, 队列索引=&quot; + index); return requestQueue.getQueue(index); &#125;&#125; Cache Aside PatternCache Aside Patten：经典的缓存+数据库读写模式。 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。更新的时候，先删除缓存，然后再更新数据库。 为什么是删除缓存，而不是更新缓存？ 之所以更新的时候只是删除缓存，因为对于一些复杂有逻辑的缓存数据，每次数据变更都更新一次缓存会造成额外的负担，只是删除缓存，让该数据下一次被使用的时候再去执行读的操作来重新缓存，这里采用的是懒加载的策略。举个例子，一个缓存涉及的表的字段，在1分钟内就修改了20次，或者是100次，那么缓存更新20次，100次;但是这个缓存在1分钟内就被读取了1次，因此每次更新缓存就会有大量的冷数据，对于缓存符合28黄金法则，20%的数据，占用了80%的访问量。 最初级的缓存不一致问题及解决方案问题：先修改数据库，再删除缓存。如果删除缓存失败了，那么导致数据库中是新数据，缓存中是旧数据，数据就会出现不一致性。 解决思路：先删除缓存，再修改数据库。如果数据库修改失败了，那么数据库中是旧数据，缓存中是空的，那么数据就不会不一致。因为读的时候缓存中没有，则读数据库中的旧数据，然后再更新到缓存中。 比较复杂的数据不一致问题问题：数据发生了变更，先删除了缓存，然后要去修改数据库，但是还没来得及修改，一个请求过来，去读缓存，发现缓存是空的，去查询数据库，查到了修改前的旧数据，放到了缓存中，随后数据变更的程序完成了数据库的修改，这样就会造成数据库和缓存中的数据不一致。 解决思路：更新数据的时候，根据数据的唯一标识，将操作路由到一个JVM的内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个JVM内部队列中。一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。这样，一个数据变更的操作，先删除缓存，再去更新数据库，但是还没完成更新，此时一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送的队列中，此时会在队列中积压，然后同步等待缓存更新完成。 这样有一个优点：一个队列中多个更新缓存的请求串在一起是没意义的，因此可以做过滤。如果发现队列中已经有一个更新缓存的请求，那么不再放更新缓存的请求操作进去，直接等待前面的更新操作完成即可。 待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。 如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。 高并发场景下，该方案要注意如下的问题： 读请求长时阻塞由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。 该方案最大的风险点在于，可能数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库。 所以务必通过一些模拟真实的测试，看看更新数据的频率是怎样的。 另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要部署多个服务，每个服务分摊一些数据的更新操作。 如果一个内存队列里积压 100 个商品的库存修改操作，每个库存修改操作要耗费 10ms 去完成。那么最后一个商品的读请求，可能等待 10*100=1000ms=1s 后，才能得到数据，这个时候就导致读请求的长时阻塞。 因此，一定要根据实际业务系统的运行情况，去进行一些压力测试和模拟线上环境，看高峰期，内存队列可能会积压多少更新操作，可能会导致最后一个更新操作对应的读请求，会 Hang 多少时间。 如果读请求在 200ms 返回，哪怕是最繁忙的时候，积压 10 个更新操作，最多等待 200ms，那还可以的。 如果一个内存队列中可能积压的更新操作特别多，那就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。 一般来说，数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。像这种针对读高并发、读缓存架构的项目，一般来说写请求是非常少的，每秒的 QPS 能到几百就不错了。 实际粗略测算一下，如果一秒有 500 的写操作，分成 5 个时间片，每 200ms 就 100 个写操作，放到 20 个内存队列中，每个内存队列，可能就积压 5 个写操作。 每个写操作性能测试后，一般是在 20ms 左右就完成，那么针对每个内存队列的数据的读请求，也就最多 Hang 一会儿，200ms 以内肯定能返回了。 经过简单的测算，单机支撑的写 QPS 在几百是没问题的，如果写 QPS 扩大了 10 倍，那么就扩容机器，扩容 10 倍的机器，每个机器 20 个队列。 读请求并发量过高这里还必须做好压力测试，确保恰巧碰上上述情况时，还有一个风险，就是突然间大量读请求会在几十毫秒的延时 Hang 在服务上，看服务能不能扛的住，需要多少机器才能扛住最大的极限情况的峰值。 但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。 多服务实例部署的请求路由可能这个服务部署了多个实例，那么必须保证执行数据更新操作，以及执行缓存更新操作的请求，都通过 Nginx 服务器路由到相同的服务实例上。 比如对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 Hash 路由，也可以用 Nginx 的 Hash 路由功能等等。]]></content>
      <categories>
        <category>缓存</category>
        <category>redis</category>
      </categories>
      <tags>
        <tag>缓存</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOM常见原因及解决]]></title>
    <url>%2F2019%2F08%2F06%2FOOM%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3.html</url>
    <content type="text"><![CDATA[Java heap space 当堆内存（Heap Space）没有足够空间存放新创建的对象时，就会抛出 java.lang.OutOfMemoryError:Javaheap space 错误（根据实际生产经验，可以对程序日志中的 OutOfMemoryError 配置关键字告警，一经发现，立即处理）。 原因分析 Javaheap space 错误产生的常见原因可以分为以下几类： 1、请求创建一个超大对象，通常是一个大数组。 2、超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。 3、过度使用终结器（Finalizer），该对象没有立即被 GC。 4、内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收。 解决方案 针对大部分情况，通常只需要通过 -Xmx 参数调高 JVM 堆内存空间即可。如果仍然没有解决，可以参考以下情况做进一步处理： 1、如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制。 2、如果是业务峰值压力，可以考虑增加机器资源，或者做限流降级。 3、如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。 GC overhead limit exceeded 当 Java 进程花费 98% 以上的时间执行 GC，但只恢复了不到 2% 的内存，且该动作连续重复了 5 次，就会抛出 java.lang.OutOfMemoryError:GC overhead limit exceeded错误。简单地说，就是应用程序已经基本耗尽了所有可用内存， GC 也无法回收。 此类问题的原因与解决方案跟 Javaheap space 非常类似，可以参考。 Permgen space 该错误表示永久代（Permanent Generation）已用满，通常是因为加载的 class 数目太多或体积太大。 原因分析: 永久代存储对象主要包括以下几类： 1、加载/缓存到内存中的 class 定义，包括类的名称，字段，方法和字节码； 2、常量池； 3、对象数组/类型数组所关联的 class； 4、JIT 编译器优化后的 class 信息。 PermGen 的使用量与加载到内存的 class 的数量/大小正相关。 解决方案: 根据 Permgen space 报错的时机，可以采用不同的解决方案，如下： 1、程序启动报错，修改 -XX:MaxPermSize 启动参数，调大永久代空间。 2、应用重新部署时报错，很可能是没有应用没有重启，导致加载了多份 class 信息，只需重启 JVM 即可解决。 3、运行时报错，应用程序可能会动态创建大量 class，而这些 class 的生命周期很短暂，但是 JVM 默认不会卸载 class，可以设置 -XX:+CMSClassUnloadingEnabled 和 -XX:+UseConcMarkSweepGC这两个参数允许 JVM 卸载 class。 如果上述方法无法解决，可以通过 jmap 命令 dump 内存对象 jmap-dump:format=b,file=dump.hprof&lt;process-id&gt;，然后利用 Eclipse MAT https://www.eclipse.org/mat 功能逐一分析开销最大的 classloader 和重复 class。 Metaspace JDK 1.8 使用 Metaspace 替换了永久代（Permanent Generation），该错误表示 Metaspace 已被用满，通常是因为加载的 class 数目太多或体积太大。 此类问题的原因与解决方法跟 Permgenspace 非常类似，可以参考。需要特别注意的是调整 Metaspace 空间大小的启动参数为 -XX:MaxMetaspaceSize。 Unable to create new native thread 每个 Java 线程都需要占用一定的内存空间，当 JVM 向底层操作系统请求创建一个新的 native 线程时，如果没有足够的资源分配就会报此类错误。 原因分析: JVM 向 OS 请求创建 native 线程失败，就会抛出 Unableto create new native thread，常见的原因包括以下几类： 1、线程数超过操作系统最大线程数 ulimit 限制； 2、线程数超过 kernel.pid_max（只能重启）； 3、native 内存不足； 该问题发生的常见过程主要包括以下几步： 1、JVM 内部的应用程序请求创建一个新的 Java 线程； 2、JVM native 方法代理了该次请求，并向操作系统请求创建一个 native 线程； 3、操作系统尝试创建一个新的 native 线程，并为其分配内存； 4、如果操作系统的虚拟内存已耗尽，或是受到 32 位进程的地址空间限制，操作系统就会拒绝本次 native 内存分配； 5、JVM 将抛出 java.lang.OutOfMemoryError:Unable to create new native thread 错误。 解决方案: 1、升级配置，为机器提供更多的内存； 2、降低 Java Heap Space 大小； 3、修复应用程序的线程泄漏问题； 4、限制线程池大小； 5、使用 -Xss 参数减少线程栈的大小； 6、调高 OS 层面的线程最大数：执行 ulimia-a 查看最大线程数限制，使用 ulimit-u xxx 调整最大线程数限制。 ulimit -a …. 省略部分内容 ….. max user processes (-u) 16384 Out of swap space? 该错误表示所有可用的虚拟内存已被耗尽。虚拟内存（Virtual Memory）由物理内存（Physical Memory）和交换空间（Swap Space）两部分组成。当运行时程序请求的虚拟内存溢出时就会报 Outof swap space?错误。 原因分析: 该错误出现的常见原因包括以下几类： 1、地址空间不足； 2、物理内存已耗光； 3、应用程序的本地内存泄漏（native leak），例如不断申请本地内存，却不释放。 4、执行 jmap-histo:live&lt;pid&gt; 命令，强制执行 Full GC；如果几次执行后内存明显下降，则基本确认为 Direct ByteBuffer 问题。 解决方案: 1、升级地址空间为 64 bit； 2、使用 Arthas 检查是否为 Inflater/Deflater 解压缩问题，如果是，则显式调用 end 方法。 3、Direct ByteBuffer 问题可以通过启动参数 -XX:MaxDirectMemorySize 调低阈值。 4、升级服务器配置/隔离部署，避免争用。 Kill process or sacrifice child 有一种内核作业（Kernel Job）名为 Out of Memory Killer，它会在可用内存极低的情况下“杀死”（kill）某些进程。OOM Killer 会对所有进程进行打分，然后将评分较低的进程“杀死”，具体的评分规则可以参考 Surviving the Linux OOM Killer。 不同于其他的 OOM 错误， Killprocessorsacrifice child 错误不是由 JVM 层面触发的，而是由操作系统层面触发的。 原因分析: 默认情况下，Linux 内核允许进程申请的内存总量大于系统可用内存，通过这种“错峰复用”的方式可以更有效的利用系统资源。 然而，这种方式也会无可避免地带来一定的“超卖”风险。例如某些进程持续占用系统内存，然后导致其他进程没有可用内存。此时，系统将自动激活 OOM Killer，寻找评分低的进程，并将其“杀死”，释放内存资源。 解决方案: 1、升级服务器配置/隔离部署，避免争用。 2、OOM Killer 调优。 Requested array size exceeds VM limit JVM 限制了数组的最大长度，该错误表示程序请求创建的数组超过最大长度限制。 JVM 在为数组分配内存前，会检查要分配的数据结构在系统中是否可寻址，通常为 Integer.MAX_VALUE-2。 此类问题比较罕见，通常需要检查代码，确认业务是否需要创建如此大的数组，是否可以拆分为多个块，分批执行。 Direct buffer memory Java 允许应用程序通过 Direct ByteBuffer 直接访问堆外内存，许多高性能程序通过 Direct ByteBuffer 结合内存映射文件（Memory Mapped File）实现高速 IO。 原因分析: Direct ByteBuffer 的默认大小为 64 MB，一旦使用超出限制，就会抛出 Directbuffer memory 错误。 解决方案: 1、Java 只能通过 ByteBuffer.allocateDirect 方法使用 Direct ByteBuffer，因此，可以通过 Arthas 等在线诊断工具拦截该方法进行排查。 2、检查是否直接或间接使用了 NIO，如 netty，jetty 等。 3、通过启动参数 -XX:MaxDirectMemorySize 调整 Direct ByteBuffer 的上限值。 4、检查 JVM 参数是否有 -XX:+DisableExplicitGC 选项，如果有就去掉，因为该参数会使 System.gc() 失效。 5、检查堆外内存使用代码，确认是否存在内存泄漏；或者通过反射调用 sun.misc.Cleaner 的 clean() 方法来主动释放被 Direct ByteBuffer 持有的内存空间。 6、内存容量确实不足，升级配置。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 计数排序]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想：计数排序是一种非基于比较的排序算法，其空间复杂度和时间复杂度均为O(n+k)，其中k是整数的范围。基于比较的排序算法时间复杂度最小是O(nlogn)的。该算法于1954年由 Harold H. Seward 提出。 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 算法步骤： 花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max。 开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)。 数组 B 中 index 的元素记录的值是 A 中某元素出现的次数。 最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数。 算法演示： 算法演示说明： 首先，扫描一下整个序列。 获得最小值为 2 ，最大值为 7。 新建数组包含 2~7 的元素。 再次扫描序列，将序列的值放置在新建数组中。 扫描数字 5，数组中 index 为 3 的值为 5，次数为 1。 扫描数字 3，数组中 index 为 1 的值为 3，次数为 1。 扫描数字 4，数组中 index 为 2 的值为 4，次数为 1。 扫描数字 7，数组中 index 为 5 的值为 7，次数为 1。 扫描数字 2，数组中 index 为 0 的值为 2，次数为 1。 扫描数字 4，数组中 index 为 2 的值为 4，次数为 2。 扫描数字 3，数组中 index 为 1 的值为 3，次数为 2。 按照这种节奏，扫描结束后，新建数组中存放了整个序列以及每个数字出现的次数。 最后输出目标整数序列。 输出数字 2，同时数组中 index 为 0 的值为 2 的元素次数变为 0。 输出数字 3，同时数组中 index 为 1 的值为 3 的元素次数变为 1。 同样的操作，整个序列就完全输出了。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;import java.util.Arrays;/** * @author: whb * @date: 2019/6/28 10:43 * @description: 计数排序 */public class CountingSort &#123; public static int[] countingSort(int[] unsorted) &#123; //开始声明桶,找到数组的最小值和最大值 int minNum = unsorted[0]; int maxNum = unsorted[0]; for (int i = 0; i &lt; unsorted.length; i++) &#123; if (unsorted[i] &lt; minNum) &#123; minNum = unsorted[i]; &#125; if (unsorted[i] &gt; maxNum) &#123; maxNum = unsorted[i]; &#125; &#125; System.out.println(&quot;最小数字为:&quot; + minNum); System.out.println(&quot;最大数字位:&quot; + maxNum); //找到最大最小值的之后,就开始声明有序桶,桶的初始位代表的值为minNum最大值为maxNum //数组的长度为(maxNum-minNum+1) int[] bucket = new int[(maxNum - minNum + 1)]; //声明了有序桶之后,开始对数字进行放桶操作 for (int j = 0; j &lt; unsorted.length; j++) &#123; //因为是找到了待排序数组的最小值minNum,所以,与数组数组比较的值应为(j+minNum) //如果遍历的值大小与数组代表的数字大小相等,则放入 //j次循环得到的数字是tempArray[j],则存储到下标为tempArray[j]+minNum的桶中 bucket[unsorted[j] - minNum] = bucket[unsorted[j] - minNum] + 1; &#125; //将得到的桶排序结果进行输出,输出的是桶排序的数组的下标 //可以声明新数组对该序列进行存储 int[] sorted = new int[unsorted.length]; int count = 0; for (int k = 0; k &lt; bucket.length; k++) &#123; if (bucket[k] != 0) &#123; //桶里装的值可能不是1,所以,在不等于一的时候,对桶里面的数字进行遍历存储 if (bucket[k] != 1) &#123; for (int z = 0; z &lt; bucket[k]; z++) &#123; sorted[count] = k + minNum; count++; &#125; &#125; else &#123; sorted[count] = k + minNum; count++; &#125; &#125; &#125; return sorted; &#125; public static void main(String[] args) &#123; //产生随机待排序列 int[] unsorted = new int[(int) (Math.random() * 11) + 5]; for (int i = 0; i &lt; unsorted.length; i++) &#123; unsorted[i] = (int) (Math.random() * 100); &#125; System.out.println(&quot;**************计数排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(unsorted); System.out.println(&quot;排序后：&quot;); int[] sorted = countingSort(unsorted); CommonUtils.display(sorted); &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 珠排序]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E7%8F%A0%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想： 将每个数用珠子表示，例如：数字5就是5个珠子。用珠子表示好每一个数后，让所有的珠子自由下落。排序完成。 上图中的三个珠就表示数字3,两个珠表示数字2,这个OK了继续,这里的3和2都叫bead。 上图(a)中有两个数字,4和3,分别串在四条线上,于是数字4的最后一个珠子下落,因为它下边是空的,自由下落后变成上图(b) 上图(c)中随机给了四个数字,分别是3,2,4,2,这些珠子自由下落,就变成了(d)中,落完就有序了,2,2,3,4 以上就是珠排序的精华。 上图中的n表示待排序数组的长度,有多少数字就有多少层,横向表示一层;m表示有多少个珠子,就是多少个1,这取决于最大数是几。 举个例子：比如待排数组[6 2 4 1 5 9]。 让珠子全部做自由落体运动 9没有什么好落的,它在最底层 5也没有什么好落的,全部有支撑点 1同样不需要滑落 4除了第一个珠子不动外,其它三颗全部下落,落到1的位置变成下边这样 过程的细节不画了,原则就是你下边有支点,你就不用再滑落了,最后变成下边这样,排序完毕。 从上到下顺序输出即可得到结果:[ 1 2 4 5 6 9]。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @date: 2019/6/28 10:06 * @description: 珠排序:将每个数用珠子表示，例如：数字5就是5个珠子。用珠子表示好每一个数后，让所有的珠子自由下落。排序完成。 */public class BeadSort &#123; /** * 珠排序 * * @param unsorted 待排序列 * @return */ public static int[] beadSort(int[] unsorted) &#123; //待排序列中的最大值 int max = 0; //获取最大值 for (int i = 0; i &lt; unsorted.length; i++) &#123; if (unsorted[i] &gt; max) &#123; max = unsorted[i]; &#125; &#125; //每个数都用珠子表示，比如5就用5个珠子，所以用二维数组表示每个数 char[][] grid = new char[unsorted.length][max]; int[] levelCount = new int[max]; for (int i = 0; i &lt; max; i++) &#123; levelCount[i] = 0; for (int j = 0; j &lt; unsorted.length; j++) &#123; grid[j][i] = &apos;_&apos;; &#125; &#125; //删除珠子 for (int i = 0; i &lt; unsorted.length; i++) &#123; int num = unsorted[i]; for (int j = 0; num &gt; 0; j++) &#123; grid[levelCount[j]++][j] = &apos;*&apos;; num--; &#125; &#125; //数珠子，放到已排序列表 int[] sorted = new int[unsorted.length]; for (int i = 0; i &lt; unsorted.length; i++) &#123; int putt = 0; for (int j = 0; j &lt; max &amp;&amp; grid[unsorted.length - 1 - i][j] == &apos;*&apos;; j++) &#123; putt++; &#125; sorted[i] = putt; &#125; return sorted; &#125; public static void main(String[] args) &#123; //产生随机待排序列 int[] unsorted = new int[(int) (Math.random() * 11) + 5]; for (int i = 0; i &lt; unsorted.length; i++) &#123; unsorted[i] = (int) (Math.random() * 10); &#125; System.out.println(&quot;**************珠排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(unsorted); System.out.println(&quot;排序后：&quot;); int[] sorted = beadSort(unsorted); CommonUtils.display(sorted); &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 耐心排序]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%80%90%E5%BF%83%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[耐心排序充分集合了桶排序和插入排序的优点，首先使用桶排序，排序之后每个桶中数据相对有序，这样再使用插入排序，简化了问题，速度变的更快。 建桶规则:如果没有桶,新建一个桶;如果不符合入桶规则那么新建一个桶。 入桶规则:只要比桶里最上边的数字小即可入桶,如果有多个桶可入,那么按照从左到右的顺序入桶即可。 举个例子：待排序数组[6 4 5 1 8 7 2 3] 第一步：因为此前还没有桶，则建立一个桶，我们命名为桶1,从上面取出第一个数字 6，然后将6放入到桶中。 第二步：我们使用第二个值4，然后遍历现有的桶，遍历的工程中先遇到桶1，我们发现桶1中最上面的元素是6,4比6大，则6下沉，有桶【4,6】。 第三步：我们使用第三个值5，然后遍历现有的桶，因为第一个桶第一个元素是4，比5小，所以重新开一个桶【5】，之后共有两个桶【4,5】【5】。 第四部：我们使用第四个值1，然后遍历现有的桶，因为第一个桶第一个元素是4，比1大，所以放到桶1【4,6】最前面，从而形成【1,4,6】【5】。 第五步：我们使用第五个元素，然后遍历现有的桶，第一个桶第一个元素是1，第二个桶第一个元素是5，都比8小，所以需要重新开一个桶【8】，此时共有桶【1,4,6】【5】【8】。 第六步：使用同样的方法，之后桶是【1,4,6】【5】【7，8】。 第七步：使用同样的方法，之后桶是【1,4,6】【2，5】【7，8】。 第八步：使用同样的方法，之后桶是【1,4,6】【2，5】【3，7，8】。 注意：遍历的数组，只跟各个桶的第一个元素做比较，这样保证各个桶元素有序。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;import java.util.ArrayList;import java.util.List;/** * @author: whb * @date: 2019/6/26 2:22 * @description: 耐心排序 */public class PatienceSort &#123; public static int[] patienceSort(int[] unsorted) &#123; List new_list = new ArrayList(); for (int i = 0; i &lt; unsorted.length; i++) &#123; List bucket_list = new ArrayList(); if (i == 0) &#123; bucket_list.add(unsorted[i]); new_list.add(bucket_list); &#125; else &#123; boolean is_ok = false; for (int j = 0; j &lt; new_list.size(); j++) &#123; if (unsorted[i] &lt; (int) ((List) new_list.get(j)).get(0)) &#123; ((List) new_list.get(j)).add(0, unsorted[i]); is_ok = true; break; &#125; &#125; if (!is_ok) &#123; bucket_list.add(unsorted[i]); new_list.add(bucket_list); &#125; &#125; &#125; //多维数组变成单维数组 int[] ok_list = new int[unsorted.length]; int q = 0; for (int m = 0; m &lt; new_list.size(); m++) &#123; for (int n = 0; n &lt; ((List) new_list.get(m)).size(); n++) &#123; ok_list[q] = (int) ((List) new_list.get(m)).get(n); q++; &#125; &#125; //插入循环 //将数组的长度赋给n是为了防止每次for循环中判断时都调用length方法影响性能 int n = ok_list.length; //用于中转数据 int tmp; int j; //排序的次数 for (int i = 1; i &lt; n; i++) &#123; tmp = ok_list[i]; //取i前面的所有跟i位置元素进行比较，先比较i-1和i，如果i-1大于i，则互换位置，i-1和i-2比较，以此类推 for (j = i - 1; j &gt;= 0 &amp;&amp; ok_list[j] &gt; tmp; j--) &#123; ok_list[j + 1] = ok_list[j]; &#125; ok_list[j + 1] = tmp; &#125; return ok_list; &#125; public static void main(String[] args) &#123; int[] unsorted = &#123;6, 4, 5, 1, 8, 7, 2, 3&#125;; System.out.println(&quot;**************耐心排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(unsorted); System.out.println(&quot;排序后：&quot;); int[] sorted = patienceSort(unsorted); CommonUtils.display(sorted); &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 梳排序]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%A2%B3%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想： 梳排序和希尔排序很类似。希尔排序是在直接插入排序的基础上做的优化，而梳排序是在冒泡排序的基础上做的优化。也是像希尔排序一样，将待排序序列通过增量分为若干个子序列，然后对子序列进行一趟冒泡排序，一步步减小增量，直至增量为1。所以梳排序的最后一次排序是冒泡排序。梳排序增量是根据递减率减小的，递减率的设定影响着梳排序的效率，原作者以随机数作实验，得到最有效递减率为1.3的。因为编程中乘法比除法快，所以会取递减率的倒数与间距相乘，即0.8。其实当间距为1的时候，梳排序就是冒泡排序，而间距大于1的时候，梳排序的就是尽量把小的数字往前移动并保证此次间隔内的组是有序的。 举个例子：假设待数组[10 4 3 9 6 5 2 1 7 8] 待排数组长度为10,而10÷1.3=8,则比较10和7,4和8,并做交换。 交换后的结果为： [7 4 3 9 6 5 2 1 10 8] 第二次循环,更新间距为8÷1.3=6,比较7和2,4和1,3和10,9和8,7和2，4和1,9和8需要交换。 交换后的结果为： [2 1 3 8 6 5 7 4 10 9] 第三次循环,更新距离为4,比较2和6,1和5,3和7,8和4,6和10,5和9,8和4需要交换。 [2 1 3 4 6 5 7 8 10 9] 第四次循环,更新距离为3,比较2和4,1和6,3和5,4和7,6和8,5和10,7和9，不需要交换。 第五次循环,更新距离为2,比较2和3,1和4,3和6,4和5,6和7,5和8,7和10,8和9，不需要交换。 第六次循环，更新距离为1，为冒泡排序。 [1 2 3 4 5 6 7 8 9 10] 交换后排序结束,顺序输出即可得到[1 2 3 4 5 6 7 8 9 10]。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @date: 2019/6/26 1:27 * @description: 梳排序 */public class CombSort &#123; /** * 梳排序 * * @param unsorted 待排序列 */ public static void combSort(int[] unsorted) &#123; int gap = unsorted.length; boolean swapped = true; while (gap &gt; 1 || swapped) &#123; if (gap &gt; 1) &#123; gap = (int) (gap / 1.3); &#125; int i = 0; swapped = false; while (i + gap &lt; unsorted.length) &#123; if (unsorted[i] &gt; unsorted[i + gap]) &#123; swap(unsorted, i, i + gap); swapped = true; &#125; i++; &#125; &#125; &#125; /** * 按从小到大的顺序交换数组 * * @param a 传入的数组 * @param b 传入的要交换的数b * @param c 传入的要交换的数c */ public static void swap(int[] a, int b, int c) &#123; if (b == c) &#123; return; &#125; int temp = a[b]; a[b] = a[c]; a[c] = temp; &#125; public static void main(String[] args) &#123; int[] unsorted = &#123;11, 95, 45, 15, 78, 84, 51, 24, 12&#125;; System.out.println(&quot;**************梳排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(unsorted); System.out.println(&quot;排序后：&quot;); combSort(unsorted); CommonUtils.display(unsorted); &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 奇偶排序]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思路是奇数列排一趟序,偶数列排一趟序,再奇数排,再偶数排,直到全部有序。 举个例子：待排数组[6 2 4 1 5 9] 第一次比较奇数列,奇数列与它的邻居偶数列比较,如6和2比,4和1比,5和9比。 [6 2 4 1 5 9] 交换后变成 [2 6 1 4 5 9] 第二次比较偶数列,即6和1比,5和5比。 [2 6 1 4 5 9] 交换后变成 [2 1 6 4 5 9] 第三趟又是奇数列,选择的是2,6,5分别与它们的邻居列比较。 [2 1 6 4 5 9] 交换后 [1 2 4 6 5 9] 第四趟偶数列。 [1 2 4 6 5 9] 一次交换 [1 2 4 5 6 9] 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @date: 2019/6/26 0:06 * @description: 奇偶排序：基本思路是奇数列排一趟序,偶数列排一趟序,再奇数排,再偶数排,直到全部有序 */public class OddEventSort &#123; public static void oddEventSort(int[] unsorted) &#123; int temp; for (int i = unsorted.length - 1; i &gt; unsorted.length / 2 - 1; i--) &#123; //奇数排序 for (int j = 1; j &lt;= i; j += 2) &#123; if (j == unsorted.length - 1) &#123; break; &#125; if (unsorted[j] &gt; unsorted[j + 1]) &#123; temp = unsorted[j]; unsorted[j] = unsorted[j + 1]; unsorted[j + 1] = temp; &#125; &#125; //偶数排序 for (int j = 0; j &lt;= i; j += 2) &#123; if (j == unsorted.length - 1) &#123; break; &#125; if (unsorted[j] &gt; unsorted[j + 1]) &#123; temp = unsorted[j]; unsorted[j] = unsorted[j + 1]; unsorted[j + 1] = temp; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] unsorted = new int[]&#123;12, 33, 45, 33, 13, 55, 34, 7, 6&#125;; System.out.println(&quot;**************奇偶排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(unsorted); System.out.println(&quot;排序后：&quot;); oddEventSort(unsorted); CommonUtils.display(unsorted); &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 地精排序]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9C%B0%E7%B2%BE%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[号称最简单的排序算法,只有一层循环,默认情况下前进冒泡,一旦遇到冒泡的情况发生就往回冒,直到把这个数字放好为止。 举个例子：待排数组[6 2 4 1 5 9]。 先设计一个标识i=0然后从头开始判断,什么时候(i &lt; 6)不成立,什么时候排序结束。 [6 2 4 1 5 9] [0 1 2 3 4 5] 下具体的排序过程如下： [ i = 0 ]时啥也不干,先让i自增1,达到值为1才开始真正的比较。 交换前[6 2 4 1 5 9][ i = 0] 交换后[6 2 4 1 5 9][ i = 1] [ i = 1 ]比较6和2,发生交换,只要发生交换i就减1。 交换前[6 2 4 1 5 9][ i = 1] 交换后[2 6 4 1 5 9][ i = 0] [ i = 0 ]又成0了,啥也不干,自增变成1再说。 交换前[2 6 4 1 5 9][ i = 0] 交换后[2 6 4 1 5 9][ i = 1] [ i = 1 ]再比较2和6,不交换,只要不交换就自增1。 交换前[2 6 4 1 5 9][ i = 1] 交换后[2 6 4 1 5 9][ i = 2] [ i = 2 ]比较6和4,发生交换,只要交换就减1。 交换前[2 6 4 1 5 9][ i = 2] 交换后[2 4 6 1 5 9][ i = 1] [ i = 1 ]比较2和4,不交换,只要不交换就自增1。 交换前[2 4 6 1 5 9][ i = 1] 交换后[2 4 6 1 5 9][ i = 2] [ i = 2 ]比较4和6,不交换,只要不交换就自增1。 交换前[2 4 6 1 5 9][ i = 2] 交换后[2 4 6 1 5 9][ i = 3] [ i = 3 ]比较6和1,交换,只要交换就减1。 交换前[2 4 6 1 5 9][ i = 3] 交换后[2 4 1 6 5 9][ i = 2] [ i = 2 ]比较4和1,交换,只要交换就减1。 交换前[2 4 1 6 5 9][ i = 2] 交换后[2 1 4 6 5 9][ i = 1] [ i = 1 ]比较2和1,交换,只要交换就减1。 交换前[2 1 4 6 5 9][ i = 1] 交换后[1 2 4 6 5 9][ i = 0] [ i = 0 ]时啥也不干,先让i自增1,达到值为1才开始真正的比较。 交换前[1 2 4 6 5 9][ i = 0] 交换后[1 2 4 6 5 9][ i = 1] [ i = 1]比较1和2,不交换,只要不交换就自增1。 [ i = 2]比较2和4,不交换,只要不交换就自增1。 [ i = 3]比较4和6,不交换,只要不交换就自增1。 [ i = 4]比较6和5,交换,只要交换就减1。 交换前[1 2 4 6 5 9][ i = 4] 交换后[1 2 4 5 6 9][ i = 3] [ i = 3]比较4和5,不交换,只要不交换就自增1。 [ i = 4]比较5和6,不交换,只要不交换就自增1。 [ i = 5]比较6和9,不交换,只要不交换就自增1。 [ i = 6]表达式(i &lt; n)不成立,排序结束。 顺序输出结果即可:[ 1 2 4 5 6 9]。 代码如下：1234567891011121314151617181920212223242526272829303132333435package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @date: 2019/6/25 23:48 * @description: 地精排序：号称最简单的排序算法,只有一层循环,默认情况下前进冒泡,一旦遇到冒泡的情况发生就往回冒,直到把这个数字放好为止。 */public class GnomeSort &#123; public static void gnomeSort(int[] unsorted) &#123; int i = 0; while (i &lt; unsorted.length) &#123; if (i == 0 || unsorted[i - 1] &lt;= unsorted[i]) &#123; i++; &#125; else &#123; int temp = unsorted[i]; unsorted[i] = unsorted[i - 1]; unsorted[i - 1] = temp; i--; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] unsorted = &#123;6, 2, 4, 1, 5, 9&#125;; System.out.println(&quot;**************地精排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(unsorted); System.out.println(&quot;排序后：&quot;); gnomeSort(unsorted); CommonUtils.display(unsorted); &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 鸡尾酒排序]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[鸡尾酒排序基于冒泡排序,双向循环。 举个例子：给定待排数组[2 3 4 5 1] 第一趟过去时的每一步。 第一步迭代,2 &lt; 3不换 [2 3 4 5 1] 第二步迭代,3 &lt; 4不换 [2 3 4 5 1] 第三步迭代,4 &lt; 5不换 [2 3 4 5 1] 第四步迭代,5 &gt; 1交换 [2 3 4 1 5] 第一趟回来时的第一步,鸡尾酒一次到头后就回返回来,再到头后再过去,来回比,一个来回能排两个数字。 第五步迭代,1 &lt; 5不交换 [2 3 4 1 5] 第六步迭代,1 &lt; 4交换 [2 3 1 4 5] 第七步迭代,1 &lt; 3交换 [2 1 3 4 5] 第八步迭代,2 &gt; 1交换 [1 2 3 4 5] 排序完毕,顺序输出结果即可得[ 1 2 3 4 5]。 如何判断排序结束了? 假如一趟来回没有交换任何数字,则表示该数组已经有序了,可以设置了个变量表示有没有交换过。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @date: 2019/6/25 23:12 * @description: 鸡尾酒排序 基于冒泡排序,双向循环 */public class CocktailSort &#123; public static void cocktailSort(int[] unsorted) &#123; boolean swapped = false; do &#123; for (int i = 0; i &lt; unsorted.length - 1; i++) &#123; if (unsorted[i] &gt; unsorted[i + 1]) &#123; int temp = unsorted[i]; unsorted[i] = unsorted[i + 1]; unsorted[i + 1] = temp; swapped = true; &#125; &#125; swapped = false; for (int j = unsorted.length - 1; j &gt; 0; j--) &#123; if (unsorted[j] &lt; unsorted[j - 1]) &#123; int temp = unsorted[j]; unsorted[j] = unsorted[j - 1]; unsorted[j - 1] = temp; swapped = true; &#125; &#125; &#125; while (swapped); &#125; public static void main(String[] args) &#123; int[] unsorted = &#123;6, 2, 4, 1, 5, 9&#125;; System.out.println(&quot;**************鸡尾酒排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(unsorted); System.out.println(&quot;排序后：&quot;); cocktailSort(unsorted); CommonUtils.display(unsorted); &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 鸽巢排序]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E9%B8%BD%E5%B7%A2%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[鸽巢排序是桶排序的一种，顾名思义，就是一排鸽巢，看里面有几个鸽巢，然后遍历这些鸽巢，打印出来就好，排序之前得先知道区间和最大值。 比如有数组a = [2,7,5,9,8,8]，我们需要对这个数组进行排序，这是一个最大值不超过10的数组，那么我们定区间为0-10，定义一个下标0-10这样一个11位数组b,初始化值为0。然后遍历已知数组a，通过a的一项一项的值和我们定义的数组b的下标进行对应。 遍历开始： 取a[0]=2，然后操作b[2]=1 取a[1]=7，然后操作b[7]=1 取a[2]=5，然后操作b[5]=1 取a[3]=9，然后操作b[9]=1 取a[4]=8，然后操作b[8]=1 取a[5]=8，然后操作b[8]=2（注意了哦） 这样就对号入座了，之后遍历b，如果b中某个小标对应的值是多个，则遍历多次，把不是0的给打印出来，结果就是我们想要的了 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @date: 2019/6/25 19:59 * @description: 鸽巢排序 * 原理类似桶排序,同样需要一个很大的鸽巢[桶排序里管这个叫桶,名字无所谓] * 鸽巢其实就是数组,数组的索引位置就表示值,该索引位置的值表示出现次数,如果全部为1次或0次那就是桶排序 * 例如 * int[] pigeonHole = new int[100]; * pigeonHole[0]的值表示0的出现次数... * pigeonHole[1]的值表示1的出现次数... * pigeonHole[2]的值表示2的出现次数... */public class PigeonholeSort &#123; /** * 鸽巢排序 * * @param unsorted 待排序列 * @param maxNumber 最大数 * @return */ public static int[] pigeonholeSort(int[] unsorted, int maxNumber) &#123; int[] pogeonHole = new int[maxNumber + 1]; for (int item : unsorted) &#123; pogeonHole[item]++; &#125; return pogeonHole; &#125; public static void main(String[] args) &#123; int[] unsorted = &#123;99, 65, 24, 47, 47, 50, 99, 88, 66, 33, 66, 67, 31, 18, 24&#125;; System.out.println(&quot;**************鸽巢排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(unsorted); int[] sorted = pigeonholeSort(unsorted, 99); System.out.println(&quot;排序后：&quot;); for (int i = 0; i &lt; sorted.length; i++) &#123; for (int j = 0; j &lt; sorted[i]; j++) &#123; System.out.print(i + &quot; &quot;); &#125; &#125; &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 基数排序]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基数排序过程无须比较关键字，而是通过“分配”和“收集”过程来实现排序。它们的时间复杂度可达到线性阶：O(n)。 实例:扑克牌中52张牌，可按花色和面值分成两个字段，其大小关系为： 花色： 梅花&lt; 方块&lt; 红心&lt; 黑心 面值： 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A若对扑克牌按花色、面值进行升序排序，得到如下序列： 即两张牌，若花色不同，不论面值怎样，花色低的那张牌小于花色高的，只有在同花色情况下，大小关系才由面值的大小确定。这就是多关键码排序。为得到排序结果，我们讨论两种排序方法。方法1：先对花色排序，将其分为4 个组，即梅花组、方块组、红心组、黑心组。再对每个组分别按面值进行排序，最后，将4 个组连接起来即可。方法2：先按13 个面值给出13 个编号组(2 号，3 号，…，A 号)，将牌按面值依次放入对应的编号组，分成13 堆。再按花色给出4 个编号组(梅花、方块、红心、黑心)，将2号组中牌取出分别放入对应花色组，再将3 号组中牌取出分别放入对应花色组，……，这样，4 个花色组中均按面值有序，然后，将4 个花色组依次连接起来即可。设n 个元素的待排序列包含d 个关键码{k1，k2，…，kd}，则称序列对关键码{k1，k2，…，kd}有序是指：对于序列中任两个记录r[i]和rj都满足下列有序关系： 其中k1 称为最主位关键码，kd 称为最次位关键码。 两种多关键码排序方法：多关键码排序按照从最主位关键码到最次位关键码或从最次位到最主位关键码的顺序逐次排序，分两种方法： 最高位优先(Most Significant Digit first)法，简称MSD 法： 1）先按k1 排序分组，将序列分成若干子序列，同一组序列的记录中，关键码k1 相等。 2）再对各组按k2 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd 对各子组排序后。 3）再将各组连接起来，便得到一个有序序列。扑克牌按花色、面值排序中介绍的方法一即是MSD 法。 最低位优先(Least Significant Digit first)法，简称LSD 法： 1) 先从kd 开始排序，再对kd-1进行排序，依次重复，直到按k1排序分组分成最小的子序列后。 2) 最后将各个子序列连接起来，便可得到一个有序的序列, 扑克牌按花色、面值排序中介绍的方法二即是LSD 法。基于LSD方法的链式基数排序的基本思想 “多关键字排序”的思想实现“单关键字排序”。对数字型或字符型的单关键字，可以看作由多个数位或多个字符构成的多关键字，此时可以采用“分配-收集”的方法进行排序，这一过程称作基数排序法，其中每个数字或字符可能的取值个数称为基数。比如，扑克牌的花色基数为4，面值基数为13。在整理扑克牌时，既可以先按花色整理，也可以先按面值整理。按花色整理时，先按红、黑、方、花的顺序分成4摞（分配），再按此顺序再叠放在一起（收集），然后按面值的顺序分成13摞（分配），再按此顺序叠放在一起（收集），如此进行二次分配和收集即可将扑克牌排列有序。基数排序:是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @date: 2019/6/25 15:53 * @description: 基数排序：过程无须比较关键字，而是通过“分配”和“收集”过程来实现排序。 * 平均O(d(n+r)),最好O(d(n+r)),最坏O(d(n+r));空间复杂度O(n+r);稳定;较复杂 * d为位数,r为分配后链表的个数 */public class RadixSort &#123; /** * 基数排序 * * @param unsorted 待排数组 * @param max 最大几位数 */ public static void radixSort(int[] unsorted, int max) &#123; //count数组用来计数 int[] count = new int[unsorted.length]; //bucket用来当桶，放数据，取数据 int[] bucket = new int[unsorted.length]; //k表示第几位，1代表个位，2代表十位，3代表百位 for (int k = 1; k &lt;= max; k++) &#123; //把count置空，防止上次循环的数据影响 for (int i = 0; i &lt; unsorted.length; i++) &#123; count[i] = 0; &#125; //分别统计第k位是0,1,2,3,4,5,6,7,8,9的数量 //以下便称为桶 //即此循环用来统计每个桶中的数据的数量 for (int i = 0; i &lt; unsorted.length; i++) &#123; count[getFigure(unsorted[i], k)]++; &#125; //利用count[i]来确定放置数据的位置 for (int i = 1; i &lt; unsorted.length; i++) &#123; count[i] = count[i] + count[i - 1]; &#125; //执行完此循环之后的count[i]就是第i个桶右边界的位置 //利用循环把数据装入各个桶中，注意是从后往前装 for (int i = unsorted.length - 1; i &gt;= 0; i--) &#123; int j = getFigure(unsorted[i], k); bucket[count[j] - 1] = unsorted[i]; count[j]--; &#125; //将桶中的数据取出来，赋值给unsorted for (int i = 0, j = 0; i &lt; unsorted.length; i++, j++) &#123; unsorted[i] = bucket[j]; &#125; &#125; &#125; /** * 返回整型数num的第pos位是什么 * * @param num 整数num * @param pos pos=1表示个位，pos=2表示十位 * @return */ public static int getFigure(int num, int pos) &#123; int tmp = 1; for (int i = 0; i &lt; pos - 1; i++) &#123; tmp *= 10; &#125; return (num / tmp) % 10; &#125; /** * 二维数组的方式实现基数排序 * * @param unsorted 待排序列 * @param arr_x 最大数字不超过999999999...(array_x个9) * @param arr_y 最大位数 */ public static void radix_sort(int[] unsorted, int arr_x, int arr_y) &#123; for (int i = 0; i &lt; arr_x; i++) &#123; int[][] bucket = new int[arr_x][arr_y]; //分配 for (int item : unsorted) &#123; int temp = (item / (int) Math.pow(10, i)) % 10; for (int j = 0; j &lt; arr_y; j++) &#123; if (bucket[temp][j] == 0) &#123; bucket[temp][j] = item; break; &#125; &#125; &#125; //收集 for (int o = 0, x = 0; x &lt; arr_x; x++) &#123; for (int y = 0; y &lt; arr_y; y++) &#123; if (bucket[x][y] == 0) &#123; continue; &#125; unsorted[o++] = bucket[x][y]; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; //定义待排整型数组 int[] arr = &#123;21, 56, 88, 195, 354, 1, 35, 12, 6, 7&#125;; System.out.println(&quot;**************基数排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(arr); //调用基数排序函数 radixSort(arr, 3); System.out.println(&quot;排序后：&quot;); //输出排序后的数组 CommonUtils.display(arr); System.out.println(&quot; &quot;); int[] unsorted = &#123;999999999, 65, 24, 47, 13, 50, 92, 88, 66, 33, 22445, 10001, 624159, 624158, 624155501&#125;; System.out.println(&quot;**************二维数组方式实现的基数排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(unsorted); radix_sort(unsorted, 10, 100); System.out.println(&quot;排序后：&quot;); for (int tmp : unsorted) &#123; if (tmp &gt; 0) &#123; System.out.print(tmp + &quot; &quot;); &#125; &#125; &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哆啦A梦]]></title>
    <url>%2F2019%2F06%2F25%2F%E5%93%86%E5%95%A6A%E6%A2%A6.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;title&gt;哆啦A梦&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; &#125; #doraemon &#123; background-color: #fff; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body onmousemove=&quot;zuobiao(event)&quot;&gt;&lt;canvas id=&quot;doraemon&quot; width=&quot;400&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;&lt;div id=&quot;put&quot; style=&quot;width: 50px&quot; height=&quot;20px&quot;&gt;&lt;/div&gt;&lt;script&gt; window.onload = function () &#123; var cxt = document.getElementById(&apos;doraemon&apos;).getContext(&apos;2d&apos;); /* 头部*/ cxt.beginPath();//起始路径 cxt.lineWidth = 1;//线宽度为1 cxt.strokeStyle = &apos;#000&apos;;//笔触的颜色 cxt.arc(200, 175, 175, 0.7 * Math.PI, 0.3 * Math.PI);//绘制弧，中心点（200，175），半径175 cxt.fillStyle = &apos;#0bb0da&apos;;//设置填充时的颜色 cxt.fill();//填充颜色 cxt.stroke();//绘制路径 /*脸部*/ cxt.beginPath(); cxt.fillStyle = &apos;#fff&apos;; cxt.moveTo(110, 110);//将路径移到点（110，110），不创建线条 cxt.quadraticCurveTo(-10, 200, 120, 315);//创建二次贝塞尔曲线,控制点(-10,200),结束点(120,315) cxt.lineTo(280, 315);//添加一个新点，然后在画布中创建从（110，110）到（280，315）的线条 cxt.quadraticCurveTo(410, 210, 290, 110); cxt.lineTo(110, 110); cxt.fill(); cxt.stroke(); /*眼睛*/ cxt.beginPath(); cxt.lineWidth = 1; cxt.fillStyle = &apos;#fff&apos;; cxt.moveTo(110, 110); cxt.bezierCurveTo(110, 25, 200, 25, 200, 100);//创建三次贝塞尔曲线,控制点1(110,25),控制点2(200,25),结束点(200,100)，也就是画左上半椭圆 cxt.bezierCurveTo(200, 175, 110, 175, 110, 100);//画左下半椭圆 cxt.moveTo(200, 100); cxt.bezierCurveTo(200, 25, 290, 25, 290, 100); cxt.bezierCurveTo(290, 175, 200, 175, 200, 100); cxt.fill(); cxt.stroke(); /*右眼球*/ cxt.beginPath(); cxt.fillStyle = &apos;#000&apos;; cxt.arc(230, 130, 12, 0, 2 * Math.PI); cxt.fill(); cxt.stroke(); /*左眼球*/ cxt.beginPath(); cxt.fillStyle = &apos;#000&apos;; cxt.arc(170, 130, 12, 0, 2 * Math.PI); cxt.fill(); cxt.stroke(); /* 鼻子*/ cxt.beginPath(); cxt.arc(200, 165, 25, 0, 2 * Math.PI); cxt.fillStyle = &apos;#d05823&apos;; cxt.fill(); cxt.stroke(); /*胡须*/ //左胡须 cxt.beginPath(); cxt.moveTo(80, 175); cxt.lineTo(150, 195); cxt.moveTo(80, 200); cxt.lineTo(150, 205); cxt.moveTo(80, 225); cxt.lineTo(150, 215); //中部胡须 cxt.moveTo(200, 195); cxt.lineTo(200, 290); //右胡须 cxt.moveTo(250, 195); cxt.lineTo(320, 175); cxt.moveTo(250, 205); cxt.lineTo(320, 200); cxt.moveTo(250, 215); cxt.lineTo(320, 225); cxt.stroke(); /*嘴*/ cxt.moveTo(80, 240); cxt.quadraticCurveTo(200, 350, 320, 240); cxt.stroke(); /*围巾*/ cxt.beginPath(); cxt.moveTo(96, 316); cxt.lineTo(305, 316); cxt.lineTo(320, 316); cxt.arcTo(330, 316, 330, 326, 10);//在画布上创建介于两个切线之间的弧，起点坐标为(330,316),终点坐标为(330,326),半径为10 cxt.lineTo(330, 336); cxt.arcTo(330, 346, 305, 346, 10); cxt.lineTo(81, 346); cxt.arcTo(71, 346, 71, 336, 10); cxt.lineTo(71, 326); cxt.arcTo(71, 316, 81, 316, 10); cxt.lineTo(96, 316); cxt.fillStyle = &apos;#b13209&apos;; cxt.fill(); cxt.stroke(); /*下半身*/ cxt.beginPath(); cxt.fillStyle = &apos;#0bb0da&apos;; cxt.moveTo(80, 346); //左衣服 cxt.lineTo(26, 406); cxt.lineTo(65, 440); cxt.lineTo(85, 418); cxt.lineTo(85, 528); cxt.lineTo(185, 528); //右衣服 cxt.lineTo(315, 528); cxt.lineTo(315, 418); cxt.lineTo(337, 440); cxt.lineTo(374, 406); cxt.lineTo(320, 346); cxt.fill(); cxt.stroke(); /*手*/ //左手 cxt.beginPath(); cxt.fillStyle = &apos;#fff&apos;; cxt.arc(37, 433, 30, 0, 2 * Math.PI); cxt.fill(); cxt.stroke(); //右手 cxt.beginPath(); cxt.fillStyle = &apos;#fff&apos;; cxt.arc(363, 433, 30, 0, 2 * Math.PI); cxt.fill(); cxt.stroke(); /*肚*/ cxt.beginPath(); cxt.fillStyle = &apos;#fff&apos;; cxt.arc(200, 400, 91, 1.8 * Math.PI, 1.2 * Math.PI); cxt.fill(); cxt.stroke(); //小口袋 cxt.beginPath(); cxt.fillStyle = &apos;#fff&apos;; cxt.moveTo(130, 394); cxt.lineTo(270, 394); cxt.moveTo(130, 394); cxt.bezierCurveTo(130, 490, 270, 490, 270, 394); cxt.fill(); cxt.stroke(); /*两只脚的空隙*/ cxt.beginPath(); cxt.fillStyle = &apos;#fff&apos;; cxt.arc(200, 529, 20,Math.PI, 0); cxt.fill(); cxt.stroke(); /*脚*/ //左脚 cxt.beginPath(); cxt.fillStyle=&apos;#fff&apos;; cxt.moveTo(180,528); cxt.lineTo(72,528); cxt.bezierCurveTo(52,528,52,558,72,558); cxt.lineTo(180,558); cxt.moveTo(180,558); cxt.bezierCurveTo(200,558,200,528,180,528); cxt.fill(); cxt.stroke(); //右脚 cxt.beginPath(); cxt.fillStyle=&apos;#fff&apos;; cxt.moveTo(220,528); cxt.lineTo(328,528); cxt.bezierCurveTo(348,528,348,558,328,558); cxt.lineTo(220,558); cxt.moveTo(220,558); cxt.bezierCurveTo(200,558,200,528,220,528); cxt.fill(); cxt.stroke(); &#125;; //显示坐标 function zuobiao(event) &#123; var x = event.clientX; var y = event.clientY; var out = document.getElementById(&quot;put&quot;); out.innerHTML = &quot;x:&quot; + x + &quot; y:&quot; + y; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下：]]></content>
      <categories>
        <category>Html</category>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 桶排序]]></title>
    <url>%2F2019%2F06%2F25%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%A1%B6%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想：是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。 例如要对大小为[1..1000]范围内的n个整数A[1..n]排序。首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储(10..20]的整数，……集合B[i]存储((i-1)10, i10]的整数，i = 1,2,..100。总共有100个桶。然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任何排序法都可以。最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这样就得到所有数字排好序的一个序列了。假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果对每个桶中的数字采用快速排序，那么整个算法的复杂度是O(n + m * n/m*log(n/m)) = O(n + nlogn - nlogm)从上式看出，当m接近n的时候，桶排序复杂度接近O(n)。 当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的 ，实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。 桶排序的缺点是：1）首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。2）其次待排序的元素都要在一定的范围内等等。桶式排序是一种分配排序。分配排序的特点是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。 例如待排数字[6 2 4 1 5 9] 准备10个空桶,最大数个空桶 [6 2 4 1 5 9] 待排数组 [0 0 0 0 0 0 0 0 0 0] 空桶 [0 1 2 3 4 5 6 7 8 9] 桶编号(实际不存在) 1,顺序从待排数组中取出数字,首先6被取出,然后把6入6号桶,这个过程类似这样:空桶[ 待排数组[ 0 ] ] = 待排数组[ 0 ] [6 2 4 1 5 9] 待排数组 [0 0 0 0 0 0 6 0 0 0] 空桶 [0 1 2 3 4 5 6 7 8 9] 桶编号(实际不存在) 2,顺序从待排数组中取出下一个数字,此时2被取出,将其放入2号桶,是几就放几号桶 [6 2 4 1 5 9] 待排数组 [0 0 2 0 0 0 6 0 0 0] 空桶 [0 1 2 3 4 5 6 7 8 9] 桶编号(实际不存在) 3,4,5,6省略,过程一样,全部入桶后变成下边这样 [6 2 4 1 5 9] 待排数组 [0 1 2 0 4 5 6 0 0 9] 空桶 [0 1 2 3 4 5 6 7 8 9] 桶编号(实际不存在) 0表示空桶,跳过,顺序取出即可:1 2 4 5 6 9 代码如下：1234567891011121314151617181920212223242526272829303132333435363738package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @date: 2019/6/25 15:15 * @description: 桶排序 */public class BucketSort &#123; /** * 是将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。 * 桶排序是鸽巢排序的一种归纳结果。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。 * 但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。 */ public static int[] bucketSort(int[] unsorted, int maxNumber) &#123; int[] sorted = new int[maxNumber + 1]; for (int i = 0; i &lt; unsorted.length; i++) &#123; sorted[unsorted[i]] = unsorted[i]; &#125; return sorted; &#125; public static void main(String[] args) &#123; int[] unsorted = &#123;99, 65, 24, 47, 50, 88, 33, 66, 67, 31, 18&#125;; int[] sorted = bucketSort(unsorted, 99); System.out.println(&quot;**************桶排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(unsorted); System.out.println(&quot;排序后：&quot;); for (int tmp : sorted) &#123; if (tmp &gt; 0) &#123; System.out.print(tmp + &quot; &quot;); &#125; &#125; &#125;&#125; 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 归并排序]]></title>
    <url>%2F2019%2F06%2F25%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 算法步骤： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针到达序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 算法流程图： 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @date: 2019/6/24 14:13 * @description: 归并排序 */public class MergeSort &#123; /** * 归并排序（Merge Sort）与快速排序思想类似：将待排序数据分成两部分，继续将两个子部分进行递归的归并排序；然后将已经有序的两个子部分进行合并，最终完成排序。 * 其时间复杂度与快速排序均为O(nlogn)，但是归并排序除了递归调用间接使用了辅助空间栈，还需要额外的O(n)空间进行临时存储。从此角度归并排序略逊于快速排序，但是归并排序是一种稳定的排序算法，快速排序则不然。 * 所谓稳定排序，表示对于具有相同值的多个元素，其间的先后顺序保持不变。对于基本数据类型而言，一个排序算法是否稳定，影响很小，但是对于结构体数组，稳定排序就十分重要。例如对于student结构体按照关键字score进行非降序排序： */ public static void mergeSort(int[] numArr, int[] tempArr, int head, int rear) &#123; if (head &lt; rear) &#123; //取分割位置 int middle = (head + rear) / 2; //递归划分列表的左序列 mergeSort(numArr, tempArr, head, middle); //递归划分列表的右序列 mergeSort(numArr, tempArr, middle + 1, rear); //列表的合并 merge(numArr, tempArr, head, middle + 1, rear); &#125; &#125; /** * 合并操作(列表的两两合并) * * @param numArr * @param tempArr * @param head * @param middle * @param rear */ public static void merge(int[] numArr, int[] tempArr, int head, int middle, int rear) &#123; //左指针尾 int headEnd = middle - 1; //右指针头 int rearStart = middle; //临时表的下标 int tempIndex = head; //列表合并后的长度 int tempLength = rear - head + 1; //先循环两个区间段都没有结束的情况 while ((headEnd &gt;= head) &amp;&amp; (rearStart &lt;= rear)) &#123; //如果发现右序列大，则将此数放入临时列表 if (numArr[head] &lt; numArr[rearStart]) &#123; tempArr[tempIndex++] = numArr[head++]; &#125; else &#123; tempArr[tempIndex++] = numArr[rearStart++]; &#125; &#125; //判断左序列是否结束 while (head &lt;= headEnd) &#123; tempArr[tempIndex++] = numArr[head++]; &#125; //判断右序列是否结束 while (rearStart &lt;= rear) &#123; tempArr[tempIndex++] = numArr[rearStart++]; &#125; //交换数据 for (int i = 0; i &lt; tempLength; i++) &#123; numArr[rear] = tempArr[rear]; rear--; &#125; &#125; public static void main(String[] args) &#123; int[] numArr = &#123;27, 11, 13, 45, 34, 22, 19, 8, 3, 99, 74, 55, 88, 66&#125;; System.out.println(&quot;**************归并排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(numArr); System.out.println(&quot;排序后：&quot;); mergeSort(numArr, new int[numArr.length], 0, numArr.length - 1); CommonUtils.display(numArr); &#125;&#125; CommonUtils工具类：1234567891011121314151617181920212223package main.java.com.study.utils;/** * @author: whb * @date: 2019/6/24 14:53 * @description: 工具类 */public class CommonUtils &#123; /** * 遍历打印 * * @param numArr */ public static void display(int[] numArr) &#123; if (numArr != null &amp;&amp; numArr.length &gt; 0) &#123; for (int num : numArr) &#123; System.out.print(num + &quot; &quot;); &#125; &#125; System.out.println(&quot;&quot;); &#125;&#125; 测试结果如下:]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 希尔排序]]></title>
    <url>%2F2019%2F06%2F25%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想： 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。希尔排序，也称递减增量排序算法，是插入排序的一种高速而稳定的改进版本。 操作方法： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 算法流程图: 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @date: 2019/6/24 14:14 * @description: 希尔排序 */public class ShellSort &#123; /** * 希尔排序（Shell’s Sort）又称“缩小增量排序”(Diminishing Increment Sort)，它也是一种属于插入排序类的方法，但在时间效率上比直接插入排序方法有较大的改进。 * 从对直接插入排序的分析可知，其算法时间复杂度为O(n2)，但是，若待排记录序列为“正序”时，其时间复杂度可提高至O(n)。 * 由此设想，若待排记录序列按关键字“基本有序”，直接插入排序的效率就可以大大提高。 * 从另一方面来看，由于直接插入排序算法简单，所以在n值很小时效率比较高。希尔排序正是从这两点分析出发对直接插入排序进行改进而得到的一种插入排序方法。 * &lt;p&gt; * 希尔排序的基本思想是：先将整个待排序列分割成若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。（这是《数据结构》这本书里的说法。） * &lt;p&gt; * 通俗点说就是：先取较大的步长对待排序列进行直接插入排序，每排一次就缩小一次步长，再进行插入排序，直到最后步长变为1。 */ public static void shellSort(int[] numArr) &#123; int length = numArr.length; //取增量 int gap = length / 2; while (gap &gt;= 1) &#123; //无序序列 for (int i = gap; i &lt; length; i++) &#123; int temp = numArr[i]; int j; //有序序列 for (j = i - gap; j &gt;= 0 &amp;&amp; numArr[j] &gt; temp; j = j - gap) &#123; numArr[j + gap] = numArr[j]; &#125; numArr[j + gap] = temp; &#125; //缩小增量 gap = gap / 2; &#125; &#125; public static void main(String[] args) &#123; int[] numArr = &#123;27, 11, 13, 45, 34, 22, 19, 8, 3, 99, 74, 55, 88, 66&#125;; System.out.println(&quot;**************希尔排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(numArr); System.out.println(&quot;排序后：&quot;); shellSort(numArr); CommonUtils.display(numArr); &#125;&#125; CommonUtils工具类：1234567891011121314151617181920212223package main.java.com.study.utils;/** * @author: whb * @date: 2019/6/24 14:53 * @description: 工具类 */public class CommonUtils &#123; /** * 遍历打印 * * @param numArr */ public static void display(int[] numArr) &#123; if (numArr != null &amp;&amp; numArr.length &gt; 0) &#123; for (int num : numArr) &#123; System.out.print(num + &quot; &quot;); &#125; &#125; System.out.println(&quot;&quot;); &#125;&#125; 测试结果如下:]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 快速排序]]></title>
    <url>%2F2019%2F06%2F25%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想： 1）选择一个基准元素,通常选择第一个元素或者最后一个元素, 2）如果选择第一个元素作为基准元素，则先从右向左找比基准元素小的元素，再从左向右找比基准元素大的元素，交换这两个元素的位置。（如果选择最后一个元素做基准元素，则先从左向右找）直到找到同一位置，跟基准元素位置交换，第一趟排序就结束。 3）通过一趟排序将记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的元素值比基准值大。 4）此时基准元素在其排好序后的正确位置 5）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。 算法流程图： 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @date: 2019/6/24 14:13 * @description: 快速排序 */public class QuickSort &#123; /** * 快速排序的基本思想是，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 * &lt;p&gt; * 一趟快速排序（或一次划分）的过程如下：首先任意选取一个记录（通常可选第一个记录）作为枢轴（或支点）（pivot），然后按下列原则重新排列其余记录：将所有关键字比它小的记录都安置在它的位置之前，将所有关键字比它大的记录都安置在它的位置之后。 * &lt;p&gt; * 经过一趟快速排序之后，以该枢轴记录最后所落的位置i作分界线，将序列分割成两个子序列，之后再分别对分割所得的两个子序列进行快速排序。 * &lt;p&gt; * 可以看出这个算法可以递归实现，可以用一个函数来实现划分，并返回分界位置。然后不断地这么分下去直到排序完成，可以看出函数的输入参数需要提供序列的首尾位置。 */ public static void quickSort(int[] numArr, int left, int right) &#123; //不管使用哪种分割方式，都可以通过递归形式进行排序 // 需要注意的是这个if语句不能少，不然没法停止，会导致堆栈溢出的异常。 if (left &lt; right) &#123; //分割数组，找到分割点 int point = partitionTwo(numArr, left, right); //递归调用，对左子数组进行快速排序 quickSort(numArr, left, point - 1); //递归调用，对右子数组进行快速排序 quickSort(numArr, point + 1, right); &#125; &#125; /** * 划分实现1 （枢轴跳来跳去法） * 一趟快速排序的实现：设两个指针left和right，设枢轴记录的关键字为first，则首先从right所指位置起向前搜索找到第一个关键字小于first的记录和枢轴记录互相交换， * 然后从left所指位置起向后搜索，找到第一个关键字大于first的记录和枢轴记录互相交换，重复这两步直至left==right为止。 */ public static int partitionOne(int[] numArr, int left, int right) &#123; //用数组的第一个元素做基准元素 int first = numArr[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; numArr[right] &gt;= first) &#123; right--; &#125; //交换 swap(numArr, left, right); while (left &lt; right &amp;&amp; numArr[left] &lt;= first) &#123; left++; &#125; //交换 swap(numArr, left, right); &#125; //返回分割点所在的位置 return left; &#125; /** * 划分实现2 （枢轴一次到位法） * partitionOne实现可以看出，枢轴元素（即最开始选的“中间”元素（其实往往是拿第一个元素作为“中间”元素））需要不断地和其他元素交换位置，而每交换一次位置实际上需要三次赋值操作。 * &lt;p&gt; * 实际上，只有最后left=right的位置才是枢轴元素的最终位置，所以可以先将枢轴元素保存起来，排序过程中只作元素的单向移动，直至一趟排序结束后再将枢轴元素移至正确的位置上。 * * @return */ public static int partitionTwo(int[] numArr, int left, int right) &#123; int first = numArr[left]; int temp = numArr[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; numArr[right] &gt;= first) &#123; right--; &#125; numArr[left] = numArr[right]; while (left &lt; right &amp;&amp; numArr[left] &lt;= first) &#123; left++; &#125; numArr[right] = numArr[left]; &#125; numArr[left] = temp; return left; &#125; /** * 交换数组中两个位置的元素 */ public static void swap(int[] numArr, int left, int right) &#123; int temp = 0; if (numArr != null &amp;&amp; numArr.length &gt; 0) &#123; temp = numArr[left]; numArr[left] = numArr[right]; numArr[right] = temp; &#125; &#125; public static void main(String[] args) &#123; int[] numArr = &#123;27, 11, 13, 45, 34, 22, 19, 8, 3, 99, 74, 55, 88, 66&#125;; System.out.println(&quot;**************快速排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(numArr); System.out.println(&quot;排序后：&quot;); quickSort(numArr, 0, numArr.length - 1); CommonUtils.display(numArr); &#125;&#125; CommonUtils工具类：1234567891011121314151617181920212223package main.java.com.study.utils;/** * @author: whb * @date: 2019/6/24 14:53 * @description: 工具类 */public class CommonUtils &#123; /** * 遍历打印 * * @param numArr */ public static void display(int[] numArr) &#123; if (numArr != null &amp;&amp; numArr.length &gt; 0) &#123; for (int num : numArr) &#123; System.out.print(num + &quot; &quot;); &#125; &#125; System.out.println(&quot;&quot;); &#125;&#125; 测试结果如下:]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 堆排序]]></title>
    <url>%2F2019%2F06%2F25%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[堆排序是一种树形选择排序，是对直接选择排序的有效改进。 基本思想：堆的定义如下：具有n个元素的序列（k1,k2,…,kn),当且仅当满足 时称之为堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最小项（小顶堆）。 若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。如：（a）大顶堆序列：（96, 83,27,38,11,09)（b）小顶堆序列：（12，36，24，85，47，30，53，91） 初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储顺序，使之成为一个堆，将堆顶元素输出，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。因此，实现堆排序需解决两个问题： 如何将n 个待排序的数建成堆； 输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。 首先讨论第二个问题：输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。 调整小顶堆的方法： 1）设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。 2）将根结点与左、右子树中较小元素的进行交换。 3）若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）. 4）若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）. 5）继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。称这个自根结点到叶子结点的调整过程为筛选。如图： 再讨论对n 个元素初始建堆的过程。建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。1）n 个结点的完全二叉树，则最后一个结点是第个结点的子树。2）筛选从第 个结点为根的子树开始，该子树成为堆。3）之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49） 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @date: 2019/6/24 14:12 * @description: 堆排序 */public class HeapSort &#123; /** * 堆排序的是集合了插入排序的单数组操作，又有归并排序的时间复杂度，完美的结合了2者的优点。 */ public static void heapSort(int[] numArr) &#123; //将无序堆构造成一个大根堆，大根堆有length/2个父节点 for (int i = numArr.length / 2 - 1; i &gt;= 0; i--) &#123; headAdjust(numArr, i, numArr.length); &#125; //逐步将每个最大值的根节点与末尾元素交换，并且再调整其为最大堆 for (int i = numArr.length - 1; i &gt; 0; i--) &#123; //将堆顶元素和当前未经排序的子序列的最后一个元素交换位置 swap(numArr, 0, i); headAdjust(numArr, 0, i); &#125; &#125; /** * 构造大根堆 */ public static void headAdjust(int[] numArr, int parent, int length) &#123; //保存当前父节点 int temp = numArr[parent]; //得到左孩子 int leftChild = 2 * parent + 1; while (leftChild &lt; length) &#123; //如果parent有左孩子，则要判断左孩子是否小于右孩子 if (leftChild + 1 &lt; length &amp;&amp; numArr[leftChild] &lt; numArr[leftChild + 1]) &#123; leftChild++; &#125; //如果父节点大于子节点，就不交换 if (temp &gt;= numArr[leftChild]) &#123; break; &#125; //将较大子节点的值赋给父节点 numArr[parent] = numArr[leftChild]; //然后将子节点作为父节点 parent = leftChild; //找到该父节点较小的左孩子 leftChild = 2 * parent + 1; &#125; //最后将temp的值赋给较大的子节点，以形成两值交换 numArr[parent] = temp; &#125; /** * 交换数组中两个位置的元素 */ public static void swap(int[] numArr, int top, int last) &#123; int temp = numArr[top]; numArr[top] = numArr[last]; numArr[last] = temp; &#125; public static void main(String[] args) &#123; int[] numArr = &#123;27, 11, 13, 45, 34, 22, 19, 8, 3, 99, 74, 55, 88, 66&#125;; System.out.println(&quot;**************堆排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(numArr); System.out.println(&quot;排序后：&quot;); heapSort(numArr); CommonUtils.display(numArr); &#125;&#125; CommonUtils工具类：1234567891011121314151617181920212223package main.java.com.study.utils;/** * @author: whb * @date: 2019/6/24 14:53 * @description: 工具类 */public class CommonUtils &#123; /** * 遍历打印 * * @param numArr */ public static void display(int[] numArr) &#123; if (numArr != null &amp;&amp; numArr.length &gt; 0) &#123; for (int num : numArr) &#123; System.out.print(num + &quot; &quot;); &#125; &#125; System.out.println(&quot;&quot;); &#125;&#125; 测试结果如下:]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 简单选择排序]]></title>
    <url>%2F2019%2F06%2F25%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想：在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。 操作方法：第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；以此类推…..第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，直到整个序列按关键码有序。 算法流程图: 代码如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @date: 2019/6/24 14:14 * @description: 选择排序 */public class SelectionSort &#123; /** * 选择排序：每一趟在剩余未排序的若干记录中选取关键字最小的（也可以是最大的）记录作为有序序列中下一个记录。 * 如第i趟选择排序就是在n-i+1个记录中选取关键字最小的记录作为有序序列中第i个记录。 * 这样，整个序列共需要n-1趟排序。 */ public static void selctionSort(int[] numArr) &#123; int length = numArr.length; //要遍历的次数（length-1） for (int i = 0; i &lt; length - 1; i++) &#123; //将当前下标定义为最小值下标 int min = i; //遍历min之后的数据 for (int j = i + 1; j &lt; length - 1; j++) &#123; //如果有小于当前最小值的元素，将它的下标赋值给min if (numArr[j] &lt; numArr[min]) &#123; min = j; &#125; &#125; //如果min不等于i，则说明找到了真正的最小值 if (min != i) &#123; swap(numArr, min, i); &#125; &#125; &#125; /** * 交换数组中两个元素的位置 * * @param numArr * @param min * @param i */ public static void swap(int[] numArr, int min, int i) &#123; int temp = numArr[min]; numArr[min] = numArr[i]; numArr[i] = temp; &#125; public static void main(String[] args) &#123; int[] numArr = &#123;27, 11, 13, 45, 34, 22, 19, 8, 3, 99, 74, 55, 88, 66&#125;; System.out.println(&quot;**************选择排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(numArr); System.out.println(&quot;排序后：&quot;); selctionSort(numArr); CommonUtils.display(numArr); &#125;&#125; CommonUtils工具类：1234567891011121314151617181920212223package main.java.com.study.utils;/** * @author: whb * @date: 2019/6/24 14:53 * @description: 工具类 */public class CommonUtils &#123; /** * 遍历打印 * * @param numArr */ public static void display(int[] numArr) &#123; if (numArr != null &amp;&amp; numArr.length &gt; 0) &#123; for (int num : numArr) &#123; System.out.print(num + &quot; &quot;); &#125; &#125; System.out.println(&quot;&quot;); &#125;&#125; 测试结果如下:]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 直接插入排序]]></title>
    <url>%2F2019%2F06%2F25%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想: 将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。 操作方法： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 算法流程图: 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @date: 2019/6/24 14:12 * @description: 插入排序 */public class InsertSort &#123; /** * 直接插入排序是一种最简单的排序方法，它的基本操作是将一个记录插入到已排好的有序的表中，从而得到一个新的、记录数增1的有序表。 * &lt;p&gt; * 当前元素的前面元素均为有序，要插入时，从当前元素的左边开始往前找（从后往前找），比当前元素大的元素均往右移一个位置，最后把当前元素放在它应该呆的位置就行了。 * 移动、比较的次数可作为衡量时间复杂性的标准。 * &lt;p&gt; * 最优情况：如果原始的输入序列为正序： * &lt;p&gt; * 比较次数：n-1 * &lt;p&gt; * 移动次数：0 * &lt;p&gt; * 最差情况：如果原始的输入序列为逆序： * &lt;p&gt; * 比较次数：(n+2)(n-1)/2 * &lt;p&gt; * 移动次数：(n+4)(n-1)/2 * &lt;p&gt; * 所以直接插入排序的时间复杂度为O(n2)。 */ public static void insertSort(int[] numArr) &#123; int length = numArr.length; for (int i = 1; i &lt; length; i++) &#123; int temp = numArr[i]; int j; //遍历有序序列，如果有序序列中的元素比临时元素大，则将有序序列中比临时元素大的元素依次向后移动 for (j = i - 1; j &gt;= 0 &amp;&amp; numArr[j] &gt; temp; j--) &#123; numArr[j + 1] = numArr[j]; &#125; //将临时元素插入到腾出的位置 numArr[j + 1] = temp; &#125; &#125; public static void main(String[] args) &#123; int[] numArr = &#123;27, 11, 13, 45, 34, 22, 19, 8, 3, 99, 74, 55, 88, 66&#125;; System.out.println(&quot;**************直接插入排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(numArr); System.out.println(&quot;排序后：&quot;); insertSort(numArr); CommonUtils.display(numArr); &#125;&#125;``` CommonUtils工具类： package main.java.com.study.utils; /** @author: whb @date: 2019/6/24 14:53 @description: 工具类*/public class CommonUtils { /** 遍历打印* @param numArr*/public static void display(int[] numArr) { if (numArr != null &amp;&amp; numArr.length &gt; 0) {for (int num : numArr) { System.out.print(num + &quot; &quot;); } } System.out.println(“”);}} ` 测试结果如下：]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法 - 冒泡排序]]></title>
    <url>%2F2019%2F06%2F25%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。 算法步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 算法流程图： 算法改进对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。 代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package main.java.com.study.sortingAalgorithm;import main.java.com.study.utils.CommonUtils;/** * @author: whb * @date: 2019/6/24 14:12 * @description: 冒泡排序 */public class BubbleSort &#123; /** * 冒泡排序的过程很简单，就是不断比较相邻两个元素的大小关系，若逆序则交换，这样通过一轮比较，关子健最大的记录就沉底了。 * 一般地，第i趟冒泡排序从第一个元素起到第n-i+1个元素依次比较相邻两个记录的关键字，并在逆序时交换相邻记录，其结果就是这n-i+1个记录中关键字最大的记录被交换到n-i+1的位置上。 * 当然也可以反过来，从后往前进行，这样每经过一趟排序，就把未排序的序列中最小的元素放在它应当处于的位置上，然后下次比较就不再让前面的元素参与了。 * 整个排序过程需要进行k趟冒泡排序，其中k至少为1，至多为n-1次，如果一趟冒泡排序中没有出现交换元素的操作，则说明序列已经有序了，可以停止排序了。 * 时间复杂度：正序时O(n)， 逆序时O(n2)，平均时间复杂性O(n2)。使用temp 作为临时交换变量，空间复杂度为 O(1). * &lt;p&gt; * 一般情况下貌似效率不及直接插入排序（尽管它们的平均时间复杂度都是O(n2)）。 */ public static void bubbleSort(int[] numArr) &#123; int length = numArr.length; //最多length-1次排序 for (int i = 0; i &lt; length; i++) &#123; //每一轮多少元素参与排序 for (int j = 0; j &lt; length - 1 - i; j++) &#123; if (numArr[j] &gt; numArr[j + 1]) &#123; /** * 交换顺序，不使用临时变量，利用 * a = a + b; * b = a - b; * a = a - b; */ numArr[j] = numArr[j] + numArr[j + 1]; numArr[j + 1] = numArr[j] - numArr[j + 1]; numArr[j] = numArr[j] - numArr[j + 1]; &#125; &#125; &#125; &#125; /** * 改进版冒泡：当某趟排序没有元素交换的时候，证明整个序列有序，无需再循环比较 * * @param numArr */ public static void bubbleSortImprove(int[] numArr) &#123; int length = numArr.length; //设置标志变量，这样当序列有序时及时退出循环，避免冗余处理。 boolean sorted = false; //最多length-1次排序 for (int i = 0; i &lt; length; i++) &#123; sorted = true; //每一轮多少元素参与排序 for (int j = 0; j &lt; length - 1 - i; j++) &#123; if (numArr[j] &gt; numArr[j + 1]) &#123; /** * 交换顺序，不使用临时变量，利用 * a = a + b; * b = a - b; * a = a - b; */ numArr[j] = numArr[j] + numArr[j + 1]; numArr[j + 1] = numArr[j] - numArr[j + 1]; numArr[j] = numArr[j] - numArr[j + 1]; sorted = false; &#125; &#125; if (sorted) &#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] numArr = &#123;27, 11, 13, 45, 34, 22, 19, 8, 3, 99, 74, 55, 88, 66&#125;; System.out.println(&quot;**************冒泡排序******************&quot;); System.out.println(&quot;排序前：&quot;); CommonUtils.display(numArr); System.out.println(&quot;排序后：&quot;); bubbleSortImprove(numArr); CommonUtils.display(numArr); &#125;&#125; CommonUtils工具类：1234567891011121314151617181920212223package main.java.com.study.utils;/** * @author: whb * @date: 2019/6/24 14:53 * @description: 工具类 */public class CommonUtils &#123; /** * 遍历打印 * * @param numArr */ public static void display(int[] numArr) &#123; if (numArr != null &amp;&amp; numArr.length &gt; 0) &#123; for (int num : numArr) &#123; System.out.print(num + &quot; &quot;); &#125; &#125; System.out.println(&quot;&quot;); &#125;&#125; 测试结果如下:]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--单例模式]]></title>
    <url>%2F2019%2F06%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[单例模式介绍 意图 ：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 主要解决 ：一个全局使用的类频繁地创建与销毁。 何时使用 ：当您想控制实例数目，节省系统资源的时候。 如何解决 ：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。 关键代码 ：构造函数是私有的。 优点 ： 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 避免对资源的多重占用（比如写文件操作）。 缺点 ：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 使用场景 ： 要求生产唯一序列号。 WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。 实现方式饿汉式（静态常量）【可用】 代码实现 ：1234567891011121314151617181920212223package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 9:40 * @description: 饿汉式（静态常量）【可用】 * 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。 * 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。 */public class Hungry &#123; //自有永久的对象 private static final Hungry hungry = new Hungry(); //构造器私有化 private Hungry() &#123; System.out.println(&quot;饿汉式（静态常量）...&quot;); &#125; public static Hungry getInstance() &#123; return hungry; &#125;&#125; 测试类 ：12345678910111213141516171819202122package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 9:49 * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 饿汉式（静态常量）【可用】 */ Hungry hungry = Hungry.getInstance(); System.out.println(&quot;第&quot; + (finalI + 1) + &quot;次获得的hungry对象的hashCode：&quot; + hungry.hashCode()); &#125;).start(); &#125; &#125;&#125; 输出结果 ： 饿汉式（静态代码块）【可用】 代码实现 ：1234567891011121314151617181920212223242526package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 10:09 * @description: 饿汉式（静态代码块）【可用】 * 将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。 * 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。 * 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。 */public class Hungry2 &#123; private static Hungry2 hungry2; static &#123; hungry2 = new Hungry2(); &#125; private Hungry2() &#123; System.out.println(&quot;饿汉式（静态代码块）...&quot;); &#125; public static Hungry2 getInstance() &#123; return hungry2; &#125;&#125; 测试类 ：12345678910111213141516171819202122package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 9:49 * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 饿汉式（静态代码块）【可用】 */ Hungry2 hungry2 = Hungry2.getInstance(); System.out.println(&quot;第&quot; + (finalI + 1) + &quot;次获得的hungry2对象的hashCode：&quot; + hungry2.hashCode()); &#125;).start(); &#125; &#125;&#125; 输出结果 ： 懒汉式（线程不安全）【不可用】 代码实现 ：12345678910111213141516171819202122232425package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 9:41 * @description: 懒汉式（线程不安全）【不可用】 * 这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。 * 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句， * 这时便会产生多个实例。所以在多线程环境下不可使用这种方式。 */public class Lazy &#123; private static Lazy lazy; private Lazy() &#123; System.out.println(&quot;懒汉式（线程不安全）...&quot;); &#125; public static Lazy getInstance() &#123; if (lazy == null) &#123; lazy = new Lazy(); &#125; return lazy; &#125;&#125; 测试类 ：12345678910111213141516171819202122package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 9:49 * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 懒汉式（线程不安全）【不可用】 */ Lazy lazy = Lazy.getInstance(); System.out.println(&quot;第&quot; + (finalI + 1) + &quot;次获得的lazy对象的hashCode：&quot; + lazy.hashCode()); &#125;).start(); &#125; &#125;&#125; 输出结果 ： 懒汉式(线程安全，同步方法)【不推荐用】 代码实现 ：12345678910111213141516171819202122232425package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 9:44 * @description: 懒汉式(线程安全，同步方法)【不推荐用】 * 有点：解决了线程不安全问题，做个线程同步就可以了，于是就对getInstance()方法进行了线程同步。 * 缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。 * 而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。 */public class Lazy2 &#123; private static Lazy2 lazy; private Lazy2() &#123; System.out.println(&quot;懒汉式(线程安全，同步方法)...&quot;); &#125; public static synchronized Lazy2 getInstance() &#123; if (lazy == null) &#123; lazy = new Lazy2(); &#125; return lazy; &#125;&#125; 测试类 ：12345678910111213141516171819202122package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 9:49 * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 懒汉式(线程安全，同步方法)【不推荐用】 */ Lazy2 lazy2 = Lazy2.getInstance(); System.out.println(&quot;第&quot; + (finalI + 1) + &quot;次获得的lazy2对象的hashCode：&quot; + lazy2.hashCode()); &#125;).start(); &#125; &#125;&#125; 输出结果 ： 懒汉式(线程安全 ， 同步代码块)【不可用】 代码实现 ：1234567891011121314151617181920212223242526package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 9:46 * @description: 懒汉式(线程安全 ， 同步代码块)【不可用】 * 由于同步方法的同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。 * 但是这种同步并不能起到线程同步的作用。假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。 */public class Lazy3 &#123; private static volatile Lazy3 lazy; private Lazy3() &#123; System.out.println(&quot;懒汉式(线程安全，同步代码块)...&quot;); &#125; public static Lazy3 getInstance() &#123; if (lazy == null) &#123; synchronized (Lazy3.class) &#123; lazy = new Lazy3(); &#125; &#125; return lazy; &#125;&#125; 测试类 ：12345678910111213141516171819202122package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 9:49 * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 懒汉式(线程安全，同步代码块)【不可用】 */ Lazy3 lazy3 = Lazy3.getInstance(); System.out.println(&quot;第&quot; + (finalI + 1) + &quot;次获得的lazy3对象的hashCode：&quot; + lazy3.hashCode()); &#125;).start(); &#125; &#125;&#125; 输出结果 ： 静态内部类【推荐用】 代码实现 ：1234567891011121314151617181920212223242526package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 10:26 * @description: 静态内部类【推荐用】 * 这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。 * &lt;p&gt; * 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 * &lt;p&gt; * 优点：避免了线程不安全，延迟加载，效率高。 */public class StaticInnerClass &#123; private StaticInnerClass() &#123; System.out.println(&quot;静态内部类...&quot;); &#125; private static class SingletonInstance &#123; private static StaticInnerClass instance = new StaticInnerClass(); &#125; public static StaticInnerClass getInstance() &#123; return SingletonInstance.instance; &#125;&#125; 测试类 ：12345678910111213141516171819202122package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 9:49 * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 静态内部类【推荐用】 */ StaticInnerClass staticInnerClass = StaticInnerClass.getInstance(); System.out.println(&quot;第&quot; + (finalI + 1) + &quot;次获得的staticInnerClass对象的hashCode：&quot; + staticInnerClass.hashCode()); &#125;).start(); &#125; &#125;&#125; 输出结果 ： 双重检查【推荐用】 代码实现 ：12345678910111213141516171819202122232425262728package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 10:23 * @description: 双重检查【推荐用】 * 我们进行了两次if (doubleCheck == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (doubleCheck == null)，直接return实例化对象。 * 优点：线程安全；延迟加载；效率较高。 */public class DoubleCheck &#123; private static volatile DoubleCheck doubleCheck; private DoubleCheck() &#123; System.out.println(&quot;双重检查...&quot;); &#125; public static DoubleCheck getInstance() &#123; if (doubleCheck == null) &#123; synchronized (DoubleCheck.class) &#123; if (doubleCheck == null) &#123; doubleCheck = new DoubleCheck(); &#125; &#125; &#125; return doubleCheck; &#125;&#125; 测试类 ：12345678910111213141516171819202122package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 9:49 * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 双重检查【推荐用】 */ DoubleCheck doubleCheck = DoubleCheck.getInstance(); System.out.println(&quot;第&quot; + (finalI + 1) + &quot;次获得的doubleCheck对象的hashCode：&quot; + doubleCheck.hashCode()); &#125;).start(); &#125; &#125;&#125; 输出结果 ： 枚举【推荐用】 代码实现 ：1234567891011121314package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 10:09 * @description: 枚举【推荐用】 * 不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。 */public enum EnumSingleton &#123; Instance; public void whatEverMethod() &#123; &#125;&#125; 测试类 ：12345678910111213141516171819202122package main.java.com.study.designPatterns.single;/** * @author: whb * @date: 2019/6/13 9:49 * @description: 单例模式测试 */public class singletonTest &#123; public static void main(String[] args) &#123; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(() -&gt; &#123; /** * 双重检查【推荐用】 */ DoubleCheck doubleCheck = DoubleCheck.getInstance(); System.out.println(&quot;第&quot; + (finalI + 1) + &quot;次获得的doubleCheck对象的hashCode：&quot; + doubleCheck.hashCode()); &#125;).start(); &#125; &#125;&#125; 输出结果 ：]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~检出]]></title>
    <url>%2F2019%2F06%2F12%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E6%A3%80%E5%87%BA.html</url>
    <content type="text"><![CDATA[HEAD的重置即检出HEAD可以理解为“头指针”，是当前工作区的“基础版本”，当执行提交时，HEAD指向的提交作为新提交的父提交。看看当前HEAD的指向。1$ cat .git/HEAD 可以看出HEAD指向了分支master，此时执行git branch会看到当前处于master分支。1$ git branch -v 现在使用git checkout命令检出该ID的父提交，看看会怎么样。1$ git checkout 23995a2 翻译一下上面的输出结果：12345678910$ git checkout 23995a2注意：正在检出 &apos;23995a2&apos;.您现在处于&apos;分离头指针&apos;状态，您可以检查、测试和提交，而不影响任何分支。通过执行另外的一个 checkout 检出指令会丢弃在此状态下的修改和提交。如果想保留在此状态下的修改和提交，使用 -b 参数调用 checkout 检出指令以创建新的跟踪分支。如： git checkout -b new_branch_name 头指针现在指向 23995a2... 提交说明为：does master follow this new commit? 什么叫做“分离头指针”状态？查看一下此时的HEAD的内容就明白了。12$ cat .git/HEAD23995a2d61d0a2667ba0db8aa4a17b127c1977d1 原来“分离头指针”状态指的就是HEAD头指针指向了一个具体的提交ID，而不是一个引用（分支）。 查看最新提交的reflog也可以看到当针对提交执行git checkout命令时，HEAD头指针就被更改了：由指向master分支变成了指向一个提交ID。12$ git reflog -l23995a2 (HEAD, master) HEAD@&#123;0&#125;: checkout: moving from master to 23995a2 注意上面的reflog是HEAD头指针的变迁记录，而非master分支。查看一下HEAD和master对应的提交ID，会发现现在它们指向的不一样。1$ git rev-parse HEAD master 前一个是HEAD头指针的指向，后一个是master分支的指向。而且还可以看到执行git checkout命令与执行git reset命令不同，分支(master)的指向并没有改变，仍旧指向原有的提交ID。现在版本库的HEAD是指向23995a提交的，再做一次提交，HEAD会如何变化？ 先做一次修改：创建一个新文件detached-commit.txt，添加到暂存区中。 12$ touch detached-commit.txt $ git add detached-commit.txt 看一下状态，会发现其中有“当前不处于任何分支”的字样，显然这是因为HEAD处于“分离头指针”模式。 1$ git status 执行提交。在提交输出中也会出现[detached HEAD...]的标识，这也是对用户的警示。1$ git commit -m &quot;commit in detached HEAD mode&quot; 此时头指针指向了新的提交。12$ cat .git/HEAD1fe77f7b9993cd79b050826df1c73715cc1d1e45 再查看一下日志会发现新的提交是建立在之前的提交基础上的。1$ git log --graph --oneline 记下新的提交ID(1fe77f7b9993cd79b050826df1c73715cc1d1e45)，然后以master分支名作为参数执行git checkout命令，会切换到master分支上。 切换到master分支上，再没有之前大段的文字警告。1$ git checkout master 因为HEAD头指针重新指向了分支，而不是处于“分离头指针模式”。1$ cat .git/HEAD 切换之后，之前本地建立的detached-commit.txt文件不见了。12$ lsnew-commit.txt welcome.txt 切换之后，刚才的提交日志也不见了。1$ git log --graph --oneline 刚才的提交还存在于版本库的对象库中吗？看看刚才记下的提交ID。1$ git show 1fe77 可以看出这个提交现在仍在版本库中。由于这个提交没有被任何分支跟踪到，因此不能保证这个提交会永久存在。实际上当reflog中含有该提交的日志过期后，这个提交随时都会从版本库中彻底清除。 挽救分离头指针在“分离头指针”模式下进行的测试提交除了使用ID（1fe77）访问之外，不能通过master分支或其他引用访问到。如果这个提交是master分支所需的，那么该如何处理？如果使用git reset，的确可以将master分支重置到该测试提交的1fe77，但这就会丢掉master分支原先的提交23995a2。使用合并操作git merge可以实现两者的兼顾。下面的操作会将提交1fe77合并到master分支中来，具体操作如下： 确认当前处于master分支。1$ git branch -v 执行合并操作，将1fe77提交合并到当前分支。1$ git merge 1fe77 工作区中多了一个detached-commit.txt文件。 深入了解git checkout命令git checkout是Git常用的命令之一，同时也是很危险的命令，因为这条命令会重写工作区。检出命令的用法如下：123用法一： git checkout [-q] [&lt;commit&gt;] [--] &lt;paths&gt;...用法二： git checkout [&lt;branch&gt;]用法三： git checkout [-m] [[-b|--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;] 用法一和用法二的区别在于，用法一在命令中包含路径。为了避免路径和引用（或者提交ID）同名而发生冲突，可以在前用两个连续的短线作为分隔。 第一种用法的是可选项，如果省略相当于从暂存区(index)进行检出。这和重置命令大不相同：重置的默认值是HEAD，而检出的默认值是暂存区。因此重置一般用于重置暂存区(除非使用–hard参数，否则不重置工作区)，而检出命令主要是覆盖工作区(如果不省略，也会替换暂存区中相应的文件)。 用法一(包含了路径的用法)不会改变HEAD头指针，主要是用于指定版本的文件覆盖工作区中对应的文件。如果省略，则会用暂存区的文件覆盖工作区的文件，否则用指定提交中的文件覆盖暂存区和工作区中对应的文件。 用法二(不使用路径的用法)则会改变HEAD头指针。之所以后面的参数写作，是因为只有HEAD切换一个分支才可以对提交进行跟踪，否则仍然会进入“分离头指针”状态。在“分离头指针”状态下的提交不能被引用关联到，从而可能丢失。用法二的最主要作用就是切换到分支。如果省略则相当于对工作区进行状态检查。 用法三主要是创建和切换到新分支(&lt;new_branch&gt;)，新的分支从&lt;start_point&gt;指定的提交开始创建。新分支和我们熟悉的master分支没有什么实质的不同，都是在refs/heads命名空间下引用。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~重置]]></title>
    <url>%2F2019%2F06%2F12%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E9%87%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[分支游标master的探秘先来看看当有新的提交发生时，文件.git/refs/heads/master的内容如何改变。首先在工作区创建一个新文件，姑且叫做new-commit.txt，然后提交到版本库中。123$ touch new-commit.txt $ git add new-commit.txt $ git commit -m &quot;does master follow this new commit?&quot; 此时工作目录下会有两个文件，其中文件new-commit.txt是新增的。12$ lsnew-commit.txt welcome.txt 来看看master分支指向的提交ID是否改变了。 先看看在版本库引用空间(.git/refs/目录)下的master文件内容的确更改了，指向了新的提交。12$ cat .git/refs/heads/master23995a2d61d0a2667ba0db8aa4a17b127c1977d1 再用git log查看一下提交日志，可以看到刚刚完成的提交。1$ gilt log --graph --oneline 引用refs/heads/master就好像是一个游标，在有新的提交发生的时候指向了新的提交。可是如果只可上、不可下，就不能称为“游标”。Git提供了git reset命令，可以将“游标”指向任意一个存在的提交ID。下面就尝试人为更改游标。1$ git reset --hard HEAD^ 注意，上面的命令中使用了--hard参数，会破坏工作区未提交的改动，要慎用。这条命令将master重置到了上一个老的提交上，来看下master文件内容是否更改了。12$ cat .git/refs/heads/mastera67c6fdd0a0e809340944432a3bf7d78e7e10f31 果然master分支的引用文件的指向更改为前一次提交的ID了。而且通过下面的命令可以看到新添加的文件new-commit.txt也丢失了。1$ ls 重置命令不仅可以重置到前一次提交，还可以直接使用提交ID重置到任何一次提交。 通过git log查询到最早的提交ID。1$ git log --graph --oneline 然后重置到最早的一次提交。1$ git reset --hard d3e0684 -重置后会发现welcome.txt也回退到了最原始版本库，曾经的修改都丢失了。1$ cat welcome.txt 使用重置命令很危险，会彻底的丢弃历史。那么还能够通过浏览提交历史的办法找到丢弃的提交ID，再使用重置命令恢复历史吗？不可能！！！因为重置让提交历史也改变了。1$ git log 使用reflog挽救错误的重置如果没有记下重置前master分支指向的提交ID，想要重置回原来的提交真的是一件麻烦的事情(去对象库中一个个地找)。幸好Git提供了一个挽救机制，通过.git/logs目录下日志文件记录了分支的变更。默认非裸版本库（带有工作区）都提供分支日志功能，这是因为带有工作区的八本库都有如下设置：1$ git config core.logallrefupdates 查看一下master分支的日志文件.git/logs/refs/heads/master中的内容。下面命令显示了该文件的最后几行。1$ tail -5 .git/logs/refs/heads/master 可以看出这个文件记录了master分支指向的变迁，最新的改变追加到文件的末尾因此最后出现。最后一行可以看出因执行git reset --hard命令，指向的提交ID由a67c6f改变为d3e0684。Git提供了一个git reflog命令，对这个文件进行操作。使用show子命令可以显示此文件的内容。1$ git reflog show master | head -5 使用git reflog的输出和直接查看日志文件最大的不同在于显示顺序不同，即最新改变放在了最前面显示，而且只显示每次改变的最终的SHA1哈希值。还有个区别在于使用git reflog的输出中还提供了一个方便易记的表达式：&lt;refname&gt;@{&lt;n&gt;}。这个表达式的含义是引用&lt;refname&gt;之前第次改变时的SHA1哈希值。那么将引用master切换到两次变更之前的值，可以使用如下命令： 重置master为两次改变之前的值。1$ git reset --hard master@&#123;2&#125; 重置后工作区中文件new-commit.txt又回来了。 12$ lsnew-commit.txt welcome.txt 提交的历史也回来了。 1$ git log --oneline 此时如果再用git reflog查看，会看到恢复master的操作也记录在了日志中。1$ git reflog show master | head -5 深入了解git reset命令重置命令git reset是Git最常用的命令之一，也是最危险，最容易误用的命令。用法如下：12用法一：git reset [-q] [&lt;commit&gt;] [--] &lt;paths&gt;…​用法二：git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;] 上面列出的用法中，是可选项，可以使用引用或者提交ID，如果省略则相当于使用了HEAD的指向作为提交ID。上面列出的两种用法的区别在于，第一种用法在命令中包含路径&lt;paths&gt;。为了避免路径和引用（或者提交ID）同名而冲突，可以在&lt;paths&gt;前用两个连续的短线作为分隔。 第一种用法不会重置引用，更不会改变工作区，而是用指定提交状态（）下的文件（）替换掉暂存区的文件。例如命令git reset HEAD &lt;paths&gt;相当于取消之前执行的git add &lt;paths&gt;命令时改变的暂存区。 第二种用法（不使用路径&lt;paths&gt;的用法）则会重置引用。根据不同的选项，可以对暂存区或者工作区进行重置。参照下面的版本库模型图，来看一看不同的参数对第二种重置语法的影响。 命令格式：git reset [–soft | –mixed | –hard] [] 使用参数--hard，如：git reset --hard &lt;commit&gt; 会执行上图中的1、2、3全部的三个动作。即： 替换引用的指向。引用指向新的提交ID。 替换暂存区。替换后，暂存区的内容和引用指向的目录树一致。 替换工作区。替换后，工作区的内容变得和暂存区一致，也和HEAD指向的目录树内容相同。 使用参数--soft，如：git reset --soft &lt;commit&gt;，会执行上图中的操作1.即只更改引用的指向，不改变暂存区和工作区。 使用参数--mixed或者不使用参数（缺省为--mixed），如：git reset &lt;commit&gt;，会执行上图中的操作1和操作2。即更改引用的指向以及重置暂存区，但不改变工作区。 下面通过一些示例，看一下重置命令的不同用法。 命令：git reset仅用HEAD指向的目录树重置暂存区，工作区不受影响，相当于将之前用git add命令更新到暂存区的内容撤出暂存区。引用也未改变，因为引用重置到HEAD相当于没有重置。 命令：git reset HEAD 同上。 命令：git reset -- filename。仅将文件filename撤出暂存区，暂存区中其他文件不改变。相当于对命令git add filename的反向操作。 命令：git reset HEAD filename。同上。 命令：git reset --soft HEAD^。工作区和暂存区不改变，但是引用向前回退一次。当对最新提交的提交说明或者提交的更改不满意时，撤销下最新的提交以便重新提交。 之前曾经介绍过一个修改提交命令：git commit --amend，用于对最新的提交进行重新提交以修补错误的提交说明或者错误的提交文件。修补命令实际上相当于执行了下面两条命令。（文件.git/COMMIT_EDITMSG保存了上次的提交日志） 12$ git reset --soft HEAD^$ git commit -e -F .git/COMMIT_EDITMSG 命令：git reset HEAD^。工作区不改变，但是暂存区会回退到上一次提交之前，引用也会回退一次。 命令：git reset --mixed HEAD^。同上。 命令：git reset --hard HEAD^。彻底撤销最近的提交。引用会回退到前一次，而且工作区和暂存区都会回退到上一次提交的状态。自上一次以来的提交全部丢失。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~对象]]></title>
    <url>%2F2019%2F06%2F06%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E5%AF%B9%E8%B1%A1.html</url>
    <content type="text"><![CDATA[Git对象库探秘通过查看日志的详尽输出，会看到非常多的SHA1哈希值。1$ git log -l --pretty=raw 一个提交中居然包含了三个SHA1哈希值表示的对象ID。 commit a67c6fdd0a0e809340944432a3bf7d78e7e10f31这是本次提交的唯一标识。 tree b79fd13fac802739388af44a81d72b6e1d68da89这是本次提交所对应的的目录树。 parent d3617dadd10c274e6e2b6caf47635d5771b9034c这是本次提交的父提交（上一次提交）。 研究Git对象ID的一个重量级武器：git cat-file命令。用下面的命令可以查看这三个ID的类型。123456$ git cat-file -t a67c6fcommit$ git cat-file -t b79ftree$ git cat-file d3617commit 在引用对象ID的时候，没有必要把整个40位的ID写全，只需要从头开始的几位不冲突即可。下面再使用git cat-file命令查看一下这几个对象的内容。 commit对象a67c6fdd0a0e809340944432a3bf7d78e7e10f311$ git cat-file -p a67c6f tree对象b79fd13fac802739388af44a81d72b6e1d68da891$ git cat-file -p b79fd commit对象d3617dadd10c274e6e2b6caf47635d5771b9034c1$ git cat-file -p d3617 在上面目录树(tree)对象中看到了一个新的类型的对象：blob对象。这个对象保存着文件welcome.txt的内容。 该对象的类型为blob。 12$ git cat-file -t d7230d74c5f8d61ff3c1adbfd3b035c09cb62c16blob 该对象的内容就是welcome.txt文件的内容。 123$ git cat-file -p d7230d74c5f8d61ff3c1adbfd3b035c09cb62c16Hello Git.很高兴见到你。 这些对象保存在哪里？当然是Git库中的objects目录下（ID的前两位作为目录名，后38位作为文件名。） 用下面的命令可以看到这些对象在对象库中的实际位置。1for id in a67c6f b79fd d3617 d7230d; do ls .git/objects/$&#123;id:0:2&#125;/$&#123;id:2&#125;*;done 通过下面的命令可以看到提交对象之间相互关联的跟踪连。1$ git log --pretty=raw --graph a67c 上面的命令通过--graph参数可以看到提交链路，通过--pretty=raw参数以便显示每个提交对象的parent属性。最后一个提交没有parent属性，所以跟踪连到此终结，这实际上就是提交的起点。 HEAD和Master探秘现在先看下工作区的状态。12$ git status -s -b## master 上面在显示工作区状态时，除了使用-s参数以显示精简输出外，还使用了-b参数以便能够同时显示出当前工作分支的名称。使用git branch也可以显示当前的工作分支。12$ git branch * master 在master分支名称前面出现一个星号表明这个分支是当前工作分支。现在连续执行下面三个命令会看到相同的输出：12345$ git log -1 HEAD $ git log -1 master $ git log -1 refs/heads/master 也就是说在当前版本库中，HEAD、master和refs/heads/master具有相同的指向。让我们去版本库.git目录中看一看。12345$ find .git -name HEAD -o -name master.git/HEAD.git/logs/HEAD.git/logs/refs/heads/master.git/refs/heads/master 显示一下.git/HEAD的内容：12$ cat .git/HEADref: refs/heads/master 把HEAD的内容翻译过来就是：“指向一个引用：refs/heads/master”。这个引用在文件.git/refs/heads/master。12$ cat .git/refs/heads/mastera67c6fdd0a0e809340944432a3bf7d78e7e10f31 用git cat-file命令查看下a67c6fdd0a0e809340944432a3bf7d78e7e10f31的内容。 显示SHA1哈希值指代的数据类型。 12$ git cat-file -t a67c6commit 显示提交的内容。 1234567$ git cat-file -p a67c6tree b79fd13fac802739388af44a81d72b6e1d68da89parent d3617dadd10c274e6e2b6caf47635d5771b9034cauthor wanghongbo &lt;270028806@qq.com&gt; 1560174530 +0800committer wanghongbo &lt;270028806@qq.com&gt; 1560174530 +0800哪个版本的数据会被提交？ 原来分支master指向的是一个提交ID（最新提交）。这样的分支实现很巧妙：既然可以从任何提交开始建立一条历史跟踪连，那么用一个文件指向这个链条的最新提交，那么这个文件就可以用于追踪整个提交历史了。这个文件就是.git/refs/heads/master文件。下面看一个更接近于真实的版本库结构图： 目录.git/refs是保存引用的命名空间，其中.git/refs/heads目录下的引用又称为分支。对于分支既可以使用正规的长格式表示法，如refs/heads/master，也可以去掉前面的两级目录用master表示。Git有一个底层命令git rev-parse可以用于显示引用对应的提交ID。12345678$ git rev-parse mastera67c6fdd0a0e809340944432a3bf7d78e7e10f31$ git rev-parse refs/heads/master a67c6fdd0a0e809340944432a3bf7d78e7e10f31$ git rev-parse HEAD a67c6fdd0a0e809340944432a3bf7d78e7e10f31 可以看出它们都指向同一个对象。下面来展示一下提交的SHA1哈希值生成方法。 看看HEAD对应的提交的内容。使用git cat-file命令。1234567$ git cat-file commit HEADtree b79fd13fac802739388af44a81d72b6e1d68da89parent d3617dadd10c274e6e2b6caf47635d5771b9034cauthor wanghongbo &lt;270028806@qq.com&gt; 1560174530 +0800committer wanghongbo &lt;270028806@qq.com&gt; 1560174530 +0800哪个版本的数据会被提交？ 提交信息中总共包含243个字符。1$ git cat-file commit HEAD | wc -c 在提交信息的前面加上内容commit 243&lt;null&gt;(为空字符)，然后执行SHA1哈希算法。12$ (printf &quot;commit 243\000&quot;; git cat-file commit HEAD) | sha1suma67c6fdd0a0e809340944432a3bf7d78e7e10f31 *- 上面命令得到的哈希值和用git rev-parse看到的是一样的。1$ git rev-parse HEAD 下面看一看文件内容的SHA1哈希值生成方法。 看看版本库中welcome.txt的内容，使用git cat-file命令。 123$ git cat-file blob HEAD:welcome.txtHello Git.很高兴见到你。 文件总共包含33字节的内容。 12$ git cat-file blob HEAD:welcome.txt | wc -c 33 在文件内容的前面加上blob 33&lt;null&gt;的内容，然后执行SHA1哈希算法。 12$ (printf &quot;blob 33\000&quot;; git cat-file blob HEAD:welcome.txt) | sha1sumd7230d74c5f8d61ff3c1adbfd3b035c09cb62c16 *- 上面命令得到的哈希值和用git rev-parse看到的是一样的。 12$ git rev-parse HEAD:welcome.txtd7230d74c5f8d61ff3c1adbfd3b035c09cb62c16 最后再来看看树的SHA1哈希值的形成方法。 HEAD对应的树的内容共包含39个字节。 12$ git cat-file tree HEAD^&#123;tree&#125; | wc -c39 在树的内容的前面加上tree 39&lt;null&gt;的内容，然后执行SHA1哈希算法。 12$ (printf &quot;tree 39\000&quot;; git cat-file tree HEAD^&#123;tree&#125;) | sha1sumb79fd13fac802739388af44a81d72b6e1d68da89 *- 上面命令得到的哈希值和用git rev-parse看到的是一样的。 12$ git rev-parse HEAD^&#123;tree&#125;b79fd13fac802739388af44a81d72b6e1d68da89 Git提供了很多方法可以方便的访问Git库中的对象。 采用部分SHA1哈希值。不必写全40位的哈希值，只采用开头的部分，不和现有其他的冲突即可。 使用master代表分支master中最新的提交，使用全称refs/heads/master亦可。 使用HEAD代表版本库中最近的一次提交。 符号^可以用于指代父提交。例如： HEAD^代表版本库中上一次提交，即最近一次提交的父提交。 HEAD^^则代表HEAD^的父提交。 对于一个提交有多个父提交，可以在符号^后面用数字表示是第几个父提交。例如： a5731^2含义是提交a5731的多个父提交中的第二个父提交。 HEAD^1相当于HEAD^含义是HEAD多个父提交中的第一个。 HEAD^^2含义是HEAD^(HEAD父提交)的多个父提交中的第二个。 符号~&lt;n&gt;也可以用于指代祖先提交。下面两个表达式效果等同： 12a5731~5a5731^^^^^ 提交所对应的树对象，可以用类似如下的语法访问。 1a5731^&#123;tree&#125; 某一此提交对应的文件对象，可以用如下的语法访问。 1a5731:path/to/file 暂存区中的文件对象，可以用如下语法访问。 1:path/to/file 下面使用git rev-parse练习下。12345678910111213141516$ git rev-parse HEAD a67c6fdd0a0e809340944432a3bf7d78e7e10f31$ git cat-file -p a67c6f tree b79fd13fac802739388af44a81d72b6e1d68da89parent d3617dadd10c274e6e2b6caf47635d5771b9034cauthor wanghongbo &lt;270028806@qq.com&gt; 1560174530 +0800committer wanghongbo &lt;270028806@qq.com&gt; 1560174530 +0800哪个版本的数据会被提交？$ git rev-parse a67c6f^&#123;tree&#125;b79fd13fac802739388af44a81d72b6e1d68da89$ git rev-parse a67c6f^^&#123;tree&#125;a070b35c2d55e057a2eead7b8ae1b06c3e4d8e3b]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~工作区、暂存区、HEAD]]></title>
    <url>%2F2019%2F06%2F06%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E5%B7%A5%E4%BD%9C%E5%8C%BA%E3%80%81%E6%9A%82%E5%AD%98%E5%8C%BA%E3%80%81HEAD.html</url>
    <content type="text"><![CDATA[首先看一下git-demo的提交日志，使用git log查看提交日志（附加--stat参数可以看到每次提交的文件变更统计）。1$ git log --stat 通过日志可以看到第一次提交对文件welcome.txt有一行的变更，而第二次提交因为使用了--allow-empty参数进行的空提交，所以提交说明中看不到任何对实质内容的修改。 修改不能直接提交？首先更改welcome.txt文件的内容，在文件后面追加一行。1$ echo &quot;很高兴见到你。&quot; &gt;&gt; welcome.txt 这时就可以通过git diff命令看到修改后的文件和版本库中文件的差异。实质和本地比较的不是版本库，而是一个中间状态的文件。1$ git diff 接下来执行提交，看能否提交成功。1$ git commit -m &quot;追加一行：很高兴见到你。&quot; 提交成功了吗？好像没有。提交没有成功的证据： 先看看提交日志，如果提交成功就会有新的提交记录。1$ git log --pretty=oneline 使用了精简输出来显示日志，以便更简洁和清晰地看到提交历史。可以看到版本库中只有两个提交，针对刚才修改文件的提交没有成功！ 执行git diff可以看到和之前相同的差异输出，这也说明提交没有成功。 执行git status查看文件状态，可以看到文件处于未提交状态。 执行git status -s可以显示精简格式的状态输出。 提交为什么会失败呢？原因是没有对修改的welcome.txt文件执行git add命令，将修改的文件添加到“提交任务”，然后才能提交。现在就将修改的文件“添加”到提交任务。1$ git add welcome.txt 现在再执行一些Git命令，看看当执行“添加”后会发生什么变化。 执行git diff没有输出。 执行git diff head或git diff master进行比较会发现有差异，这个差异是正常的，因为还没有提交。 1$ git diff head 执行git status，状态输出和之前不一样了。 1$ git status 对新的Git状态输出做下翻译：12345位于分支master上下列的修改将被提交： （如果你后悔了，可以使用“git reset HEAD &lt;file&gt;...”命令将下列改动撤出提交任务（提交暂存区，stage）， 否则执行提交命令将会提交） 已修改： welcome.txt 不得不说，Git太人性化了，它把各种情况下可以使用到的命令都告诉了用户，虽然这显得有点啰嗦。如果不要这么啰嗦，可以使用简洁方式：12$ git status -sM welcome.txt 上面精简状态输出与执行git add之前的精简状态的输出相比，有细微的差别。 虽然都是M(Modified)标识，但是位置不同。在执行git add之前，这个M位于第二列（第一列是个空格），执行完git add之后，字符M位于第一列（第二列是空白）。 位于第一列的字符M的含义：版本库中的文件和处于中间状态–提交任务（提交暂存区，stage）中的文件相比有改动； 位于第二列的字符M的含义：工作区当前的文件和处于中间状态–提交任务（提交暂存区，stage）中的文件相比有改动。这时如果直接提交git commit,加入提交任务的welcome.txt文件的更改就被提交入库了。但是先不忙着提交，再进行一些操作，看看能否被彻底搞糊涂。 继续修改welcome.txt文件（在文件后面追加一行）。 1$ echo &quot;Good-bye&quot; &gt;&gt; welcome.txt 然后执行git status查看一下状态： 1git status 状态输出中居然是之前出现的两种不同状态的输出。 使用简洁模式输出，也会看到两种精简输出的杂合。1git status -s 上面Git状态的输出可以这么理解：不但版本库中最新提交的文件和处于中间状态（提交暂存区，stage）中文件相比有改动，而且工作区当前的文件和处于中间状态（提交暂存区，stage）中的文件相比也有改动。即现在welcome.txt中有三个不同的版本：一个在工作区，一个在暂存区，一个是版本库中最新版本。通过不同的参数调用git diff命令可以看到不同版本库之间的差异。 不带任何选项和参数调用git diff显示工作区最新改动，即工作区和提交暂存区中相比的差异。 将工作区和HEAD（当前工作分支）相比，会看到更多差异。 通过参数--cached或者--staged参数调用git diff命令，看到的是提交暂存区和版本库中文件的差异。 好了，现在提交下看看。123$ git commit -m &quot;哪个版本的数据会被提交？&quot;[master a67c6fd] 哪个版本的数据会被提交？ 1 file changed, 1 insertion(+) 这次提交终于成功了，查看下日志：1234$ git log --pretty=onelinea67c6fdd0a0e809340944432a3bf7d78e7e10f31 (HEAD -&gt; master) 哪个版本的数据会被提交？d3617dadd10c274e6e2b6caf47635d5771b9034c 这是谁提交的？d3e0684a1c510f4effd155b01591019e2c5d7812 初始化的第一次提交 查看精简状态输出：12$ git status -s M welcome.txt 状态输出中文件名的前面出现了一个字母M，即只位于第二列的字母M。那么第一列的M去哪了？很明显被提交了。即提交任务（提交暂存区，stage）中的内容被提交到版本库，所以第一列因为提交暂存区和版本库中的状态一致，所以显示空白。那提交的welcome.txt是哪个版本呢？通过执行git diff或者git diff head命令查看差异。虽然命令git diff和git diff head的比较过程并不同，但是会看到下面相同的差异输出结果。12$ git diff$ git diff head 理解Git暂存区（stage）Git暂存区（stage，或称为index）的设计是Git最成功的设计之一，也是最难理解的一个设计。在版本库.git目录下，有一个index文件，下面针对这个文件做个实验。首先执行git checkout命令，撤销工作区中welcome.txt文件尚未提交的修改。12$ git checkout -- welcome.txt$ git status -s 通过状态输出可以看到工作区已经没有改动了，查看下.git/index文件的时间戳： 2019-06-10 22:00:431$ ls --full-time .git/index 再次执行git status命令，然后显示.git/index文件的时间戳：2019-06-10 22:00:43，和上面的一样。12$ git status -s $ ls --full-time .git/index 现在更改一下welcome.txt文件的时间戳，但不改变它的内容。然后再执行git status命令，然后查看.git/index文件时间戳为：22:06:32123$ touch welcome.txt$ git status -s $ ls --full-time .git/index 可以看到时间戳改变了。这个实验说明当执行git status或者git diff命令扫描工作区改动的时候，先依据.git/index文件中记录的（工作区跟踪文件）时间戳、长度等信息判断工作区文件是否改变。如果工作区的文件时间戳改变，说明文件的内容可能被改变了，需要打开文件，读取文件内容，和更改前的原始文件相比，判断文件内容是否被更改。如果文件内容没有改变，则将该文件新的时间戳记录到.git/index文件中。因为判断文件是否更改使用的是时间戳、文件长度等信息进行比较，要比通过文件内容比较快的多，所以GIt这样的实现方式可以让工作区状态扫描更快执行，这也是Git高效的因素之一。文件.git/index实际上就是一个包含文件索引的目录树，像是一个虚拟的工作区。在这个虚拟工作区的目录树中，记录了文件名、文件的状态信息（时间戳、文件长度等）。文件的内容并不存储其中，而是保存在Git对象库.git/objects目录中，文件索引建立了文件和对象库中对象实体之间的对应。下面这张图展示了工作区、版本库中的暂存区和版本库之间的关系。 图中左侧为工作区，右侧为版本库。在版本库中标记为index的区域是暂存区(stage，亦称index),标记为master的是master分支所代表的目录树。 图中可以看出此时HEAD实际上是指向master分支的一个“游标”，所以图示的命令中出现HEAD的地方可以用master替换。 图中的objects标识的区域为Git的对象库，实际位于.git/objects目录下。 当对工作区修改（或新增）的文件执行git add命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而对象的ID被记录在暂存区的文件索引中。 当执行提交操作时，暂存区的目录树写到版本库（对象库）中，master分支会做出相应的更新。即master最新指向的目录树就是提交时原暂存区的目录树。 当执行git reset HEAD命令时，暂存区的目录树会被重写，被master分支指向的目录树所替换，但是工作区不受影响。 当执行git rm --cached &lt;file&gt;命令时，会直接从暂存区删除文件，工作区则不做改变。 当执行git checkout . 或者git checkout -- &lt;file&gt;命令时，会用暂存区全部或指定的文件替换工作区的文件，。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行git checkout HEAD .或者git checkout HEAD &lt;file&gt;命令时，会用HEAD指向的master分支中的全部或者部分文件替换暂存区和工作区中的文件。这个命令也极具危险性，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 Git Diff 魔法暂存区目录树浏览 对于HEAD（版本库中当前提交）指向的目录树，可以使用git ls-tree来查看。12$ git ls-tree -l HEAD 100644 blob d7230d74c5f8d61ff3c1adbfd3b035c09cb62c16 33 welcome.txt 使用-l参数，可以显示文件大小。上面welcome.txt大小33字节。 输出的条目从左至右，第一个字段是文件的属性（rw-r–r–）,第二个字段说明是Git对象库中的一个blob对象（文件），第三个字段则是该文件在对象库中对应的ID–一个40位的SHA1哈希值格式的ID，第四个字段是文件大小，第五个字段是文件名。 在浏览暂存区中的目录树之前，首先清除工作区当中的改动。通过 git clean -fd命令清除当前工作区中没有加入版本库的文件和目录（非跟踪文件和目录），然后执行git checkout .命令，用暂存区刷新工作区。12$ git clean -fd$ git checkout . 然后在工作区中做出一些修改（修改welcome.txt，增加一个子目录和文件），然后添加到暂存区。最后再对工作区做出修改。123456$ echo &quot;( ^_^ )/~~拜拜&quot; &gt;&gt; welcome.txt$ mkdir -p a/b/c$ echo &quot;Hello.&quot; &gt;&gt; a/b/c/hello.txt $ git add .$ echo &quot;ヾ(￣▽￣)Bye~Bye~&quot; &gt;&gt; a/b/c/hello.txt $ git status -s 上面的命令运行完毕后，通过精简的状态输出，可以看出工作区、暂存区、版本库当前分支的最新版本（HEAD）各不相同。先来看看工作区中文件的大小：123$ find . -path ./.git -prune -o -type f -printf &quot;%-20p\t%s\n&quot;./a/b/c/hello.txt 30./welcome.txt 52 要显示暂存区的目录树，可以使用git ls-files命令。123$ git ls-files -s100644 18832d35117ef2f013c4009f5b2128dfaeff354f 0 a/b/c/hello.txt100644 a2b90cc2992cf3ff4e0d6beb0c9461158124c2b6 0 welcome.txt 这个输出和之前使用git ls-tree命令的输出不一样，如果想要使用git ls-tree命令，需要先将暂存区的目录树写入Git对象库git write-tree命令，然后在针对git write-tree命令写入的tree执行git ls-tree。12345$ git write-tree 1e9d611d50af21a2f0ec7bce6e270fd170a8f557$ git ls-tree -l 040000 tree 53583ee687fbb2e913d18d508aefd512465b2092 - a100644 blob a2b90cc2992cf3ff4e0d6beb0c9461158124c2b6 50 welcome.txt 从上面的命令可以看出： 到处都是40位的SHA1哈希值格式的ID，可以用于指代文件内容（blob），用于指代目录树(tree)，还可以用于指代提交。 git write-tree的输出就是写入Git对象库中的Tree ID，这个ID将作为下一条命令的输入。 git ls-tree命令中，没有把40位的ID写全，而是使用了前几位，实际上只要不和其他的对象ID冲突，可以随心所欲的使用缩写ID。 git ls-tree的输出显示的第一条是一个tree对象，即刚才创建的一级目录a。 如果想要递归显示目录内容，则使用-r参数调用。使用参数-t可以把递归过程中遇到的每棵树都显示出来，而不是只显示最终的文件。下面执行递归操作显示目录树的内容。123456$ git write-tree | xargs git ls-tree -l -r -t040000 tree 53583ee687fbb2e913d18d508aefd512465b2092 - a040000 tree 514d729095b7bc203cf336723af710d41b84867b - a/b040000 tree deaec688e84302d4a0b98a1b78a434be1b22ca02 - a/b/c100644 blob 18832d35117ef2f013c4009f5b2128dfaeff354f 7 a/b/c/hello.txt100644 blob a2b90cc2992cf3ff4e0d6beb0c9461158124c2b6 50 welcome.txt 通过使用不同的参数调用git diff命令，可以对工作区、暂存区、HEAD中的内容两两比较。下面的图展示了git diff命令的作用范围。 通过上面的图就不难理解下面命令的输出。 工作区和暂存区比较。1$ git diff 暂存区和HEAD比较。1$ git diff --cached 工作区和HEAD比较。1$ git diff HEAD 不要使用git commit -a实际上Git的提交命令git commit可以带上-a参数，对本地所有变更的文件执行提交操作，包括本地修改的文件，删除的文件，但不包括未被版本库跟踪的文件。这个命令的确可以简化一些操作，但同时会丢掉Git暂存区带给用户最大的好处：对提交内容进行控制的能力。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~初始化]]></title>
    <url>%2F2019%2F06%2F06%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E5%88%9D%E5%A7%8B%E5%8C%96.html</url>
    <content type="text"><![CDATA[创建版本库及第一次提交首先看一下当前Git的版本1$ git --version 在开始Git之前，我们需要设置一下Git的环境变量，这个设置是一次性的工作。即这些设置会在全局文件（用户主目录的 .gitconfig）或系统文件（/etc/gitconfig）中做永久记录。 告诉Git当前用户的姓名和邮件地址，配置的用户名和邮件地址将在版本库提交时作为提交者的用户名和邮件地址。 12$ git config --global user.name &quot;wanghongbo&quot;$ git config --global user.email whb@163.com 设置一些Git别名，以便可以使用更为简洁的子命令。例如：输入 git ci 即相当于 git commit -s ，输入git st 即相当于 git -p status。 如果拥有系统管理员权限，希望注册的命令别名能被所有用户使用，可执行如下命令： 1234$ git config --system alias.br branch$ git config --system alias.ci &quot;commit -s&quot;$ git config --system alias.co checkout$ git config --system alias.st &quot;-p status&quot; 如果只在本用户使用，执行下面的命令：1234$ git config --global alias.st status$ git config --global alias.ci &quot;commit -s&quot;$ git config --global alias.co checkout$ git config --global alias.br branch 创建Git版本库下面就从一个空目录开始初始化版本库，这个版本库命名为“git-demo”。首先建立一个新的工作目录，进入该目录后，执行git init创建版本库12345$ cd /d/workspace$ mkdir git-demo$ cd git-demo$ git initInitialized empty Git repository in D:/workspace/git-demo/.git/ 从上面版本库初始化后的输出中，可以看到执行git init命令在工作区创建了隐藏目录.git。12$ ls -aF./ ../ .git/ 这个隐藏的.git目录就是Git版本库（又叫仓库，repository）。.git版本库目录所在的目录，即/d/workspace/git-demo目录称为工作区，目前工作区除了包含一个隐藏的.git目录外空无一物。 下面在工作区中创建一个文件：welcome.txt，内容就是一行“Hello Git.”。1$ echo &quot;Hello Git.&quot; &gt;&gt; welcome.txt 为了将这个新建立的文件添加到版本库，需要执行下面的命令：1$ git add welcome.txt Git和大部分其他版本控制系统都需要再执行一个提交操作，对于Git执行git commit命令完成提交。在提交过程中需要输入提交说明，这个要求对Git是强制性的，不像CVS、SVN等允许空白的提交说明。在Git提交时，如果在命令行不提供提交说明（没有使用 -m 参数），Git会自动打开一个编辑器，要求您在其中输入提交说明，输入完毕保存退出。下面进行提交，为了说明方便，使用 -m 参数直接给出提交说明。1$ git commit -m &quot;初始化的第一次提交&quot; 从上面的命令及输出可以看出： 通过-m参数设置提交说明为：“初始化的第一次提交”。该提交说明也显示在命令输出的第一行中。 命令输出的第一行还显示了当前处于名为master的分支上，提交ID为e55c54c，且该提交是该分支的第一个提交，即根提交（root-commit）。根提交和其他提交的区别在于没有关联的父提交。 命令输出的第二行开始显示本次提交所做修改的统计：修改了一个文件，包含一行的插入。 思考：Git工作区下为什么有个.git目录？Git及其他分布式版本控制系统的一个显著特点：版本库位于工作区的根目录下。对于Git，版本库位于工作区根目录下的.git目录中，且仅此一处，在工作区的子目录下则没有任何其他跟踪文件或目录。Git为什么要这样设计呢？对于CVS，工作区的根目录及每个子目录下都有一个CVS目录，该目录中包含几个配置文件，建立了对版本库的追踪。如CVS目录下的Entries文件记录了从版本库检出到工作区的文件的名称、版本和时间戳等，这样就可以通过对工作区文件时间戳的改变来判断文件是否更改。这样设计的好处是，可以将工作区移动到任何其他目录，工作区和版本控制服务器的映射关系保持不变，这样工作区依然能正常工作。甚至还将工作区的某个子目录移动到其他位置，形成新的工作区，在新的工作区仍然能完成版本控制相关的操作。但缺点也很多，例如工作区文件修改了，因为没有原始文件做比对，因此向服务器提交修改的时候只能对整个文件进行传输而不能仅传输文件的改动部分。还有一个风险就是信息泄露，通过扫描CVS/Entries文件就能得到目录下的文件列表，造成信息泄露。 对于SVN，工作区的根目录和每一个子目录下都有一个.svn目录，该目录不仅包含了类似CVS的跟踪目录下的配置文件，还包含了当前工作区下每一个文件的拷贝。多出文件的原始拷贝让某些svn命令可以脱离版本库执行，还可以在由客户端向服务器提交时，仅仅对文件改动的内容提交，因此改动的文件可以和原始拷贝进行差异比较。缺点除了像CVS跟踪目录造成信息泄露，还导致加倍占用工作区的空间。再有就是当在工作区目录下针对文件内容进行搜索时，会因为.svn目录下文件的原始拷贝，导致搜索的结果加倍，而出现混乱的搜索结果。 Git的设计，将版本库放在工作区根目录下，所有的版本控制操作（除了和远程版本库之间的相互操作）都是在本地即可完成，不向SVN只有寥寥几个命令才能脱离网络执行。而且Git也不存在安全泄露（只要保护好.git目录），也没有SVN本地文件搜索结果混乱的问题，Git甚至还提供了一条git grep命令来更好地搜索工作区的文件内容。1$ git grep &quot;Hello&quot; 当工作区中包含子目录，在子目录中执行Git命令时，如何定位版本库？实际上，Git工作区目录下执行操作时，会对目录依次向上递归查找.git目录，找到.git目录就是工作区对应的版本库，.git所在的目录就是工作区的根目录，文件.git/index记录了工作区文件的状态（实际上是暂存区的状态）。 例如，在非Git工作区执行git命令，会因找不到.git目录而报错。12$ cd /d/workspace/webstrom$ git status 怎样获取Git版本库的位置以及工作区根目录位置？ 先在工作区下建立目录a/b/c，进入该目录中。 12$ mkdir -p a/b/c`$ cd a/b/c 显示版本库.git目录所在的位置。 12$ git rev-parse --git-dirD:/workspace/git-demo/.git 显示工作区根目录 12$ git rev-parse --show-toplevelD:/workspace/git-demo 相对于工作区根目录的相对目录 12$ git rev-parse --show-prefixa/b/c 显示从当前目录（cd）后退（up）到工作区的根的深度。 12$ git rev-parse --show-cdup../../../ 思考：git config 命令参数的区别？在之前使用过的git config命令，有的使用了--global参数，有的使用了--system参数，这两个参数有什么区别？ 执行下面的命令，将打开D:/workspace/git-demo/.git/config文件进行编辑。12$ cd /d/workspace/git-demo/$ git config -e 执行下面的命令，将打开C:/Users/ASUS/.gitconfig（用户主目录下的.gitconfig文件）全局配置文件进行编辑。1$ git config -e --global 执行下面的命令，将打开E:/developerTools/git/mingw64/etc/gitconfig系统级配置文件进行编辑。1$ git config -e --system Git的三个配置文件分别是版本库级别的配置、全局配置（用户主目录下）和系统级配置（Git安装目录下）。其中版本库级别配置文件的优先级最高，全局配置文件次之，系统级配置文件优先级最低。这样的优先级设置可以让版本库.git目录下的config文件中的配置可以覆盖用户主目录下的Git环境配置，而用户主目录下的配置也可以覆盖系统的Git配置文件。 执行之前的三个git config命令，会看到这三个级别配置文件的格式和内容，采用INI文件格式。如下：12345678$ cat /d/workspace/git-demo/.git/config[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true git config命令可以用来读取和更改INI配置文件的内容。使用git config &lt;section&gt;.&lt;key&gt;，来读取INI配置文件中某个配置的键值。例如读取[core]小节的bare的属性值，命令如下：12$ git config core.barefalse 如果想要更改或配置INI文件中某个属性的值也很简单，命令格式：git config &lt;section&gt;.&lt;key&gt; &lt;value&gt;。12$ git config a.b learningGit$ git config x.y.z something 打开.git/config文件会看到增加的内容：1234[a] b = learningGit[x &quot;y&quot;] z = something 思考：是谁提交的？在一开始我们为Git设置了user.name和user.email全局环境变量，如果不设置会怎样？执行下面的命令，删除Git全局配置文件中关于user.name和user.email的设置：12$ git config --unset --global user.name$ git config --unset --global user.email 这样关于用户名和邮件的设置都被清空了，执行下面的命令将看不到输出12$ git config user.name$ git config user.email 下面再进行一次提交，看看提交过程有什么不同，以及提交之后显示的提交者是谁？1$ git commit --allow-empty -m &quot;这是谁提交的？&quot; 上面的命令使用了--allow-empty参数，这是因为没有对工作区的文件进行任何修改，Git默认是不会执行提交，使用了--allow-empty参数后，允许执行空白提交。 从提交结果看到，因为没有设置user.name和user.email，提交结果中Git提供了详细的帮助指引来告诉如何设置必须的变量，以及如何修改之前提交中出现的错误的提交者信息。为了保证提交时提交者和作者信息的正确性，重新恢复user.name和user.email的设置。12$ git config --global user.name &quot;wanghongbo&quot;$ git config --global user.email youreamil@email.com 然后执行下面的命令，重新修改最新的提交，修正提交者的错误信息。1$ git commit --amend --allow-empty --reset-author 说明： 参数--amend是对刚刚的提交进行修补，这样就可以改正之前错误的提交，而不会产生新的提交； 参数--allow-empty是因为要进行修改的提交实际上是一个空白提交，Git默认不允许空白提交； 参数--reset-author的含义是将提交者的ID重置，否则会影响最新的Commit的ID。这条命令也会重置AuthorDate的信息。 通过日志可以看到提交者的信息已经改正了。1$ git log --pretty=fuller]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~爱上Git的理由]]></title>
    <url>%2F2019%2F06%2F05%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E7%88%B1%E4%B8%8AGit%E7%9A%84%E7%90%86%E7%94%B1.html</url>
    <content type="text"><![CDATA[现场版本控制 现场版本库创建。直接在需要版本控制的目录下执行Git版本库初始化命令。 1git init 添加文件并提交 12git add -Agit commit -m &quot;本次提交的内容描述&quot; 为初始提交建立一个里程碑：”v1” 1git tag v1 然后开始在工作区中工作–修改文件，提交 1git commit -a 当对修改结果满意，想将工作成功保存带走时，可以通过下面的命令，将从v1开始的历次提交逐一导出为补丁文件。转换的补丁文件都包含一个数字前缀，并提取提交日志信息作为文件名，而且补丁文件还提供对二进制文件的支持。 1git format-patch v1..HEAD 通过邮件将补丁文件发出。当然也可以通过其他方式将补丁文件带走。 1git send-email *.patch Git创建的补丁文件使用了Git扩展格式，因此在导入时为了避免数据遗漏，要使用Git提供的命令而不能使用GNU patch命令。即时要导入的不是Git版本库，也可以使用Git命令。 修改提交说明1git commit --amend 这个命令如果不带”-m”参数，会进入提交提交说明编辑界面，修改原来的提交说明，直到满意为止。 如果要修改某个历史提交的提交说明，Git也可以实现，但要用到另一个命令：变基命令。例如要修改所标识提交的提交说明，执行下面的命令，并在弹出的变基索引文件中修改相应提交前面的动作的关键字。1git rebase -i &lt;commit-id&gt;^ 删除不应提交的文件12git rm --cached 文件名git commit --amend 如果是历史版本，例如是在所标识的提交中引入的文件，则需要使用变基操作。1git rebase -i &lt;commit-id&gt;^ 更好用的提交列表git add 命令将修改内容加入提交暂存区。git add -u 命令可以将所有修改过的文件加入暂存区。git add -A 命令可以将本地删除文件和新增文件都登记到暂存区。git add -p 命令甚至可以对一个文件内的修改进行有选择性的添加。 一个修改后的文件被登记到提交暂存区后，可以继续修改，继续修改的内容不会被提交，除非再对此文件再执行一次 git add 命令。即一个修改文件可以拥有两个版本，在提交暂存区中有一个版本，在工作区中有另外一个版本。 执行 git commit命令提交，无须设定什么变更列表，直接将登记在暂存区中的内容提交。Git支持对提交的撤销，而且可以撤销任意多次。 工作进度保存如果工作区的修改尚未完成时，忽然有一个紧急的任务，需要从一个干净的工作区开始新的工作，或者要切换到别的分支进行工作，那么如果保存当前尚未完成的工作进度呢？1git stash 在切换到新的工作分支之前，执行 git stash 保存工作进度，工作区会变的非常干净，然后就可以切换到新的分支。12git stash git checkout &lt;new_branch&gt; 新的工作分支修改完毕后，再切换回当前分支，调用 git stash pop 命令则可恢复之前保存的工作进度。12git checkout &lt;orignal_branch&gt;git stash pop 更好的差异比较Git对差异比较进行了扩展，支持对二进制文件的差异比较，这是对GNU的 diff 和 patch 命令的重要补充。还有Git的差异比较除了支持基于行的差异比较外，还支持在一行内逐字比较的方式，当向 git diff 命令传递 --word-diff 参数时，就会进行逐字比较。在上面介绍了工作区的文件修改可能会有两个不同的版本，一个是在提交暂存区，一个是在工作区。因此在执行 git diff 命令时会遇到令Git新手费解的现象。 修改后的文件在执行 git diff 命令时会看到修改造成的差异。 修改后的文件通过 git add 命令提交到暂存区，再执行 git diff 命令会看不到该文件的差异。 执行 git diff --cached 命令才可以看到添加到暂存区中的文件所做出的修改。 无处不在的分页器分页器默认使用 less命令（less -FRSX）进行分页。下面是在分页器中常用的热键： 字母q：退出分页器； 字母h：显示分页器帮助； 按空格下翻一页，按字母b上翻一页； 字母d和u：分别代表向下翻动半页和向上翻动半页； 字母j和k：分别代表向上翻一行和向下翻一行； 如果行太长被截断，可以用左箭头和右箭头使得窗口内容左右滚动； 输入/pattern：向下寻找和pattern匹配的内容； 输入?pattern：向上寻找和pattern匹配的内容； 字母n或N：代表向前或向后继续寻找； 字母g：跳到第一行； 字母G：跳到最后一行； 输入数字再加字母g：则跳转到对应的行； 输入!：可以执行Shell命令。 对于默认未提供分页器的Git命令，例如 git status 命令，可通过下面任一方法启用分页器： 在 git 和子命令(如：status)之间插入参数-p或--paginate，为命令启用内建分页器。如：1git -p status -设置Git变量，设置完毕后运行相应的命令，将启用内建分页器。1git config --global pager.status true Git 命令的分页器支持带颜色的字符输出，对于太长的行则采用截断方式处理（可用左右方向键滚动）。如果不习惯分页器的长行截断模式而希望采用自动折行模式，可通过下面任一方法进行设置： 通过设置LESS环境变量来实现。1export LESS=FRX -或者通过定义Git配置变量来改变分页器的默认行为。1git config --global core.pager &apos;less -+$LESS -FRX&apos;]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA使用FindBugs插件]]></title>
    <url>%2F2019%2F06%2F04%2FIDEA%E4%BD%BF%E7%94%A8FindBugs%E6%8F%92%E4%BB%B6.html</url>
    <content type="text"><![CDATA[下载安装在Idea中，打开”File”–&gt;”Settings”，或者使用快捷键”Ctrl+Alt+S”打开设置窗口： 在设置窗口找到 plugins 标签页，然后点击下方的 Browse Repositories ： 在新打开的Browse Repositories窗口搜索findbugs，然后点击Install进行安装，因为我已经安装过了，所以不再显示install按钮： 使用FindBugs 简单说明： 鼠标移动到右边的所有图标，看看每个图标都是什么意思。大概说一下：第一竖列的红色图标是分析当前的这个文件。下面是分析是某一个类，鼠标所在的那个类。再往下是某个包，某个模块，整个项目，所有修改过的文件，等等。第二竖列则是控制分析结果的展示情况。 下面就整个实际找到的代码的问题，单独分析某个service文件，看代码里面的问题。如下图所示： Find Bugs的意思是说代码里面把SimpleDateFormat声明为静态属性，但是SimpleDateFormat是线程不安全的。在多线程使用的时候，可能就会有意想不到的问题。所以就找到个问题啦。根据提示进行修改，如下： 在上图中看到代码里有很多黄色提示，强迫症的人看着很不爽，那怎么把代码里面这些黄色的提示给关掉呢？ 点这个 × 就以啦，代码就恢复成原来的样子啦。 常见的错误信息 Bad practice 代码中的一些坏习惯 Class names should start with an upper case letter 主要包括类名的命名，以大写字母开头。 Method names should start with a lower case letter 方法名以小写字母开头。 Field names should start with a lower case letter 字段名以小写字母开头。 equals()method does not check for null argument equals()方法应该检查非空。 Class defines equals() and uses Object.hashCode() 一个类覆写了equals方法，没有覆写hashCode方法，使用了Object对象的hashCode方法。 Method ignores exceptional return value 方法忽略返回值的异常信息。 Equals method should not assume anything about the type of its argument equals(Object o)方法不能对参数o的类型做任何的假设。比较此对象与指定的对象。当且仅当该参数不为 null，并且是表示与此对象相同的类型的对象时，结果才为 true。 Comparison of String objects using == or != 用==或者！=去比较String类型的对象。 Method might ignore exception 方法可能忽略异常。 Method invokes System.exit() 在方法中调用System.exit(…)语句，考虑用RuntimeException来代替。 Method ignores result of InputStream.read() InputStream.read方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户读取少量字符请求的情况。 Dodgy code 糟糕的代码 Switch statement found where default case is missing Switch没有默认情况下执行的case语句。 Switch statement found where one case falls through to the next case Switch语句中一个分支执行后又执行了下一个分支。通常case后面要跟break 或者return语句来跳出。 Dead store to local variable 该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。 Write to static field from instance method 在实例方法写入静态字段。 Redundant nullcheck of value known to be non-null 方法中对不为空的值进行为空的判断。 Method uses the same code for two branches 此方法使用相同的代码，以实现两个有条件的分支。检查以确保这是不是一个编码错误。 Exception is caught when Exception is not thrown 在try/catch块中捕获异常，但是异常没有在try语句中抛出而RuntimeException又没有明确的被捕获。 Integral division result cast to double or float 整形数除法强制转换为double或者float类型。 Possible null pointer dereference due to return value of called method 方法的返回值没有进行是否为空的检查就重新赋值，这样可能会出现空指针异常。 Useless object created 对象创建了并没有用。 Unread public/protected field 没有用到的字段。 Internationalization 关于代码国际化相关方面的 Consider using Locale parameterized version of invoked method使用平台默认的编码格式对字符串进行大小写转换，这可能导致国际字符的转换不当。使用以下方式对字符进行转换 Performance 关于代码性能相关方面的 Boxing/unboxing to parse a primitive 类型转换 比如字符串转换成int 应该使用Integer.parseInt(“”) 代替Integer.valueOf(“”) Method concatenates string using + in aloop每次循环里的字符串+连接，都会新产生一个string对象，在java中，新建一个对象的代价是很昂贵的，特别是在循环语句中，效率较低解决办法：使用StringBuffer或者StringBuilder重用对象。 Private method is never called 私有方法没有被调用 Explicit garbage collection;extremely dubious except in benchmarking code在代码中显式的调用垃圾回收命名，这样做并不能起作用。在过去，有人在关闭操作或者finalize方法中调用垃圾回收方法导致了很多的性能浪费。这样大规模回收对象时会造成处理器运行缓慢。 Unread field:should this field be static? 没有用到的static 字段 should be a static inner class 此内部类应该使用static修饰 Experimental Method may fail to clean up stream or resource on checked exception这种方法可能无法清除（关闭，处置）一个流，数据库对象，或其他资源需要一个明确的清理行动解决方法：流的关闭都写在finally里面 Malicious code vulnerability 关于恶意破坏代码相关方面的 May expose internal representation by incorporating reference to mutable object此代码把外部可变对象引用存储到对象的内部表示。如果实例受到不信任的代码的访问和没有检查的变化危及对象和重要属性的安全。存储一个对象的副本，在很多情况下是更好的办法。 Field isn’t final but should be 此字段前应该加final Field isn’t final and can’t be protected from malicious code 此字段前应该加final Field should be package protected一个静态字段是可以被恶意代码或其他的包访问修改。可以把这种类型的字段声明为final类型的以防止这种错误。 Multithreaded correctness 关于多线程代码正确性相关方面的 Static DateFormat DateFormat 在多线程中本身就是不安全的，如果在线程范围中共享一个DateFormat的实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。 Call to static DateFormat DateFormats多线程使用本事就是不安全的,改进方法：需要创建多实例或线程同步 Correctness 关于代码正确性相关方面的 Nullcheck of value previously dereferenced 此代码之前废弃null值检查。解决办法 进行null检查 Possible null pointer dereference 可能为null Null pointer dereference 对象赋为null值后 没有被重新赋值 Possible null pointer dereference in method on exception path 在异常null值处理分支调用的方法上，可能存在对象去除引用操作 value is null and guaranteed to be dereferenced on exception path exception分支上，存在引用一个null对象的方法，引发空指针异常。 Self comparison of value with itself 方法中对一个局部变量自身进行比较运算，并可说明错误或逻辑错误。请确保您是比较正确的事情。 An apparent infinite recursive loop 明显的无限迭代循环,将导致堆栈溢出.]]></content>
      <categories>
        <category>IDEA</category>
        <category>插件</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~cherry-pick、revert、reset介绍]]></title>
    <url>%2F2019%2F06%2F03%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~cherry-pick%E3%80%81revert%E3%80%81reset%E4%BB%8B%E7%BB%8D.html</url>
    <content type="text"><![CDATA[gti checkout – filename git checkout – filename 可以把工作区的某个文件的修改撤回到上一次add或者commit的状态，不过filename不能省略.可以使用 git checkout – 不加文件名来查看当前工作区修改了哪些文件，这个只是针对工作区的问题； git reset head filename git reset HEAD filename 可以把add到缓存区的文件回退到工作区，也就是把add filename这个过程给回退了，这并不会修改文件的内容，只是把缓存区的某个文件变成和HEAD这个当前版本相同，也就是说如果你多次add，这会回退到第一次add的过程，和上面的操作一样，也可以不带上文件名来查看哪些文件被添加到了缓存区； git reset –hard head^ git reset –hard HEAD~【1，2，3，4，5…】这个是大家熟悉的本地版本的回退 某分支上的修改迁移到另一分支 比如我们在分支a上开发新功能，此时有个紧急bug需要修改，然后切换到了分支b。bug修复完之后忘了切回之前的分支a，而是在分支b上面继续编写本应该是分支a的内容，这样b分支存在了一部分a分支的代码，这个时候需要把这段代码迁移到a分支上，两个思路： 1）如果还没有在b分支上commit的话(add的话没影响，在迁移后，就不会再当前分支的缓存中)。直接切到a分支，此时会提示有没有被commit的代码，切到a分支后，就可以commit这段没有被commit的代码，也就是在b分支上编写的代码正确的被迁移到了a分支。 2）如果已经commit了，可以这么来：git log找到你commit的分支号，然后直接切换到a分支，执行git cherry-pick commit-id，这个commit-id就是那个b分支错误commit的id，这个命令就是把这个commit的修改拿到当前分支来，很简单粗暴而有效。再切换到b分支，使用git revert commit-id把这个错误的分支号移除。 revert reset cherry-pick git revert当我们的某个分支中有了很多版本之后，形成了一条版本链，如果想去除这个线路中的某一版本，但是保留版本链中的其他所有修改，生成一个新的版本链，版本链中的HEAD就是revert最新生成的版本。所以revert是会生成新版本的指令。可以这么想，链就像一个链条，是一环扣一环的，其中的一环就是一个版本，现在想去这个链条中的某一环（某个版本），执行git revert HEAD~2，这个HEAD~2就是这个要删除的版本（链条中的一环），就会把这个环解开剔除，把和这个剔除的环（版本）相邻的环连在一起，形成了一个新的链条（少了一环），然后在链条的最后面添加一个新的没有任何修改的环（revert HEAD~2 这个新的commit版本）整个过程就像剔除了中间某一个版本，最后加上了一个没有任何修改的新的版本。需要注意的是，不要随意删除中间的版本，因为可能会存在依赖，最好是revert最新的版本，风险会小很多。 git resetgit reset [--hard|soft|mixed|merge|keep] [&lt;commit&gt;或HEAD]是比较常用的指令，其中比较重要的是mode，也就是 –hard、–soft、–mixed。。。比较常见的是–hard和–soft； –hard是指完全重设，会把回退到某版本之后的修改全部删除， –soft这是个回退解体，让版本库回退到某个版本，这个版本之后的修改全部存在缓存区，这个时候在commit的话，又会把会退的部分重新加载到最新版本中； git cherry-pickgit cherry-pick &lt;commit id&gt;用于把另一个本地分支的commit修改应用到当前分支，也是解决之前遇到问题的关键，可以直接把其他的分支上的修改或者是某一个版本直接引过来，可能会存在冲突，这个时候就和正常的冲突一样的解决就好了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~安装]]></title>
    <url>%2F2019%2F06%2F03%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E5%AE%89%E8%A3%85.html</url>
    <content type="text"><![CDATA[最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。后来有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。 要使用Git，第一步当然是安装Git了。根据你使用的操作系统如下： Linux上安装Git首先，你可以试着输入git，看看系统有没有安装Git：123$ gitThe program &apos;git&apos; is currently not installed. You can install it by typing:sudo apt-get install git 像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。 如果你用的是Debian或Ubuntu Linux，通过 sudo apt-get install git 就可以直接完成Git的安装，非常简单。 老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。 如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。 Mac OS X上安装Git 有两种安装Git的方法: 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档。 第二种方法更简单，直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！ Windows上安装Git在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 安装完成后，还需要最后一步设置，在命令行输入：12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 Git可以安装在哪些操作系统上？ Linux macOS Solaris Windows Raspberry Pi Submit]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习之~合并指定文件或Commits到另一分支]]></title>
    <url>%2F2019%2F05%2F31%2FGit%E5%AD%A6%E4%B9%A0%E4%B9%8B~%E5%90%88%E5%B9%B6%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E6%88%96Commits%E5%88%B0%E5%8F%A6%E4%B8%80%E5%88%86%E6%94%AF.html</url>
    <content type="text"><![CDATA[刚使用git进行版本管理的时候，由于成员间的代码有的需要上线，有的不需要上线，如果直接merge，经常 会把别人不需要上线的代码合并的master，导致问题从生。所以，最稳妥的是只合并你需要的那些commits，不需要的commits就不合并进去。那么如何从一个分支合并特定的文件或者Commits到另一个分支这个问题急待解。 合并某个分支上的单个commit首先，用git log或sourcetree工具查看你想选择哪些commits进行合并，例如： 比如dev-w 分支上的commit 2aeefdacad6ed1586a1e035fb8860f11533db23c 非常重要，它含有一个紧急bug的修复或是其他内容。无论什么原因，你现在只需要将 2aeefdacad6ed1586a1e035fb8860f11533db23c 合并到master，而不合并dev-w上的其他commits，所以我们用git cherry-pick命令来做：123git checkout master git cherry-pick 2aeefdacad6ed1586a1e035fb8860f11533db23c 这样 2aeefdacad6ed1586a1e035fb8860f11533db23c 就被合并到master分支，并在master中添加了commit（作为一个新的commit）。cherry-pick 和merge比较类似，如果git不能合并代码改动（比如遇到合并冲突），git需要你自己来解决冲突并手动添加commit。 这里git cherry-pick每次合并过来会显示文件冲突(其实并没有代码冲突部分，只需手动解决既可) 合并某个分支上的一系列commits在一些特定情况下，合并单个commit并不够，你需要合并一系列相连的commits。这种情况下就不要使用cherry-pick了，rebase 更适合。假设你需要合并dev-w分支的commit 76cada ~62ecb3 到master分支。 首先需要基于dev-w创建一个新的分支，并指明新分支的最后一个commit：12git checkout dev-w git checkout -b newbranch 62ecb3 然后，rebase这个新分支的commit到master（–ontomaster）。76cada^ 指明你想从哪个特定的commit开始。1git rebase --ontomaster 76cada^ 得到的结果就是dev-w分支的commit 76cada ~ 62ecb3 都被合并到了master分支。 另外如果只想将dev-w分支的某个文件Test.java合并到master分支上。12git checkout dev-wgit checkout --patch master Test.java 第一个命令： 切换到dev-w分支；第二个命令：合并master分支上Test.java文件到dev-w分支上，将master分支上 Test.java 文件追加补丁到dev-w分支上 Test.java文件。你可以接受或者拒绝补丁内容。 如果只是简单的将dev-w分支的文件Test.java copy到master分支上； 12git checkout mastergit checkout dev-w Test.java 分支test上有一个文件A，你在test1分支上， 此时如果想用test分支上的A文件替换test1分支上的文件的话，可以使用git checkout test1, 然后git checkout test – A 在feature分支commit 切换至release分支 从feature分支检出相应文件12345678#branch featuregit commit -a -m &quot;msg&quot;git checkout release#branch releasegit checkout feature file-01git checkout feature file-x...git commit -a -m &quot;msg&quot;]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL中的函数总结]]></title>
    <url>%2F2019%2F05%2F22%2FMySQL%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[CONCAT()函数CONCAT（）函数用于将多个字符串连接成一个字符串。使用数据表sys_user作为示例，sql如下：SELECT user_id as id,zwxm as name FROM sys_user LIMIT 1; 返回结果如下： 12345+----+--------+| id | name |+----+--------+| 1 | 张三 |+----+--------+ 1、语法及使用特点：CONCAT(str1,str2,…)返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。可以有一个或多个参数。 2、使用示例：SELECT CONCAT(user_id, ‘，’, zwxm) AS con FROM sys_user LIMIT 1;返回结果如下：12345+----------+| con |+----------+| 1,张三 |+----------+ SELECT CONCAT(‘My’, NULL, ‘QL’); 返回结果如下：12345+--------------------------+| CONCAT(&apos;My&apos;, NULL, &apos;QL&apos;) |+--------------------------+| NULL |+--------------------------+ CONCAT_WS()函数使用语法为：· CONCAT_WS(separator,str1,str2,…) ·CONCAT_WS() 代表 CONCAT With Separator ，是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为 NULL，则结果为 NULL。函数会忽略任何分隔符参数后的 NULL 值。但是CONCAT_WS()不会忽略任何空字符串。 (然而会忽略所有的 NULL）。 示例1：SELECT CONCAT_WS(&#39;_&#39;,user_id,zwxm) AS con_ws FROM sys_user LIMIT 1; 返回结果：12345+----------+| con_ws |+----------+| 1_张三 |+----------+ 示例2：SELECT CONCAT_WS(&#39;,&#39;,&#39;First name&#39;,NULL,&#39;Last Name&#39;); 返回结果：12345+----------------------------------------------+| CONCAT_WS(&apos;,&apos;,&apos;First name&apos;,NULL,&apos;Last Name&apos;) |+----------------------------------------------+| First name,Last Name |+----------------------------------------------+ GROUP_CONCAT()函数语法如下： group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段] [Separator ‘分隔符’]) 基本查询： 123456789101112mysql&gt; select * from test; +------+------+ | id| name | +------+------+ |1 | 10 | |1 | 20 | |1 | 20 | |2 | 20 | |3 | 200 | |3 | 500 | +------+------+ 6 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔(默认) 123456789mysql&gt; select id,group_concat(name) from test group by id; +------+--------------------+ | id | group_concat(name) | +------+--------------------+ |1 | 10,20,20 | |2 | 20 | |3 | 200,500 | +------+--------------------+ 3 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，分号分隔 123456789mysql&gt; select id,group_concat(name separator &apos;;&apos;) from test group by id; +------+----------------------------------+ | id | group_concat(name separator &apos;;&apos;) | +------+----------------------------------+ |1 | 10;20;20 | |2 | 20 | |3 | 200;500 | +------+----------------------------------+ 3 rows in set (0.00 sec) 以id分组，把去冗余的name字段的值打印在一行，逗号分隔 123456789mysql&gt; select id,group_concat(distinct name) from test group by id; +------+-----------------------------+ | id | group_concat(distinct name) | +------+-----------------------------+ |1 | 10,20 | |2 | 20 | |3 | 200,500 | +------+-----------------------------+ 3 rows in set (0.00 sec) 以id分组，把name字段的值打印在一行，逗号分隔，以name排倒序 123456789mysql&gt; select id,group_concat(name order by name desc) from test group by id; +------+---------------------------------------+ | id | group_concat(name order by name desc) | +------+---------------------------------------+ |1 | 20,20,10 | |2 | 20 | |3 | 500,200 | +------+---------------------------------------+ 3 rows in set (0.00 sec) 使用group_concat_max_len系统变量，你可以设置允许的最大长度。 程序中进行这项操作的语法如下，其中 val 是一个无符号整数：SET [SESSION | GLOBAL] group_concat_max_len = val;若已经设置了最大长度， 则结果被截至这个最大长度。将环境变量group_concat_max_len 增大。默认是1024.我就设置了session级的环境变量将其变为2048（不够用再加大）]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-“基础”03之-Thread中start()和run()的区别]]></title>
    <url>%2F2019%2F05%2F22%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E2%80%9C%E5%9F%BA%E7%A1%80%E2%80%9D03%E4%B9%8B-Thread%E4%B8%ADstart-%E5%92%8Crun-%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[start()和run()方法的区别start(): 它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。 run(): run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run()，而并不会启动新线程！ 下面以代码来进行说明。 123456class MyThread extends Thread&#123; public void run()&#123; ... &#125; &#125;;MyThread mythread = new MyThread(); mythread.start()会启动一个新线程，并在新线程中运行run()方法。而mythread.run()则会直接在当前线程中运行run()方法，并不会启动一个新线程来运行run()。 start()和run()方法示例下面，通过一个简单示例演示它们之间的区别。源码如下：12345678910111213141516171819202122class TestThread extends Thread &#123; public TestThread(String name) &#123; super(name); &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; is running&quot;); &#125;&#125;;public class ThreadMethodDemo &#123; public static void main(String[] args) &#123; Thread mythread = new TestThread(&quot;testThread&quot;); System.out.println(Thread.currentThread().getName() + &quot; call testThread.run()&quot;); mythread.run(); System.out.println(Thread.currentThread().getName() + &quot; call testThread.start()&quot;); mythread.start(); &#125;&#125; 运行结果：1234main call testThread.run()main is runningmain call testThread.start()testThread is running 结果说明：1) Thread.currentThread().getName()是用于获取“当前线程”的名字。当前线程是指正在cpu中调度执行的线程。2) testThread.run()是在“主线程main”中调用的，该run()方法直接运行在“主线程main”上。3) testThread.start()会启动“线程testThread”，“线程testThread”启动之后，会调用run()方法；此时的run()方法是运行在“线程testThread”上。 start()和run()源码说明（基于JDK1.8.0_171） Thread.java中start()方法源码如下： 12345678910111213141516171819202122232425262728public synchronized void start() &#123; /** * 如果线程不是&quot;新建状态&quot;，则抛出异常 * 状态值0 对应&quot;新建&quot; */ if (threadStatus != 0) throw new IllegalThreadStateException(); /** 将线程添加到ThreadGroup中 */ group.add(this); boolean started = false; try &#123; /** 通过start0()启动线程 */ start0(); /** 设置started标记 */ started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125;&#125; 说明： start()实际上是通过本地方法start0()启动线程的。而start0()会新运行一个线程，新线程会调用run()方法。 1private native void start0(); Thread.java中run()方法源码如下：12345public void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 说明： target是一个Runnable对象。run()就是直接调用Thread线程的Runnable成员的run()方法，并不会新建一个线程。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-“基础”02之 多线程实现方式]]></title>
    <url>%2F2019%2F05%2F22%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E2%80%9C%E5%9F%BA%E7%A1%80%E2%80%9D02%E4%B9%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[实现多线程的几种方式 继承Thread类 实现Runnable接口 通过Callable和Future 通过线程池 Thread和Runnable简介RunnableRunnable是一个接口库，该接口只包含了一个run()方法，定义如下：123public interface Runnable &#123; public abstract void run();&#125; Runnable的作用，实现多线程。我们可以定义一个类A实现Runnable接口；然后，通过new Thread(new A())等方式新建线程。 ThreadThread 是一个类。Thread本身就实现了Runnable接口。它的声明如下：1public class Thread implements Runnable &#123;&#125; Thread和Runnable的异同点Thread 和 Runnable 的相同点：都是“多线程的实现方式”。Thread 和 Runnable 的不同点：Thread 是类，而Runnable是接口；Thread本身是实现了Runnable接口的类。我们知道“一个类只能有一个父类，但是却能实现多个接口”，因此Runnable具有更好的扩展性。此外，Runnable还可以用于“资源的共享”。即，多个线程都是基于某一个Runnable对象建立的，它们会共享Runnable对象上的资源。通常，建议通过“Runnable”实现多线程！ Thread和Runnable的多线程示例Thread的多线程示例123456789101112131415161718192021222324public class ThreadTest &#123; public static void main(String[] args) &#123; // 启动3个线程t1,t2,t3；每个线程各卖10张票！ MyThread t1 = new MyThread(); MyThread t2 = new MyThread(); MyThread t3 = new MyThread(); t1.start(); t2.start(); t3.start(); &#125;&#125;class MyThread extends Thread &#123; private int ticket = 10; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if (this.ticket &gt; 0) &#123; System.out.println(this.getName() + &quot; 卖票：ticket&quot; + this.ticket--); &#125; &#125; &#125;&#125;; 运行结果：123456789101112131415161718192021222324252627282930Thread-2 卖票：ticket10Thread-1 卖票：ticket10Thread-0 卖票：ticket10Thread-1 卖票：ticket9Thread-2 卖票：ticket9Thread-1 卖票：ticket8Thread-0 卖票：ticket9Thread-1 卖票：ticket7Thread-2 卖票：ticket8Thread-1 卖票：ticket6Thread-0 卖票：ticket8Thread-1 卖票：ticket5Thread-2 卖票：ticket7Thread-1 卖票：ticket4Thread-0 卖票：ticket7Thread-1 卖票：ticket3Thread-2 卖票：ticket6Thread-1 卖票：ticket2Thread-0 卖票：ticket6Thread-1 卖票：ticket1Thread-2 卖票：ticket5Thread-0 卖票：ticket5Thread-2 卖票：ticket4Thread-0 卖票：ticket4Thread-2 卖票：ticket3Thread-0 卖票：ticket3Thread-2 卖票：ticket2Thread-0 卖票：ticket2Thread-2 卖票：ticket1Thread-0 卖票：ticket1 结果说明：(01) MyThread继承于Thread，它是自定义个线程。每个MyThread都会卖出10张票。(02) 主线程main创建并启动3个MyThread子线程。每个子线程都各自卖出了10张票。 Runnable的多线程示例1234567891011121314151617181920212223242526class MyThread2 implements Runnable &#123; private int ticket = 10; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; if (this.ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot; 卖票：ticket&quot; + this.ticket--); &#125; &#125; &#125;&#125;;public class RunnableTest &#123; public static void main(String[] args) &#123; MyThread2 mt = new MyThread2(); // 启动3个线程t1,t2,t3(它们共用一个Runnable对象)，这3个线程一共卖10张票！ Thread t1 = new Thread(mt); Thread t2 = new Thread(mt); Thread t3 = new Thread(mt); t1.start(); t2.start(); t3.start(); &#125;&#125; 运行结果：12345678910Thread-0 卖票：ticket10Thread-0 卖票：ticket7Thread-0 卖票：ticket6Thread-0 卖票：ticket5Thread-2 卖票：ticket8Thread-1 卖票：ticket9Thread-1 卖票：ticket2Thread-1 卖票：ticket1Thread-2 卖票：ticket3Thread-0 卖票：ticket4 结果说明：(01) 和上面“MyThread继承于Thread”不同；这里的MyThread实现了Thread接口。(02) 主线程main创建并启动3个子线程，而且这3个子线程都是基于“mt这个Runnable对象”而创建的。运行结果是这3个子线程一共卖出了10张票。这说明它们是共享了MyThread接口的。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-“基础”01之 基本概念]]></title>
    <url>%2F2019%2F05%2F22%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E2%80%9C%E5%9F%BA%E7%A1%80%E2%80%9D01%E4%B9%8B%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</url>
    <content type="text"><![CDATA[线程状态图 线程状态解析 新建状态(New):线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。 就绪状态(Runnable):也被称为“可执行状态”，处于就绪状态的线程，随时可能被CPU调度执行。 调用线程的start()方法，此线程进入就绪状态。 当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。 当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。 锁池里的线程拿到对象锁后，进入就绪状态。 运行状态(Running):线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。 阻塞状态(Blocked):阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种： 等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。 同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。 其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 死亡状态(Dead):线程执行完了或者因异常退出了run()方法，该线程结束生命周期。线程一旦终止了，就不能复生。在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。 说明这5种状态涉及到的内容包括Object类, Thread和synchronized关键字。Object类，定义了wait(), notify(), notifyAll()等休眠/唤醒函数。Thread类，定义了一些列的线程操作函数。例如，sleep()休眠函数, interrupt()中断函数, getName()获取线程名称等。synchronized，是关键字；它区分为synchronized代码块和synchronized方法。synchronized的作用是让线程获取对象的同步锁。 几个方法的比较 Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。 Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。 t.join()/t.join(long millis)，当前线程里调用其它线程t的join方法，当前线程进入WAITING/TIMED_WAITING状态，当前线程不会释放已经持有的对象锁。线程t执行完毕或者millis时间到，当前线程进入就绪状态。 obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout) timeout时间到自动唤醒。 obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL性能优化]]></title>
    <url>%2F2019%2F05%2F22%2FMySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[啦啦啦啦啦啦啦啦啦]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题总结]]></title>
    <url>%2F2019%2F05%2F21%2FJava%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[Java里面所有的不变的属性需要用final修饰吗 答：没必要。你可以实现相同的功能通过以下操作：设为非final的private 变量，且只有在构造函数中才能修改。不设set方法，如果是一个可变对象，不要泄露任何指向这个对象的引用。 设置一个引用变量为final 只能确保这个变量不会被赋予一个不同的引用，但是你仍然可以改变引用变量的属性值。 String的subString()实现原理 答：substring取原来string的一部分创建一个新的对象。这个问题主要想问substring可能导致的内存泄露风险。 直到Java1.7， substring 拥有原来的字符数组的引用，这意味着即使是五字符这么小的字符串，也可能会导致一个1GB字符数组无法被垃圾回收，因为有一个强引用。 这个问题在Java1.7中已经被修复，原来的字符数组不会被引用，但是会导致创建substring耗时会有点长，以前时间复杂度是 O(1), Java 7之后时间复杂度是 O(n)。 Java中如何处理写存储过程或者读存储过程时遇到的错误 答： 一个存储过程应该在操作错误时返回错误码，但是如果存储过程本身出问题，捕获 SQLException 是唯一选择。 工厂模式和抽象工厂模式有什么区别 答：抽象工场模式提供一个多层级的抽象。考虑不同的工厂继承自同一个抽象工厂，代表基于工厂的不同对象结构的创建，例如， AutomobileFactory,UserFactory,RoleFactory等都继承自 AbstractFactory。每一个独立的工厂代表那种类型物体的创造器。 下面是一个工厂模式和抽象工厂模式的UML图： 什么时候重写 hashCode()和 equals()方法 答：当需要通过业务逻辑校验两个对象是否相等，而不是通过两个对象是否执行同一地址。例如两个员工对象在 emp_id 相等的时候相等，即使它们是通过不同的代码创建出来的两个不同对象。 另外，如果你使用一个对象作为 HashMap的key，你必须重写这两个方法。 作为java equals-hashcode约束的一部分，当你重写equals的时候，必须重写hashcode. 否则你不能在Set，Map这样的类里面使用，因为他们通过equals()方法来保证逻辑正确性。 双引号直接创建字符串和使用new()创建字符串有什么区别 答: 使用new()创建String对象，实例被创建在堆中, 不会被添加到String常量池中，当通过字面量创建时，会被放到堆中的永久区的String常量池中。 Stringstr = newString(“Test”) 不会把str放到String常量池中，需要调用String.intern()方法，才会把它放到String常量池中。 当使用String字面量创建String对象时，如通过String s = “Test”, java会自动放入String常量池中。 另外，如果把”Test”这样的String字面量传进去，也会创建另外一个对象:”Test” 在String常量池。 什么是不可变对象，如何写一个不可变类 答：不可变对象是指Java类的对象一单被创建，不能被修改。任何不可变对象对象的修改在创建时候就已经完成，例如，Java中String是不可变的。 大多数不可变类是final的, 这样可以防止因子类重写方法而导致不可变失效。 你也可以实现相同的功能通过让成员非final但是private，且除了构造方法任何其他方法无法修改。 另外，要确保没有暴露不可变对象的内部，尤其是它包含可变成员的时候。 同时，当你从客户端接收到可变的对象时，例如 java.util.Date, 使用clone() 方法 来获取一个独立的拷贝，防止恶意修改可变对象带来的风险。 相同的优化需要在返回一个可变成员时执行。返回另一个独立拷贝给客户端；不要返回可变对象的原始引用。]]></content>
      <categories>
        <category>面试题</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程面试题总结]]></title>
    <url>%2F2019%2F05%2F21%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[多线程的优缺点优点： 多线程技术使程序的响应速度更快。 当前没有进行处理的任务可以将处理器时间让给其它任务。 占用大量处理时间的任务可以定期将处理器时间让给其它任务。 可以随时停止任务。 可以分别设置各个任务的优先级以及优化性能。 缺点 等候使用共享资源时造成程序的运行速度变慢。 对线程进行管理要求额外的cpu开销。 可能出现线程死锁情况。即较长时间的等待或资源竞争以及死锁等症状。 start()方法和run()方法的区别start()方法： 用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。 通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到CPU时间片，就开始执行run()方法。 run()方法： run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条。 总结： 调用start方法方可启动线程。 run方法只是thread的一个普通方法调用，还是在主线程里执行。 把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用run()方法，这是由jvm的内存机制规定的。 run()方法必须是public访问权限，返回值类型为void。 Runnable接口和Callable接口的相同点和不同点相同点： Callable和Runnable都是接口； Callable和Runnable都一科应用于Executors； 不同点： Callable要实现call()方法，Runnable要实现run()方法； call()方法可以有返回值，run()方法不能有返回值； call(0方法可以抛出Checked Exception，run()方法不可以； Runnable接口在Jdk1.1中就有了，Callable在JDK1.5才有； voliate关键字的作用 多线程使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据。 Java代码执行中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率。 CyclicBarrier和CountDownLatch的区别 CountDownLatch CyclicBarrier 减计数方式 加计数方式 计数为0时唤醒所有等待的线程 计数达到指定值时唤醒所有等待的线程 计数为0无法重置 计数达到指定值时，计数置为0重新开始 调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没有影响 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 不能重复利用 可重复使用 voliate和synchronized对比 volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住。 volatile仅能使用在变量级别,synchronized则可以使用在变量,方法以及类级别。 volatile仅能实现变量的修改可见性,而synchronized则可以保证变量的修改可见性和原子性。 volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞。 怎么唤醒一个阻塞的线程 如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它； 如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。 sleep方法和wait方法的相同点和不同点相同点： 二者都可以让线程处于阻塞； 不同点： 首先sleep方法是Thread类中定义的方法，而wait方法是Object类中定义的方法。 sleep方法必须人为地为其指定休眠时间。wait方法既可以指定时间，也可以不指定时间。 sleep方法时间到了，线程处于临时阻塞状态或者运行状态。wait方法如果没有被设置时间，就必须要通过notify或者notifyAll来唤醒。 sleep方法不一定非要定义在同步中。wait方法必须定义在同步中。 当二者都定义在同步中时，线程执行到sleep，不会释放锁。线程执行到wait，会释放锁。 生产者和消费者模型的作用 通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用。 解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约。 Executor.submit()和Executor.execute()的区别 前者返回一个 Future对象，可以用于找到工作线程的运行结果。 在异常处理上也不一样，在任务抛出异常时，如果是通过 execute()提交的，会抛出无需捕获的异常（如果你没有特殊处理，会打印错误栈道System.err）。如果是通过 submit()提交的，任何异常，无论是不是checked exception，都是返回的一部分，Future.get将把异常包在 ExecutionExeption中，向上层抛出。 ThreadLocal的作用 ThreadLocal用来解决多线程程序的并发问题。 ThreadLocal并不是一个Thread,而是Thread的局部变量,当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,所以每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本。 从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。 线程局部变量并不是Java的新发明,Java没有提供在语言级支持(语法上),而是变相地通过ThreadLocal的类提供支持。 wait方法和notify/notifyAll方法在放弃对象监视器时的区别 wait()方法立即释放对象监视器； notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。 Lock和synchronized对比 Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现； synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断； 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 Lock可以提高多个线程进行读操作的效率。 在JDK1.5中，synchronized是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞式的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java提供的Lock对象，性能更高一些。但是，JDK1.6，发生了变化，对synchronize加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在JDK1.6上synchronize的性能并不比Lock差。因此。提倡优先考虑使用synchronized来进行同步。 ReadWriteLock是什么 ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。 FutureTask是什么 FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。 Java中用到的线程调度算法 抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。 乐观锁和悲观锁 乐观锁：对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-设置这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。悲观锁：对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，直接对操作资源上了锁。 编写一个死锁程序死锁现象描述：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。 死锁的实现步骤： 两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁； 线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，100毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁; 线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的这样，线程1″睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。 代码实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class DeadLock &#123; public void run() &#123; TestDeadLock tl = new TestDeadLock(); new Thread(tl, &quot;线程A&quot;).start(); new Thread(tl, &quot;线程B&quot;).start(); &#125; class TestDeadLock implements Runnable &#123; private Object objA = new Object(); private Object objB = new Object(); private boolean flag = true; @Override public void run() &#123; if (flag) &#123; flag = false; synchronized (objA) &#123; System.out.println(Thread.currentThread().getName() + &quot;锁住资源A，等待资源B&quot;); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (objB) &#123; System.out.println(Thread.currentThread().getName() + &quot;获得资源B&quot;); &#125; &#125; &#125; else &#123; flag = true; synchronized (objB) &#123; System.out.println(Thread.currentThread().getName() + &quot;锁住资源B，等待资源A&quot;); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (objA) &#123; System.out.println(Thread.currentThread().getName() + &quot;获得资源A&quot;); &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; new DeadLock().run(); &#125;&#125;输出结果是：线程A锁住资源A，等待资源B线程B锁住资源B，等待资源A Java中如何避免死锁 死锁发生是因为两个线程试图获取被对方持有的资源。但是要想发生这种情况，必须满足以下四个条件： 相互排斥 —— 至少一个进程必须处于非共享模式； 保持并等待 —— 必须有一个进程持有一个资源并等待另一个资源； 没有抢占 —— 资源不能被抢占； 循环等待 —— 存在进程集合。通过中断循环等待可以避免死锁。可以通过在代码中指定获取和释放锁的顺序来达到这一目的。 如果多个锁通过一致的顺序被获取和释放，不会有互相等待对方释放锁的情况。]]></content>
      <categories>
        <category>面试题</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法画流程图]]></title>
    <url>%2F2019%2F05%2F19%2FMarkdown-%E8%AF%AD%E6%B3%95%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE.html</url>
    <content type="text"><![CDATA[添加支持Hexo 默认是不支持流程图的 Markdown 语法的，需要添加支持：1npm install --save hexo-filter-flowchart 演示一个简单的流程图语法如下：12345678910···flow #由于渲染问题，请自行将 · 替换为 `st=&gt;start: 开始e=&gt;end: 结束op=&gt;operation: 我的操作cond=&gt;condition: 确认？st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op··· 效果如下： 一个稍复杂的流程图语法如下：12345678910111213···flow #由于渲染问题，请自行将 · 替换为 `st=&gt;start: Start:&gt;http://www.google.com[blank]e=&gt;end:&gt;http://www.google.comop1=&gt;operation: My Operationsub1=&gt;subroutine: My Subroutinecond=&gt;condition: Yesor No?:&gt;http://www.google.comio=&gt;inputoutput: catch something...st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1··· 效果如下： 语法详解Hexo中的流程图是依赖于flowchart.js 实现的。以上面那个稍复杂的流程图为例：1234567891011121314···flow #由于渲染问题，请自行将 · 替换为 `//定义部分st=&gt;start: Start:&gt;http://www.google.com[blank]e=&gt;end:&gt;http://www.google.comop1=&gt;operation: My Operationsub1=&gt;subroutine: My Subroutinecond=&gt;condition: Yes or No?:&gt;http://www.google.comio=&gt;inputoutput: catch something...//判断和位置控制st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1··· 例如这一句： st=&gt;start: Start|past:&gt;http://www.google.com[blank] 其中，st是变量名，start是指操作模块名，冒号后面就是内容了。需要注意的是， 冒号后要加空格才能识别 操作模块语法 操作模块 说明 start 开始 end 结束 operation 普通操作块 condition 判断块 subroutine 子任务块 inputoutput 输入输出块 判断和位置控制`流程控制st-&gt;op1-&gt;e -&gt; 作为控制流程的操作符，就是指向下一步要操作的。 每一条都算是一条流程 你也可以断开写，怎么方便怎么来，如：下面两个是一样的。 分着写st-&gt;op1op1-&gt;e 合着写st-&gt;op1-&gt;e 判断cond(yes)-&gt;io-&gt;e #yes的时候到io，再到e 位置指定cond(no)-&gt;sub1(right)-&gt;op1 #no的时候到到 sub1，再从sub1的右侧到op1还可以这样 cond1(no,right)`st=>start: 开始 e=>end: 结束 op=>operation: 我的操作 cond=>condition: 确认？ st->op->cond cond(yes)->e cond(no)->op{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);st=>start: Start:>http://www.google.com[blank] e=>end:>http://www.google.com op1=>operation: My Operation sub1=>subroutine: My Subroutine cond=>condition: Yes or No?:>http://www.google.com io=>inputoutput: catch something... st->op1->cond cond(yes)->io->e cond(no)->sub1(right)->op1{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-1", options);]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法糖]]></title>
    <url>%2F2019%2F05%2F19%2FMarkdown%E8%AF%AD%E6%B3%95%E7%B3%96.html</url>
    <content type="text"><![CDATA[前言Markdown 是一种轻量级的标记语言，其用简单的标记语法便可达到排版的目的，可以使我们更加专注于内容的编写，而不需过多关注排版。本文主要整理了 Markdown 中的常用的标记语法，以便自己与他人以后查用。 优点 纯文本，所以兼容性极强，可以用所有文本编辑器打开。 让你专注于文字而不是排版。 格式转换方便，Markdown 的文本你可以轻松转换为 html、电子书等。 Markdown 的标记语法有极好的可读性。 缺点 需要记一些语法（当然，是很简单。五分钟学会）。 有些平台不支持Markdown编辑模式。 基本语法标题在想要设置为标题的文字前面加#来表示，一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：#与文字之间要有一个空格。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 字体星号或者下划线都可以，单是斜体，双是粗体，符号可以跨行，符号可加空格。 加粗要加粗的文字左右分别用两个*号包起来 斜体要倾斜的文字左右分别用一个*号包起来 斜体加粗要倾斜和加粗的文字左右分别用三个*号包起来 删除线要加删除线的文字左右分别用两个~~号包起来 示例： 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…貌似可以一直加下去，但没神马卵用。 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 分割线三个或者三个以上的 - 或者 * 都可以。 示例： 1234-------******** 效果如下：可以看到，显示效果是一样的。 图片语法：1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例：1![一脸懵逼](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1558179968948&amp;di=1c8a7432843fdaafb91e9cbffacd1557&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201608%2F02%2F20160802213915_x23St.thumb.700_0.jpeg &quot;一脸懵逼&quot;) 效果如下： 超链接语法：12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例：12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下：简书百度注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 索引超链接示例：12[百度][1][1]:http://www.baidu.com 效果如下：[百度][1][1]:http://www.baidu.com 自动链接语法：使用尖括号。 示例：12&lt;http://www.baidu.com&gt;&lt;1111111@qq.com&gt; 效果如下：http://www.baidu.com&#49;&#49;&#x31;&#49;&#49;&#49;&#x31;&#64;&#113;&#x71;&#46;&#x63;&#111;&#109; 列表无序列表语法：无序列表用 - + * 任何一种都可以。12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表语法：数字加点。123451. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 嵌套列表语法：上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 注意：在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2019.5.18 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了。如所示：示例：12019\.5\.18 效果如下：2019.5.18 表格语法：1234567891011|表头|表头|表头||---|:---:|---:||内容|内容|内容||内容|内容|内容|第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例1：12345| 法号 | 本领 | 排行 || :--------: | :-----: | :----: || 悟空 | 72变 | 大师兄|| 悟能 | 36变 | 二师哥|| 悟净 | 18变 | 三师弟| 效果如下： 法号 本领 排行 悟空 72变 大师兄 悟能 36变 二师哥 悟净 18变 三师弟 示例2：1234567891011121314151617181920212223242526272829表头1 | 表头2------------- | -------------Content Cell | Content CellContent Cell | Content Cell| 表头1 | 表头2|| ------------- | ------------- || Content Cell | Content Cell || Content Cell | Content Cell || 名字 | 描述 || ------------- | ----------- || Help | Display the help window.|| Close | Closes a window |表格中也可以使用普通文本的删除线，斜体等效果| 名字 | 描述 || ------------- | ----------- || Help | ~~Display the~~ help window.|| Close | _Closes_ a window |表格可以指定对齐方式| 左对齐 | 居中 | 右对齐 || :------------ |:---------------:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 效果如下：表头1 | 表头2————- | ————-Content Cell | Content CellContent Cell | Content Cell 表头1 表头2 Content Cell Content Cell Content Cell Content Cell 名字 描述 Help Display the help window. Close Closes a window 名字 描述 Help Display the help window. Close Closes a window 左对齐 居中 右对齐 col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 代码单行代码语法：代码之间分别用一个反引号包起来。1`代码内容` 示例：1`create database hero;` 效果如下：create database hero; 代码块语法：代码之间分别用三个反引号包起来，且两边的反引号单独占一行。12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例：123456(```) function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;; &#125; fun();(```) 效果如下：1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); 注释语法：用html的注释1&lt;!-- 用html的注释 --&gt; 转义字符Markdown中的转义字符为\，转义的有：123456789101112\\ 反斜杠\` 反引号\* 星号\_ 下划线\&#123;\&#125; 大括号\[\] 中括号\(\) 小括号\# 井号\+ 加号\- 减号\. 英文句号\! 感叹号 效果如下：\ 反斜杠` 反引号* 星号_ 下划线{} 大括号[] 中括号() 小括号# 井号+ 加号- 减号. 英文句号! 感叹号 其他特殊字符示例：1234567891011&amp;#10084&amp;#10003&amp;#9728&amp;#9733&amp;#9730&amp;#9775&amp;#9762&amp;#9742&amp;#8734&amp;#10052&amp;#9835 效果如下：&amp;#10084&amp;#10003&amp;#9728&amp;#9733&amp;#9730&amp;#9775&amp;#9762&amp;#9742&amp;#8734&amp;#10052&amp;#9835 想知道字符对应的Unicode码，可以看这个网站：https://unicode-table.com/cn/ 流程图效果如下： 段落与换行Markdown中段落指连续的一段文字，编写时段落之间至少一个空行隔开，段落内多个空格被视为一个空格，段首不支持缩进。如何想要在显示时显示多个空行，可以插入实现，注意的是，插入的应与前后的段落中间至少空一行。 段落缩进（空格）示例：1234半方大的空白&amp;ensp;或&amp;#8194;看，飞碟全方大的空白&amp;emsp;或&amp;#8195;看，飞碟不断行的空白格&amp;nbsp;或&amp;#160;看，飞碟&amp;emsp;&amp;emsp;段落从此开始。 效果如下：半方大的空白&ensp;或&#8194;看，飞碟全方大的空白&emsp;或&#8195;看，飞碟不断行的空白格&nbsp;或&#160;看，飞碟&emsp;&emsp;段落从此开始。 字体、字号、颜色、背景色示例：1234567&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;&lt;font color=#00ffff size=3&gt;null&lt;/font&gt;&lt;font color=gray size=5&gt;gray&lt;/font&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF4500&gt;这里的背景色是：OrangeRed， 十六进制颜色值：#FF4500， rgb(255, 69, 0)&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 效果如下： 我是黑体字 我是微软雅黑 我是华文彩云 黑体 null gray 这里的背景色是：OrangeRed， 十六进制颜色值：#FF4500， rgb(255, 69, 0) 快捷键 功能 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y GitHub特有特性复选框列表在列表符号后面加上[]或者[x]代表选中或者未选中情况。示例：1234567+ [x] C+ [x] C+++ [x] Java+ [x] Qt+ [x] Android+ [ ] C#+ [ ] .NET 效果如下： C C++ Java Qt Android C# .NET emoji表情符号emoji表情使用:EMOJICODE:的格式，详细列表可见：https://www.webpagefx.com/tools/emoji-cheat-sheet/当然现在很多markdown工具或者网站都不支持。 下面列出几个平台的对比： 工具/网站 emoji 简书 否 github 是 有道云笔记 否 st=>start: 开始 op=>operation: My Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改GitHub项目语言显示问题]]></title>
    <url>%2F2019%2F05%2F18%2F%E4%BF%AE%E6%94%B9GitHub%E9%A1%B9%E7%9B%AE%E8%AF%AD%E8%A8%80%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[概述当我们上传项目到GitHub上，有时候项目显示的语言并非是我们自己项目所示的语言，这就导致我们在快速检索，或者外部访问者访问时不能够搜索到我们的项目，所以，此时就很有必要修改下语言。 修改GitHub语言1、在本地项目中或者GitHub项目中新建一个 .gitattributes的文件，输入以下内容：12345*.yml linguist-language=Java *.html linguist-language=Java *.js linguist-language=Java *.xml linguist-language=Java*.css linguist-language=Java 需要说明的是，假如我们的项目中有很多的诸如.html、.js等文件，在GitHub上会显示为HTML、JavaScript，所以.gitattributes文件内容的意思就是将忽略.xx什么什么文件，然后将其语言更改为Java，如果你的项目是其他语言，诸如C++等就将Java修改为C++等。当然了，这样修改也许还不能将你的项目语言修改成功，所以你需要去查询你项目中所有尽可能的后缀名文件影响语言的情况考虑，要根据GitHub给你当前项目设定的是什么语言，就从什么语言去考虑就好了。所以在.gitattributes文件中添加多一些属性就解决了。如下：123456789*.md linguist-language=Java *.yml linguist-language=Java *.html linguist-language=Java *.js linguist-language=Java *.xml linguist-language=Java*.css linguist-language=Java *.sql linguist-language=Java*.uml linguist-language=Java *.cmd linguist-language=Java]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的SpringBoot启动banner（持续更新）]]></title>
    <url>%2F2019%2F05%2F18%2F%E6%9C%89%E8%B6%A3%E7%9A%84SpringBoot%E5%90%AF%E5%8A%A8banner%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89.html</url>
    <content type="text"><![CDATA[千里马123456789101112131415161718192021 _(\_/) ,((((^`\ (((( (6 \ ,((((( , \ ,,,_ ,((((( /&quot;._ ,`, ((((\\ ,... ,(((( / `-.-&apos; ))) ;&apos; `&quot;&apos;&quot;&apos;&quot;&quot;(((( ( ((( / ((( \ )) | |(( | . &apos; |)) \ _ &apos; `t ,.&apos;)( | y;- -,-&quot;&quot;&apos;&quot;-.\ \/ ) / ./ ) / `\ \ |./ ( ( / /&apos; || \\ //&apos;| || \\ _//&apos;|| || )) |_/ || \_\ |_/ || `&apos;&quot; \_\ `&apos;&quot; 文字兔12345678910111213141516171819202122232425262728293031323334353637/*** * 瓦瓦 十 * 十齱龠己 亅瓦車己 * 乙龍龠毋日丶 丶乙己毋毋丶 * 十龠馬鬼車瓦 己十瓦毋毋 * 鬼馬龠馬龠十 己己毋車毋瓦 * 毋龠龠龍龠鬼乙丶丶乙車乙毋鬼車己 * 乙龠龍龍鬼龍瓦 十瓦毋乙瓦龠瓦亅 * 馬齱龍馬鬼十丶日己己己毋車乙丶 * 己齱馬鬼車十十毋日乙己己乙乙 * 車馬齱齱日乙毋瓦己乙瓦日亅 * 亅車齺龖瓦乙車龖龍乙乙十 * 日龠龠十亅車龍毋十十 * 日毋己亅 己己十亅亅 * 丶己十十乙 丶丶丶丶丶 * 亅己十龍龖瓦 丶 丶 乙十 * 亅己十龠龖毋 丶丶 丶己鬼鬼瓦亅 * 十日十十日亅丶亅丶 丶十日毋鬼馬馬車乙 * 十日乙十亅亅亅丶 十乙己毋鬼鬼鬼龍齺馬乙 * 丶瓦己乙十十亅丶亅乙乙乙己毋鬼鬼鬼龍齱齺齺鬼十 * 乙乙十十十亅乙瓦瓦己日瓦毋鬼鬼龠齱齱龍龍齱齱毋丶 * 亅十十十十乙瓦車毋瓦瓦日車馬龠龍龍龍龍龍龠龠龠馬亅 * 十十十十己毋車瓦瓦瓦瓦鬼馬龠龍龠龠龍龠龠龠馬龠車 * 亅十十日毋瓦日日瓦鬼鬼鬼龠龠馬馬龠龍龍龠馬馬車 * 亅亅亅乙瓦瓦毋車車車馬龍龠鬼鬼馬龠龍龍龠馬馬鬼 * 丶丶乙亅亅乙車鬼鬼鬼毋車龍龍龠鬼馬馬龠龍齱齱龍馬鬼 * 亅己十十己十日鬼鬼車瓦毋龠龍龠馬馬龠龠龠齱齺齺齱龠鬼 * 亅乙乙乙十車馬車毋馬齱齱龍龠龠龠馬龠龍齱龍龠龠鬼瓦 * 丶毋龠鬼車瓦車馬龠龍龠龠龍齱齱龠馬馬鬼毋日 * 十乙己日十 丶己鬼龍齱齺齱龍馬馬馬車毋己 * 丶十己乙亅丶 亅瓦馬龠龍龠龠馬毋瓦乙 * 丶十十乙亅十 亅己瓦車馬龠鬼車瓦乙 * 丶十乙十十丶 丶丶亅十瓦鬼車瓦己 * 丶亅亅丶 亅日瓦日 * 丶 */ 狗头1123456789101112131415161718192021222324252627282930313233343536373839/*** * .,:,,, .::,,,::. * .::::,,;;, .,;;:,,....:i: * :i,.::::,;i:. ....,,:::::::::,.... .;i:,. ......;i. * :;..:::;::::i;,,:::;:,,,,,,,,,,..,.,,:::iri:. .,:irsr:,.;i. * ;;..,::::;;;;ri,,,. ..,,:;s1s1ssrr;,.;r, * :;. ,::;ii;:, . ................... .;iirri;;;,,;i, * ,i. .;ri:. ... ............................ .,,:;:,,,;i: * :s,.;r:... ....................................... .::;::s; * ,1r::. .............,,,.,,:,,........................,;iir; * ,s;........... ..::.,;:,,. ...............,;1s * :i,..,. .,:,,::,. .......... .......;1, * ir,....:rrssr;:, ,,.,::. .r5S9989398G95hr;. ....,.:s, * ;r,..,s9855513XHAG3i .,,,,,,,. ,S931,.,,.;s;s&amp;BHHA8s.,..,..:r: * :r;..rGGh, :SAG;;G@BS:.,,,,,,,,,.r83: hHH1sXMBHHHM3..,,,,.ir. * ,si,.1GS, sBMAAX&amp;MBMB5,,,,,,:,,.:&amp;8 3@HXHBMBHBBH#X,.,,,,,,rr * ;1:,,SH: .A@&amp;&amp;B#&amp;8H#BS,,,,,,,,,.,5XS, 3@MHABM&amp;59M#As..,,,,:,is, * .rr,,,;9&amp;1 hBHHBB&amp;8AMGr,,,,,,,,,,,:h&amp;&amp;9s; r9&amp;BMHBHMB9: . .,,,,;ri. * :1:....:5&amp;XSi;r8BMBHHA9r:,......,,,,:ii19GG88899XHHH&amp;GSr. ...,:rs. * ;s. .:sS8G8GG889hi. ....,,:;:,.:irssrriii:,. ...,,i1, * ;1, ..,....,,isssi;, .,,. ....,.i1, * ;h: i9HHBMBBHAX9: . ...,,,rs, * ,1i.. :A#MBBBBMHB##s ....,,,;si. * .r1,.. ,..;3BMBBBHBB#Bh. .. ....,,,,,i1; * :h;.. .,..;,1XBMMMMBXs,.,, .. :: ,. ....,,,,,,ss. * ih: .. .;;;, ;;:s58A3i,.. ,. ,.:,,. ...,,,,,:,s1, * .s1,.... .,;sh, ,iSAXs;. ,. ,,.i85 ...,,,,,,:i1; * .rh: ... rXG9XBBM#M#MHAX3hss13&amp;&amp;HHXr .....,,,,,,,ih; * .s5: ..... i598X&amp;&amp;A&amp;AAAAAA&amp;XG851r: ........,,,,:,,sh; * . ihr, ... . .. ........,,,,,;11:. * ,s1i. ... ..,,,..,,,.,,.,,.,.. ........,,.,,.;s5i. * .:s1r,...................... ..............;shs, * . .:shr:. .... ..............,ishs. * .,issr;,... ...........................,is1s;. * .,is1si;:,....................,:;ir1sr;, * ..:isssssrrii;::::::;;iirsssssr;:.. * .,::iiirsssssssssrri;;:. */ 狗头212345678910111213141516171819202122232425262728293031323334353637383940/*** * ii. ;9ABH, * SA391, .r9GG35&amp;G * &amp;#ii13Gh; i3X31i;:,rB1 * iMs,:,i5895, .5G91:,:;:s1:8A * 33::::,,;5G5, ,58Si,,:::,sHX;iH1 * Sr.,:;rs13BBX35hh11511h5Shhh5S3GAXS:.,,::,,1AG3i,GG * .G51S511sr;;iiiishS8G89Shsrrsh59S;.,,,,,..5A85Si,h8 * :SB9s:,............................,,,.,,,SASh53h,1G. * .r18S;..,,,,,,,,,,,,,,,,,,,,,,,,,,,,,....,,.1H315199,rX, * ;S89s,..,,,,,,,,,,,,,,,,,,,,,,,....,,.......,,,;r1ShS8,;Xi * i55s:.........,,,,,,,,,,,,,,,,.,,,......,.....,,....r9&amp;5.:X1 * 59;.....,. .,,,,,,,,,,,... .............,..:1;.:&amp;s * s8,..;53S5S3s. .,,,,,,,.,.. i15S5h1:.........,,,..,,:99 * 93.:39s:rSGB@A; ..,,,,..... .SG3hhh9G&amp;BGi..,,,,,,,,,,,,.,83 * G5.G8 9#@@@@@X. .,,,,,,..... iA9,.S&amp;B###@@Mr...,,,,,,,,..,.;Xh * Gs.X8 S@@@@@@@B:..,,,,,,,,,,. rA1 ,A@@@@@@@@@H:........,,,,,,.iX: * ;9. ,8A#@@@@@@#5,.,,,,,,,,,... 9A. 8@@@@@@@@@@M; ....,,,,,,,,S8 * X3 iS8XAHH8s.,,,,,,,,,,...,..58hH@@@@@@@@@Hs ...,,,,,,,:Gs * r8, ,,,...,,,,,,,,,,..... ,h8XABMMHX3r. .,,,,,,,.rX: * :9, . .:,..,:;;;::,.,,,,,.. .,,. ..,,,,,,.59 * .Si ,:.i8HBMMMMMB&amp;5,.... . .,,,,,.sMr * SS :: h@@@@@@@@@@#; . ... . ..,,,,iM5 * 91 . ;:.,1&amp;@@@@@@MXs. . .,,:,:&amp;S * hS .... .:;,,,i3MMS1;..,..... . . ... ..,:,.99 * ,8; ..... .,:,..,8Ms:;,,,... .,::.83 * s&amp;: .... .sS553B@@HX3s;,. .,;13h. .:::&amp;1 * SXr . ...;s3G99XA&amp;X88Shss11155hi. ,;:h&amp;, * iH8: . .. ,;iiii;,::,,,,,. .;irHA * ,8X5; . ....... ,;iihS8Gi * 1831, .,;irrrrrs&amp;@ * ;5A8r. .:;iiiiirrss1H * :X@H3s....... .,:;iii;iiiiirsrh * r#h:;,...,,.. .,,:;;;;;:::,... .:;;;;;;iiiirrss1 * ,M8 ..,....,.....,,::::::,,... . .,;;;iiiiiirss11h * 8B;.,,,,,,,.,..... . .. .:;;;;iirrsss111h * i@5,:::,,,,,,,,.... . . .:::;;;;;irrrss111111 * 9Bi,:,,,,...... ..r91;;;;;iirrsss1ss1111 */ 滑稽笑脸12345678910111213141516171819202122232425262728293031323334/*** * .,, .,:;;iiiiiiiii;;:,,. .,, * rGB##HS,.;iirrrrriiiiiiiiiirrrrri;,s&amp;##MAS, * r5s;:r3AH5iiiii;;;;;;;;;;;;;;;;iiirXHGSsiih1, * .;i;;s91;;;;;;::::::::::::;;;;iS5;;;ii: * :rsriii;;r::::::::::::::::::::::;;,;;iiirsi, * .,iri;;::::;;;;;;::,,,,,,,,,,,,,..,,;;;;;;;;iiri,,. * ,9BM&amp;, .,:;;:,,,,,,,,,,,hXA8: ..,,,. * ,;&amp;@@#r:;;;;;::::,,. ,r,,,,,,,,,,iA@@@s,,:::;;;::,,. .;. * :ih1iii;;;;;::::;;;;;;;:,,,,,,,,,,;i55r;;;;;;;;;iiirrrr,.. * .ir;;iiiiiiiiii;;;;::::::,,,,,,,:::::,,:;;;iiiiiiiiiiiiri * iriiiiiiiiiiiiiiii;;;::::::::::::::::;;;iiiiiiiiiiiiiiiir; * ,riii;;;;;;;;;;;;;:::::::::::::::::::::::;;;;;;;;;;;;;;iiir. * iri;;;::::,,,,,,,,,,:::::::::::::::::::::::::,::,,::::;;iir: * .rii;;::::,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,::::;;iri * ,rii;;;::,,,,,,,,,,,,,:::::::::::,:::::,,,,,,,,,,,,,:::;;;iir. * ,rii;;i::,,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,,::i;;iir. * ,rii;;r::,,,,,,,,,,,,,:,:::::,:,:::::::,,,,,,,,,,,,,::;r;;iir. * .rii;;rr,:,,,,,,,,,,,,,,:::::::::::::::,,,,,,,,,,,,,:,si;;iri * ;rii;:1i,,,,,,,,,,,,,,,,,,:::::::::,,,,,,,,,,,,,,,:,ss:;iir: * .rii;;;5r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,sh:;;iri * ;rii;:;51,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.:hh:;;iir, * irii;::hSr,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,sSs:;;iir: * irii;;:iSSs:.,,,,,,,,,,,,,,,,,,,,,,,,,,,..:135;:;;iir: * ;rii;;:,r535r:...,,,,,,,,,,,,,,,,,,..,;sS35i,;;iirr: * :rrii;;:,;1S3Shs;:,............,:is533Ss:,;;;iiri, * .;rrii;;;:,;rhS393S55hh11hh5S3393Shr:,:;;;iirr: * .;rriii;;;::,:;is1h555555h1si;:,::;;;iirri:. * .:irrrii;;;;;:::,,,,,,,,:::;;;;iiirrr;, * .:irrrriiiiii;;;;;;;;iiiiiirrrr;,. * .,:;iirrrrrrrrrrrrrrrrri;:. * ..,:::;;;;:::,,. */ 键盘1234567891011121314151617/*** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│&amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │&#123; [│&#125; ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│&quot; &apos;│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │&lt; ,│&gt; .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ */ 佛祖保佑123456789101112131415161718192021222324/*** * _ooOoo_ * o8888888o * 88&quot; . &quot;88 * (| -_- |) * O\ = /O * ____/`---&apos;\____ * . &apos; \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| &apos;&apos;\---/&apos;&apos; | | * \ .-\__ `-` ___/-. / * ___`. .&apos; /--.--\ `. . __ * .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-&apos;====== * `=---=&apos; * * ............................................. * 佛祖保佑 永无BUG */ 佛曰123456789101112/*** * 佛曰: * 写字楼里写字间，写字间里程序员； * 程序人员写程序，又拿程序换酒钱。 * 酒醒只在网上坐，酒醉还来网下眠； * 酒醉酒醒日复日，网上网下年复年。 * 但愿老死电脑间，不愿鞠躬老板前； * 奔驰宝马贵者趣，公交自行程序员。 * 别人笑我忒疯癫，我笑自己命太贱； * 不见满街漂亮妹，哪个归得程序员？ */ 佛祖瘫痪1234567891011121314151617181920212223/*** * _ooOoo_ * o8888888o * 88&quot; . &quot;88 * (| -_- |) * O\ = /O * ___/`---&apos;\____ * . &apos; \\| |// `. * / \\||| : |||// \ * / _||||| -:- |||||- \ * | | \\\ - /// | | * | \_| &apos;&apos;\---/&apos;&apos; | | * \ .-\__ `-` ___/-. / * ___`. .&apos; /--.--\ `. . __ * .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. * | | : `- \`.;`\ _ /`;.`/ - ` : | | * \ \ `-. \_ __\ /__ _/ .-` / / * ======`-.____`-.___\_____/___.-`____.-&apos;====== * `=---=&apos; * ............................................. * 佛曰：bug泛滥，我已瘫痪！ */ Fuck Bug12345678910111213/*** * * █████▒█ ██ ▄████▄ ██ ▄█▀ ██████╗ ██╗ ██╗ ██████╗ * ▓██ ▒ ██ ▓██▒▒██▀ ▀█ ██▄█▒ ██╔══██╗██║ ██║██╔════╝ * ▒████ ░▓██ ▒██░▒▓█ ▄ ▓███▄░ ██████╔╝██║ ██║██║ ███╗ * ░▓█▒ ░▓▓█ ░██░▒▓▓▄ ▄██▒▓██ █▄ ██╔══██╗██║ ██║██║ ██║ * ░▒█░ ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄ ██████╔╝╚██████╔╝╚██████╔╝ * ▒ ░ ░▒▓▒ ▒ ▒ ░ ░▒ ▒ ░▒ ▒▒ ▓▒ ╚═════╝ ╚═════╝ ╚═════╝ * ░ ░░▒░ ░ ░ ░ ▒ ░ ░▒ ▒░ * ░ ░ ░░░ ░ ░ ░ ░ ░░ ░ * ░ ░ ░ ░ ░ */ 哭脸神兽12345678910111213141516171819202122232425/*** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ ─┬┘ └┬─ │ * │ │ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! */ 害羞神兽12345678910111213141516171819202122232425/*** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ &gt; &lt; │ * │ │ * │ ... ⌒ ... │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! */ 墨镜神兽12345678910111213141516171819202122232425/*** * ┌─┐ ┌─┐ + + * ┌──┘ ┴───────┘ ┴──┐++ * │ │ * │ ─── │++ + + + * ███████───███████ │+ * │ │+ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ + + * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ + + + + * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ + + + + * 神兽保佑 * 代码无BUG! */ 蝙蝠123456789101112131415161718192021/*** * ___====-_ _-====___ * _--^^^#####// \\#####^^^--_ * _-^##########// ( ) \\##########^-_ * -############// |\^^/| \\############- * _/############// (@::@) \\############\_ * /#############(( \\// ))#############\ * -###############\\ (oo) //###############- * -#################\\ / VV \ //#################- * -###################\\/ \//###################- * _#/|##########/\######( /\ )######/\##########|\#_ * |/ |#/\#/\#/\/ \#/\##\ | | /##/\#/ \/\#/\#/\#| \| * ` |/ V V ` V \#\| | | |/#/ V &apos; V V \| &apos; * ` ` ` ` / | | | | \ &apos; &apos; &apos; &apos; * ( | | | | ) * __\ | | | | /__ * (vvv(VVV)(VVV)vvv) * 神兽保佑 * 代码无BUG! */ 飞天龙123456789101112131415161718192021222324/*** * * * __----~~~~~~~~~~~------___ * . . ~~//====...... __--~ ~~ * -. \_|// |||\\ ~~~~~~::::... /~ * ___-==_ _-~o~ \/ ||| \\ _/~~- * __---~~~.==~||\=_ -_--~/_-~|- |\\ \\ _/~ * _-~~ .=~ | \\-_ &apos;-~7 /- / || \ / * .~ .~ | \\ -_ / /- / || \ / * / ____ / | \\ ~-_/ /|- _/ .|| \ / * |~~ ~~|--~~~~--_ \ ~==-/ | \~--===~~ .\ * &apos; ~-| /| |-~\~~ __--~~ * |-~~-_/ | | ~\_ _-~ /\ * / \ \__ \/~ \__ * _--~ _/ | .-~~____--~-/ ~~==. * ((-&gt;/~ &apos;.|||&apos; -_| ~~-/ , . _|| * -_ ~\ ~~---l__i__i__i--~~_/ * _-~-__ ~) \--______________--~~ * //.-~~~-~_--~- |-------~~~~~~~~ * //.-~~~--\ * 神兽保佑 * 代码无BUG! */ 猪123456789101112131415/*** _ * _._ _..._ .-&apos;, _.._(`)) * &apos;-. ` &apos; /-._.-&apos; &apos;,/ * ) \ &apos;. * / _ _ | \ * | a a / | * \ .-. ; * &apos;-(&apos;&apos; ).-&apos; ,&apos; ; * &apos;-; | .&apos; * \ \ / * | 7 .__ _.-\ \ * | | | ``/ /` / * /,_| | /,_/ / * /,_/ &apos;`-&apos; */ 骷髅头123456789101112131415161718192021222324/*** ************************************************************** * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * | ______ | * * | .-&quot; &quot;-. | * * | / \ | * * | _ | | _ | * * | ( \ |, .-. .-. ,| / ) | * * | &gt; &quot;=._ | )(__/ \__)( | _.=&quot; &lt; | * * | (_/&quot;=._&quot;=._ |/ /\ \| _.=&quot;_.=&quot;\_) | * * | &quot;=._&quot;(_ ^^ _)&quot;_.=&quot; | * * | &quot;=\__|IIIIII|__/=&quot; | * * | _.=&quot;| \IIIIII/ |&quot;=._ | * * | _ _.=&quot;_.=&quot;\ /&quot;=._&quot;=._ _ | * * | ( \_.=&quot;_.=&quot; `--------` &quot;=._&quot;=._/ ) | * * | &gt; _.=&quot; &quot;=._ &lt; | * * | (_/ \_) | * * | | * * &apos;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=&apos; * * * * LASCIATE OGNI SPERANZA, VOI CH&apos;ENTRATE * ************************************************************** */ 妈妈再爱我一次123456789101112131415161718192021222324252627282930313233/*** * ,s555SB@@&amp; * :9H####@@@@@Xi * 1@@@@@@@@@@@@@@8 * ,8@@@@@@@@@B@@@@@@8 * :B@@@@X3hi8Bs;B@@@@@Ah, * ,8i r@@@B: 1S ,M@@@@@@#8; * 1AB35.i: X@@8 . SGhr ,A@@@@@@@@S * 1@h31MX8 18Hhh3i .i3r ,A@@@@@@@@@5 * ;@&amp;i,58r5 rGSS: :B@@@@@@@@@@A * 1#i . 9i hX. .: .5@@@@@@@@@@@1 * sG1, ,G53s. 9#Xi;hS5 3B@@@@@@@B1 * .h8h.,A@@@MXSs, #@H1: 3ssSSX@1 * s ,@@@@@@@@@@@@Xhi, r#@@X1s9M8 .GA981 * ,. rS8H#@@@@@@@@@@#HG51;. .h31i;9@r .8@@@@BS;i; * .19AXXXAB@@@@@@@@@@@@@@#MHXG893hrX#XGGXM@@@@@@@@@@MS * s@@MM@@@hsX#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&amp;, * :GB@#3G@@Brs ,1GM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B, * .hM@@@#@@#MX 51 r;iSGAM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8 * :3B@@@@@@@@@@@&amp;9@h :Gs .;sSXH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: * s&amp;HA#@@@@@@@@@@@@@@M89A;.8S. ,r3@@@@@@@@@@@@@@@@@@@@@@@@@@@r * ,13B@@@@@@@@@@@@@@@@@@@5 5B3 ;. ;@@@@@@@@@@@@@@@@@@@@@@@@@@@i * 5#@@#&amp;@@@@@@@@@@@@@@@@@@9 .39: ;@@@@@@@@@@@@@@@@@@@@@@@@@@@; * 9@@@X:MM@@@@@@@@@@@@@@@#; ;31. H@@@@@@@@@@@@@@@@@@@@@@@@@@: * SH#@B9.rM@@@@@@@@@@@@@B :. 3@@@@@@@@@@@@@@@@@@@@@@@@@@5 * ,:. 9@@@@@@@@@@@#HB5 .M@@@@@@@@@@@@@@@@@@@@@@@@@B * ,ssirhSM@&amp;1;i19911i,. s@@@@@@@@@@@@@@@@@@@@@@@@@@S * ,,,rHAri1h1rh&amp;@#353Sh: 8@@@@@@@@@@@@@@@@@@@@@@@@@#: * .A3hH@#5S553&amp;@@#h i:i9S #@@@@@@@@@@@@@@@@@@@@@@@@@A. * * * 又看源码，看你妹妹呀！ */ 初音12345678910111213141516171819202122232425/*** *_______________#########_______________________ *______________############_____________________ *______________#############____________________ *_____________##__###########___________________ *____________###__######_#####__________________ *____________###_#######___####_________________ *___________###__##########_####________________ *__________####__###########_####_______________ *________#####___###########__#####_____________ *_______######___###_########___#####___________ *_______#####___###___########___######_________ *______######___###__###########___######_______ *_____######___####_##############__######______ *____#######__#####################_#######_____ *____#######__##############################____ *___#######__######_#################_#######___ *___#######__######_######_#########___######___ *___#######____##__######___######_____######___ *___#######________######____#####_____#####____ *____######________#####_____#####_____####_____ *_____#####________####______#####_____###______ *______#####______;###________###______#________ *________##_______####________####______________ */ 攻城湿123456789101112131415161718192021/*** * ,%%%%%%%%, * ,%%/\%%%%/\%% * ,%%%\c &quot;&quot; J/%%% * %. %%%%/ o o \%%% * `%%. %%%% _ |%%% * `%% `%%%%(__Y__)%%&apos; * // ;%%%%`\-/%%%&apos; * (( / `%%%%%%%&apos; * \\ .&apos; | * \\ / \ | | * \\/ ) | | * \ /_ | |__ * (___________))))))) 攻城湿 * * _ _ * __ _(_)_ _(_) __ _ _ __ * \ \ / / \ \ / / |/ _` |&apos;_ \ * \ V /| |\ V /| | (_| | | | | * \_/ |_| \_/ |_|\__,_|_| |_| */ 掘金1234567891011121314151617181920212223/*** * https://gold.xitu.io/ * １１１ １ * １１１ １１１１１１１１１１１１ １１１ * １１ １１１１１１１１１１１１ １１１１１ * １１ １１１ １１ １１１１１１１ * １１１１ １ １１１１１１１１１１１ １１１ １１１１ * １１１１１１ １１１１１１１１１１１ １１１１ １１１１１ * １１１１１１ １１ １１１１ １１１１１１ * １１ １１１１１１１１ １１ １１１１１１１１１１１１１１１１１１ * １１ １１１１１１１１１１１ １１１１１１１１１１１１１１１１１１１ * １１１１１１１１１ １１ １１ １１ １１ * １１１１１１１１１１１１１１１１１１ １１ * １１１１ １１１１１１１１１１１１ １１１１１１１１１１１１１１ * １１１１ １１ １１ １１１１１１１１１１１１１１ * １１ １１ １１ １１ １１１ １１ １１ １１１ * １１ １１ １１ １１ １１ １１１ １１ １１１ * １１ １１１ １１ １１ １１ １１１ １１ １１１ * １１１１ １１１ １１１１１１１１１ １１ １１１ １１ １１１１１１１ * １１１１１１ １１１１１１１１１１ １１１１１１１１１１１１１１１１１ * １１ １１１ １１１ １１１１１１１１１１１１１１１１１ */ 知乎123456789101112131415161718192021222324/*** * https://www.zhihu.com/ * _____ _____ _____ _____ * /\ \ /\ \ /\ \ /\ \ * /::\____\ /::\ \ /::\ \ /::\ \ * /:::/ / \:::\ \ /::::\ \ /::::\ \ * /:::/ / \:::\ \ /::::::\ \ /::::::\ \ * /:::/ / \:::\ \ /:::/\:::\ \ /:::/\:::\ \ * /:::/____/ \:::\ \ /:::/__\:::\ \ /:::/__\:::\ \ * /::::\ \ /::::\ \ /::::\ \:::\ \ /::::\ \:::\ \ * /::::::\ \ _____ ____ /::::::\ \ /::::::\ \:::\ \ /::::::\ \:::\ \ * /:::/\:::\ \ /\ \ /\ \ /:::/\:::\ \ /:::/\:::\ \:::\____\ /:::/\:::\ \:::\ \ * /:::/ \:::\ /::\____\/::\ \/:::/ \:::\____\/:::/ \:::\ \:::| |/:::/__\:::\ \:::\____\ * \::/ \:::\ /:::/ /\:::\ /:::/ \::/ /\::/ |::::\ /:::|____|\:::\ \:::\ \::/ / * \/____/ \:::\/:::/ / \:::\/:::/ / \/____/ \/____|:::::\/:::/ / \:::\ \:::\ \/____/ * \::::::/ / \::::::/ / |:::::::::/ / \:::\ \:::\ \ * \::::/ / \::::/____/ |::|\::::/ / \:::\ \:::\____\ * /:::/ / \:::\ \ |::| \::/____/ \:::\ \::/ / * /:::/ / \:::\ \ |::| ~| \:::\ \/____/ * /:::/ / \:::\ \ |::| | \:::\ \ * /:::/ / \:::\____\ \::| | \:::\____\ * \::/ / \::/ / \:| | \::/ / * \/____/ \/____/ \|___| \/____/ */ freebuf1234567891011121314151617181920212223242526272829/*** * http://www.freebuf.com/ * _.._ ,------------. * ,&apos; `. ( We want you! ) * / __) __` \ `-,----------&apos; * ( (`-`(-&apos;) ) _.-&apos; * /) \ = / ( * /&apos; |--&apos; . \ * ( ,---| `-.)__` * )( `-.,--&apos; _`-. * &apos;/,&apos; ( Uu&quot;, * (_ , `/,-&apos; ) * `.__, : `-&apos;/ /`--&apos; * | `--&apos; | * ` `-._ / * \ ( * /\ . \. freebuf * / |` \ ,-\ * / \| .) / \ * ( ,&apos;|\ ,&apos; : * | \,`.`--&quot;/ &#125; * `,&apos; \ |,&apos; / * / &quot;-._ `-/ | * &quot;-. &quot;-.,&apos;| ; * / _/[&quot;---&apos;&quot;&quot;] * : / |&quot;- &apos; * &apos; | / * ` | */ Alibaba12345678910111213141516171819202122232425262728293031323334353637/*** * https://campus.alibaba.com/ * `:::::::::::, * `::;:::::::;:::::::, ` * `::;;:::::::@@@@;:::::::` * ,:::::::::::::@ #@&apos;:::::` * :::::::::::::::&apos;@@ @;:::: * ::::::::::::&apos;@@@@&apos;``` .+:::` * ::::::::::;@@@#. ,:::, * .::::::::+@#@` :::: * :::::::+@@&apos; :::: * `:::::&apos;@@: `:::. * ,::::@@: ` :::: * ;::::::@ .:::; * :;:::::;@` ` :::; * :::::::::@` @ ;:::: * :::::::::#` @` ,:::: * :::::::::@` +@ @ .::::` * .::::::&apos;@@` `@@&apos; @ ::::, * :::::::++@@@@@@@@@@. ::::; * ;:::::::+, `..` ::::: * ,::::::::&apos;, ::::: * :::::::::+, :::::` * :::::::::+@. ,::::.` `, * ::::::;;@+ .::;:: `; * :::::::@@ `:::;: `::`` * ::::::#@ ;:::: .::` * :::::;@ :::::` .;::` * :::::@ `:;::: `::::; * :::::# :::::. `,;::::: * :::::: ` ::::::,.,::::::::::. * ,::::::` .:: ::::::::::::::::;` * ;::::::::,````.,:::::, ::::::::::::::. * :::::::::::::::::: ` `::::::::::` * `::::::::::::, .:::. * `..` */ 小老鼠123456789101112131415/*** * http://www.flvcd.com/ * .--, .--, * ( ( \.---./ ) ) * &apos;.__/o o\__.&apos; * &#123;= ^ =&#125; * &gt; - &lt; * / \ * // \\ * //| . |\\ * &quot;&apos;\ /&apos;&quot;_.-~^`&apos;-. * \ _ /--&apos; ` * ___)( )(___ * (((__) (__))) 高山仰止,景行行止.虽不能至,心向往之。 */ 顶12345678910111213141516/*** * 頂頂頂頂頂頂頂頂頂 頂頂頂頂頂頂頂頂頂 * 頂頂頂頂頂頂頂 頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂頂頂頂頂頂頂頂頂頂 * 頂頂 頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂 頂頂頂 頂頂 * 頂頂 頂頂頂 * 頂頂 頂頂 頂頂 頂頂 * 頂頂頂頂 頂頂頂頂頂 頂頂頂頂頂 * 頂頂頂頂 頂頂頂頂 頂頂頂頂 */ 单身狗的凝视123456789101112131415/*** * ░░░░░░░░░░░░░░░░░░░░░░░░▄░░ * ░░░░░░░░░▐█░░░░░░░░░░░▄▀▒▌░ * ░░░░░░░░▐▀▒█░░░░░░░░▄▀▒▒▒▐ * ░░░░░░░▐▄▀▒▒▀▀▀▀▄▄▄▀▒▒▒▒▒▐ * ░░░░░▄▄▀▒░▒▒▒▒▒▒▒▒▒█▒▒▄█▒▐ * ░░░▄▀▒▒▒░░░▒▒▒░░░▒▒▒▀██▀▒▌ * ░░▐▒▒▒▄▄▒▒▒▒░░░▒▒▒▒▒▒▒▀▄▒▒ * ░░▌░░▌█▀▒▒▒▒▒▄▀█▄▒▒▒▒▒▒▒█▒▐ * ░▐░░░▒▒▒▒▒▒▒▒▌██▀▒▒░░░▒▒▒▀▄ * ░▌░▒▄██▄▒▒▒▒▒▒▒▒▒░░░░░░▒▒▒▒ * ▀▒▀▐▄█▄█▌▄░▀▒▒░░░░░░░░░░▒▒▒ * 单身狗就这样默默地看着你，一句话也不说。 */ 埃及法老1234567891011121314151617181920212223242526272829303132333435/*** * /88888888888888888888888888\ * |88888888888888888888888888/ * |~~____~~~~~~~~~&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;| * / \_________/&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;\ * / | \ \ * / | 88 88 \ \ * / | 88 88 \ \ * / / \ | * / | ________ \ | * \ | \______/ / | * /&quot;\ \ \____________ / | * | |__________\_ | | / / * /&quot;&quot;&quot;&quot;\ \_------&apos; &apos;-------/ -- * \____/,___________\ -------/ * ------* | \ * || | \ * || | ^ \ * || | | \ \ * || | | \ \ * || | | \ \ * \| / /&quot;&quot;&quot;\/ / * ------------- | | / * |\--_ \____/___/ * | |\-_ | * | | \_ | * | | \ | * | | \_ | * | | ----___ | * | | \----------| * / | | ----------&quot;&quot;\ * /&quot;\--&quot;--_| | | \ * |_______/ \______________/ ) * \___/ */ 耶123456789101112131415161718192021222324252627282930313233343536/*** * d*##$. * zP&quot;&quot;&quot;&quot;&quot;$e. $&quot; $o * 4$ &apos;$ $&quot; $ * &apos;$ &apos;$ J$ $F * &apos;b $k $&gt; $ * $k $r J$ d$ * &apos;$ $ $&quot; $~ * &apos;$ &quot;$ &apos;$E $ * $ $L $&quot; $F ... * $. 4B $ $$$*&quot;&quot;&quot;*b * &apos;$ $. $$ $$ $F * &quot;$ R$ $F $&quot; $ * $k ?$ u* dF .$ * ^$. $$&quot; z$ u$$$$e * #$b $E.dW@e$&quot; ?$ * #$ .o$$# d$$$$c ?F * $ .d$$#&quot; . zo$&gt; #$r .uF * $L .u$*&quot; $&amp;$$$k .$$d$$F * $$&quot; &quot;&quot;^&quot;$$$P&quot;$P9$ * JP .o$$$$u:$P $$ * $ ..ue$&quot; &quot;&quot; $&quot; * d$ $F $ * $$ ....udE 4B * #$ &quot;&quot;&quot;&quot;` $r @$ * ^$L &apos;$ $F * RN 4N $ * *$b d$ * $$k $F * $$b $F * $&quot;&quot; $F * &apos;$ $ * $L $ * &apos;$ $ * $ $ */ 台式电脑1234567891011121314151617181920/*** * ,----------------, ,---------, * ,-----------------------, ,&quot; ,&quot;| * ,&quot; ,&quot;| ,&quot; ,&quot; | * +-----------------------+ | ,&quot; ,&quot; | * | .-----------------. | | +---------+ | * | | | | | | -==----&apos;| | * | | I LOVE DOS! | | | | | | * | | Bad command or | | |/----|`---= | | * | | C:\&gt;_ | | | ,/|==== ooo | ; * | | | | | // |(((( [33]| ,&quot; * | `-----------------&apos; |,&quot; .;&apos;| |(((( | ,&quot; * +-----------------------+ ;; | | |,&quot; * /_)______________(_/ //&apos; | +---------+ * ___________________________/___ `, * / oooooooooooooooo .o. oooo /, \,&quot;----------- * / ==ooooooooooooooo==.o. ooo= // ,`\--&#123;)B ,&quot; * /_==__==========__==_ooo__ooo=_/&apos; /___________,&quot; * */ 书本123456789101112/*** * .-~~~~~~~~~-._ _.-~~~~~~~~~-. * __.&apos; ~. .~ `.__ * .&apos;// \./ \\`. * .&apos;// | \\`. * .&apos;// .-~&quot;&quot;&quot;&quot;&quot;&quot;&quot;~~~~-._ | _,-~~~~&quot;&quot;&quot;&quot;&quot;&quot;&quot;~-. \\`. * .&apos;//.-&quot; `-. | .-&apos; &quot;-.\\`. * .&apos;//______.============-.. \ | / ..-============.______\\`. * .&apos;______________________________\|/______________________________`. * */ 人生12345678910111213141516171819202122/** * 出生 * || * || * \ / * \/ * 青年 * （年龄 = rand(20,25))） 《============== * || || * || || * || 祝福所有开发工作者 || * || 永远年轻 || * || || * \ / || * \/ || *（ 20 &lt;= 年龄 &lt;= 25） =============== * || * || * \ / * \/ * 等死状态 */ 比克大魔王12345678910111213141516171819202122232425/* _.---..._ ./^ ^-._ ./^C===. ^\. /\ .|&apos; \\ _ ^|.^.| ___.--&apos;_ ( ) . ./ /|| /.---^T\ , | / /||| C&apos; ._`| ._ / __,-/ / /-,|| \ \/ ; /O / _ |) )|, i \./^O\./_,-^/^ ,;-^,&apos; \ |`--/ ..-^^ |_-^ `| \^- /|: i. .-- / &apos;|. i ==&apos; /&apos; |\._ _./`._ // |. ^-ooo.._ _.oo../&apos; | ^-.__./X/ . `| |#######b d#### |&apos; ^^^^ / | _\####### #####b ^^^^^^^^--. ...--^--^^^^^^^_.d###### ######b._ Y _.d######### ##########b._ | _.d############# &quot;Piccolo&quot; no. 2 (from Dragonball Z) --- Steven J. Simmons */ Fuck you123456789101112131415161718192021/* * .::::. * .::::::::. * ::::::::::: FUCK YOU * ..:::::::::::&apos; * &apos;::::::::::::&apos; * .:::::::::: * &apos;::::::::::::::.. * ..::::::::::::. * ``:::::::::::::::: * ::::``:::::::::&apos; .:::. * ::::&apos; &apos;:::::&apos; .::::::::. * .::::&apos; :::: .:::::::&apos;::::. * .:::&apos; ::::: .:::::::::&apos; &apos;:::::. * .::&apos; :::::.:::::::::&apos; &apos;:::::. * .::&apos; ::::::::::::::&apos; ``::::. * ...::: ::::::::::::&apos; ``::. * ```` &apos;:. &apos;:::::::::&apos; ::::.. * &apos;.:::::&apos; &apos;:&apos;````.. */ 围棋12345678910111213141516171819202122232425262728293031323334 // _______________________________________ // / ___________________________________ \// _--&quot;&quot;&quot;&quot;--_ / /_/_/_/_/_|_|_|_|_|_|_|_|_|_\_\_\_\_\ \// / \ / /_/_/_/_J__L_L_L_|_|_|_J_J_J__L_\_\_\_\ \// /\ /\ / /_/_/_J__L_J__L_L_|_|_|_J_J__L_J__L_\_\_\ \// L &quot;&quot;-____-&quot;&quot; J / /_/_J__L_J__L_J_J__L_|_J__L_L_J__L_J__L_\_\ \// \ / / /_/__L_/__L_J__L_J__L_|_J__L_J__L_J__\_J__\_\ \// \_ _/ / /_J__/_J__/__L_J__|__L_|_J__|__L_J__\__L_\__L_\ \// _--&quot;&quot;&quot;&quot;&quot;--_&quot; / / F / F J J | F J | F J | F F J \ J \ \// / \ / /--/-J--/--L--|--L-J--J--|--L--L-J--|--J--\--L-\--\ \///\ /\ / /__/__L_J__J___L_J__J__|__|__|__L__L_J___L__L_J__\__\ \//L &quot;&quot;-_____-&quot;&quot; J / / / / F F J J | | | | | F F J J \ \ \ \//\ / / /--/--/--/--J---L--|--|--|--o--|--|--|--J---L--\--\--\--\ \// \_ _/ / /__/__J__J___L__J___L__L__L__|__J__J__J___L__J___L__L__\__\ \// &quot;--___--&quot; / / / F F J F J J F | J F F J F J J \ \ \// / /--/---/--J---L--J---L--|--J---|---L--|--J---L--J---L--\---\--\ \// / /__J___/___L__/___L__J___L__J___|___L__J___L__J___\__J___\___L__\ \// / / F J / J J | J J | F F | F F \ F J \ \// / /---/---L--J---L---L---L--|---|---|---|---|--J---J---J---L--J---\---\ \// / /___/___/___L__J___J___J___|___|___|___|___|___L___L___L__J___\___\___\ \// / / / / / F F F F F | J J J J J \ \ \ \ \// / /___/___J___J___J___J___J____L___L___|___J___J____L___L___L___L___L___\___\ \// / / / F F F | | J F | J F | | J J J \ \ \// / /___J____/___/___J____L___L___|___J____|____L___|___J___J____L___\___\____L___\ \// / / F / J F J J | J | F | F F J F \ J \ \// / /____/___J____L___/____L___|____L___|____|____|___J____|___J____\___J____L___\____\ \// / / / F / J J F J F | J F J F F \ J \ \ \// / /____/____/___J____L____|____L___J____L____|____J____L___J____|____J____L___\____\____\ \// / \///_______________________________________________________________________________________________\//| |//| hs |//|_______________________________________________________________________________________________| 居中的佛祖1234567891011121314151617181920212223/* _ooOoo_ o8888888o 88&quot; . &quot;88 (| -_- |) O\ = /O ____/`---&apos;\____ .&apos; \\| |// `. / \\||| : |||// \ / _||||| -:- |||||- \ | | \\\ - /// | | | \_| &apos;&apos;\---/&apos;&apos; | | \ .-\__ `-` ___/-. / ___`. .&apos; /--.--\ `. . __ .&quot;&quot; &apos;&lt; `.___\_&lt;|&gt;_/___.&apos; &gt;&apos;&quot;&quot;. | | : `- \`.;`\ _ /`;.`/ - ` : | | \ \ `-. \_ __\ /__ _/ .-` / /======`-.____`-.___\_____/___.-`____.-&apos;====== `=---=&apos;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 佛祖保佑 永无BUG*/ windows图标123456789101112131415161718/* __ ,-~¨^ ^¨-, _, / / ;^-._...,¨/ / / / / / / / / / / / / /,.-:&apos;&apos;-,_ / / / _,.-:--._ ^ ^:-._ __../ /^ / /¨:.._¨__.; / / / ^ / / / / / / / / / /_,.--:^-._/ / /^ ^¨¨-.___.:^ (R) - G33K */ 七龙珠比克1234567891011121314151617181920212223242526/* /^_.-^ _ --^=_ ./&apos;-^__ _&gt;=\^^==^-. |&apos;/^^_/ /^ \ \.^\\\/\ ,|/| &apos; /&apos; _____\ `\|.^.| |&apos;/ /_--^^ . ^^-./ /|| |/,--^ , | / /||&apos; ._|/ \ / __,-/ / /-,|| \ &apos;/ ; /O / _ |) )|, i \./^O\./_,-^/^ ,;-^,&apos; \ |`--/ ..-^^ |_-^ `| \^-_,/^Y\ | ^^\ _i. \&quot;.--V_/ /| \. ^\._____...--.&gt;^^^^^^-------...._ / i ^--^^ /&apos;|&apos; |\. |./&apos; | ;___...----/^^^^---|. `._\ /^ /&apos; |&apos;_/&apos; \ `| |&apos; ,/&apos; |&apos; \ _|^-.__./&apos;__.^^\ .| ,| _.-^ `\ ,|`_./^^-----^^._ ` ./ / /^ _.-^^/ |&apos; ^ /-^ ./^ /\ `\_ __.-&lt; _,/ ./&apos; |&apos; `\. `i ^^--/._____...--^ . ./ |. `| | / / `| &quot;Piccolo&quot; (from Dragonball Z) --- Steven J. Simmons */ 七龙珠悟空123456789101112131415161718192021222324252627282930313233/* _ \&quot;-._ _.--&quot;~~&quot;--._ \ &quot; ^. ___ / \.-~_.-~ .-----&apos; /\/&quot;\ /~-._ / / __ _/\-.__\L_.-/\ &quot;-. /.-&quot; \ ( ` \_o&gt;&quot;&lt;o_/ \ .--._\ /&apos; \ \: &quot; :/_/ &quot;` / /\ &quot;\ ~ /~&quot; \ I \/]&quot;-._ _.-&quot;[ ___ \|___/ ./ l \___ ___ .--v~ &quot;v` ( `-.__ __.-&apos; ) ~v&quot; ~v--. .-&#123; | : \_ &quot;~&quot; _/ : | &#125;-. / \ | ~-.,___,.-~ | / \ ] \ | | / [ /\ \| : : |/ /\ / ^._ _K.___,^ ^.___,K_ _.^ \ / / &quot;~/ &quot;\ /&quot; \~&quot; \ \ / / / \ _ : _ / \ \ \ .^--./ / Y___________l___________Y \ \.--^. [ \ / | [/ ] | \ / ] | &quot;v&quot; l________[____/]________j -Row &#125;r&quot; / &#125;------t / \ /`-. / | | Y Y / &quot;-._/ &#125;-----v&apos; | : | 7-. / | |_| | l | / . &quot;-._/ l .[_] : \ : r[]/_. / \_____] &quot;--. &quot;-.____/ &quot;Dragonball Z&quot; ---Row */ 超级赛亚人123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/* MMMMM MMMMMM MMMMMMM MMMMMMMM . MMMMMMMMM HMMMMMMMMMM MMMMMMMMMMMM M MMMMMMMMMMMMM M MMMMMMMMMMMMM M MMMMMMMMMMMMM: oMMMMMMMMMMMMMM .MMMMMMMMMMMMMMo MMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMM. oMMMMMMMMMMMMMMM.M MMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM oMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM: H MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM . MMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM M MMMMMM .MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM M MMMMMMMMMM MM. MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM M MMMMMMMMMMMM MM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM .MMMMMMMMMMMMMM MM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM .MMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMM.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM HMMMMMMMMMMMMMMMMMMMMM.MMMMMMMMM.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMM MMM.oMMMMMMM..MMMMMMMMM:MMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMM MM..MMMMMMM...MMMMMMM. MMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMM ..MMMMMM...MMMMMM ..MMMMMMMMMMMMMMMMMMM MMMMMMM:M.MMM.M.. MMMMM M..MMMMM...MMMMMMMMMMMMMMMMMM MMM MMMM. .M..MM.M...MMMMMM..MMMMM.. MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM . MMMM..M....M.....:MMM .MMMMMM..MMMMMMM...MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMM.M.. ...M......MM.MMMMM.......MHM.M .MMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMM..MM. . MMM.....MMMMMM.M.....M ..MM..M MMMMMMMMMMMMMMMMMMM .MMMMMHMM. ..MMMM. MMM............o..... . .MMMMMMMMMMMMMMM MMM. M... .........................M..:.MMMMMMMMMMMM oMMM............ .................M.M.MMMMMMMMM .....MM........................ . MMMMMM M.....M.....................o.MM.MMMMMMMM. M........................M.. ...MMMMMMMMMMMMMo :....MMM..............MMM..oMMMMMMM M...MMM.............MMMMMMM .............:MMMMMMMM M..... MMM.....M M M............. ................M ooM.................MM MoMMMMMoooM MMoooM......................MoooooooH..oMM MHooooMoM.....................MMooooooM........M oooooooMoooM......... o........MoooooooM............ Mooooooooooo.......M.........Moooooooo:..............M MooMoooooooooM...M........:Mooooooooooo:..............M M..oooooooooooo .........Mooooooooooooooo..............M M...Mooo:oooooooo.M....ooooooooooooooooooo..M...........M ...oooooMoooooooM..Mooooooooooooo:oooooooM.M...........M. M...ooooooMoo:ooooMoooooooooooooHoooooooooH:M. ...........: M..MoooooooMoooooooooooooooooo:ooooooMooooMoM..............M M..ooooooooooMooooooooooooooHoooooooMooHooooM...............M ...ooooooooooooooooooo:MooooooooooooooMoMoooM................ M...oooooooooooooooooooooooooooooooooooooMooMM................M ...MooooooooooooooooooooooooooooooooooooooooMo ................ ...MooooooooooooooooooooooooooooooooooooooooM M................M M...ooooooooooooooooooooooooooooooooooooooooM ................M ...MoooooooooooooooooooooooooooooooooooooooMM .:............... .....MooooooooooooooooooooooooooooooooooooMoo .............M M...... ooooooooooooooooooooooooooooooooooooM M..............M M........MooooMMM MM MM MMMMMMMMMooooooooM M...............M .........HM M: MM :MMMMMM M M............... M..........M M MoM M M................M M.........:M MoH M M M MooooHoooMM. M M...............M M..........Moooo MMooM oooooMooooooooM M..............H M.........MooooM Mooo : ooooooMooooMoooM M........ . .o.M H.. .....ooooo oooo M MooooooooooooooM M... MMMMMMMMMMM MMMMMMMMMMooooM M oooo . ooooooMooooooooM .MMMMMMMMMMMMMMM MMMMMMMMMMooooH : ooooH oooooooooooooooo MMMMMMMMMMMMMMM MMMMMMMMMMoooo ooooM Moooooooooooooooo .MMMMMMMMMMMMMMM MMMMMMMMMMoooo ooooM MooooooooooooooooM MMMMMMMMMMMMMMM MMMMMMMMMMoooM ooooM ooooooooooooooooo MMMMMMMMMMM:M MMMMMMMMMMoooM MooooM oooooooooooMoooooo MH........... . ......Mooo. MooooM oooooooooooooooooo M............M M.M......oooo MooooM Moooooooooooooooooo: .........M..... M.M.....Moooo MooooM ooooooooooooooooooM .M............ .......MooooH MooooM oooooooooMoooooooooo M..o...M..o....M .o....HMooooM MooooH MooooooooMooooooooooM .:M...M.......M M..M.....MoooM :oooo: .MooooooooHooMoooooooooM M M... ..oM.M M...M.:.Mooo. MMMMooooo oooooooooooMoooooooooooooM ....M. M M:M..o.Moooooooooooooo MooooooooooooooMooooooooooooM .Mo MooooooooooooooMooooooooooooMoMoooooooooooooo Mooooooooooooooo:ooooooooooooooooooooooooooooo ooooooooooooooooMooooooooooMoooooooooooooooooo ooooooooooooooooMoooooooooooMooooooooooooooooHo ooMooooooooooooooMoooooooooooooooooooooooooooMoM MooMoooooooooooooo.ooooooooooooooooooooooooooo:oM MoooooooooooooooooooooooooooooooooooooooooooooooM MoooMooooooooooooooMooooooooooooooooooooooooooooo. MoooMooooooooooooooMoooooooooooooooooooooooooMooooM MooooooooooooooooooMoooooooooooooooooooooooooMoooooM MooooMoooooooooooooMoooooooooooooooooooooooooMoHooooM ooooooMooooooooooooooooooooooooooooooooooooooooMoMoooM MooooooooooooooooooooMooooooooooooooooooooooooooMoooooH: MoooooooMooooooooooooMoooooooooooooooooooooooooooooHoooM MooooooooMoooooooooooMoooooooooooooooooooooooooMoooMooooM Moooooooooooooooooooooooooooooooooooooooooooooo.oooMooooo MoooooooooooooooooooooooooooooooooooooooooooooMoooooooooM MooooooooooooooooooooMoooooooooooooooooooooooooooooooooM MooooooooooooooooooooMHooooooooooooooooooooMoooo:ooooo MMooooooooooooooooooMoMHoooooooooooooooooooooooMooooo MMoooooooooooooooMMooo MMooooooooooooooooooooooooooM MMMoooooooooooooMooooo oooooooooooooooooooooMooooo MooMMoooooooooMoooMMoM ooooHooooooooooooooooMooooM MooooMooooooMooooMoooM MoooooMoooooooooooooMooooo ooooooMMooooooooMooooM MoooooooooMooooooooooooooM HooooooMoooooooMooooM HoooooooHooMooooooooooooo oooMoooooooooHoooM MoooooooooMoooooooooM HooooooooooooHM MooooooooMMoooooooM MMMMMMMMMMMMMM Moooooo:MooooHMM MMMMMMM: ... MMMMMMMMMMMMMM M............M MMMMMMMMM .... M.MM.......... M.............M M ..............MM M.............. MMMMM............MMMM ..MMMMMMMM ....M MMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMM...M .MMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMM :MMMMMMMMMMMMMMMMMMH MMMMMMMMMMMMMMMMMMM By EBEN Jérôme MMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMM HMMMMMM */ 皮卡丘123456789101112131415161718192021222324252627282930313233343536373839404142/*quu..__ $$$b `---.__ &quot;$$b `--. ___.---uuudP `$$b `.__.------.__ __.---&apos; $$$$&quot; . &quot;$b -&apos; `-.-&apos; $$$&quot; .&apos;| &quot;. d$&quot; _.&apos; | `. / ...&quot; .&apos; | `./ ..::-&apos; _.&apos; | / .:::-&apos; .-&apos; .&apos; : ::&apos;&apos;\ _.&apos; | .&apos; .-. .-. `. .&apos; | : /&apos;$$| .@&quot;$\ `. .&apos; _.-&apos; .&apos;|$u$$| |$$,$$| | &lt; _.-&apos; | `:$$:&apos; :$$$$$: `. `. .-&apos; : `&quot;--&apos; | `-. \ :##. == .###. `. `. `\ |##: :###: | &gt; &gt; |#&apos; `..&apos;`..&apos; `###&apos; x: / / \ xXX| / ./ \ xXXX&apos;| / ./ /`-. `. / / : `- ..........., | / .&apos; | ``:::::::&apos; . |&lt; `. | ``` | x| \ `.:``. | .&apos; /&apos; xXX| `:`M`M&apos;:. | | ; /:&apos; xXXX&apos;| -&apos;MMMMM:&apos; `. .&apos; : /:&apos; |-&apos;MMMM.-&apos; | | .&apos; /&apos; .&apos;MMM.-&apos; `&apos;`&apos; : ,&apos; |MMM&lt; | `&apos; |tbap\ \ :MM.-&apos; \ | .&apos;&apos; \. `. / / .:::::::.. : / | .:::::::::::`. / | .:::------------\ / / .&apos;&apos; &gt;::&apos; / `&apos;,: : .&apos; `:.:&apos; */ ##12 ##12 ##12 ##12 ##12 ##12 ##12 ##12 ##12 ##12 ##12 ##12]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkdownPad发生HTML渲染组件出错]]></title>
    <url>%2F2019%2F05%2F18%2FMarkdownPad%E5%8F%91%E7%94%9FHTML%E6%B8%B2%E6%9F%93%E7%BB%84%E4%BB%B6%E5%87%BA%E9%94%99.html</url>
    <content type="text"><![CDATA[在安装破解MarkdownPad之后，新建一个文档准备练习下MarkdownPad的使用，结果，很不幸地出现了下面的错误：根据它的提示跳转到官网上查看了一番，表示很懵逼….最终还是借助强大的百度搜到其他小伙伴也遇到过这个问题，现将解决方案总结如下。1.下载这个东东： Awesomium 1.6.6 SDK2.下载完成后双击exe安装文件开始安装，点击Next：勾选“I accept the terms in the License Agreement”，点击Next勾选“Yes,remove the older version.”，点击Next安装路径可以使用默认的安装路径，也可以更改安装路径，然后选择Typical标准套餐点击Install开始安装安装完成Finsh3.然后重启MarkdownPad，问题解决。]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkdownPad正版破解与汉化]]></title>
    <url>%2F2019%2F05%2F18%2FMarkdownPad%E6%AD%A3%E7%89%88%E7%A0%B4%E8%A7%A3%E4%B8%8E%E6%B1%89%E5%8C%96.html</url>
    <content type="text"><![CDATA[下载先去官网：http://markdownpad.com/ 下载MarkdownPad，如下图： 安装安装过程很简单，一路NexT下去，可使用默认的安装目录，也可以自定义安装目录，这里不做截图展示。 汉化安装完成后，启动MarkdownPad，在工具栏上面点击Tools-Options，如下图：在打开的页面下方有个languages的选项，点击English的选项卡弹出选择窗，选中文，点击save and close按钮后就可以看到中文效果，并弹窗“需要重新启动 MarkdownPad”的提示。如下图： 破解注册码1GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 邮箱地址Soar360@live.com 使用方式点击帮助-专业版激活在弹出的小窗口输入邮箱Soar360@live.com 授权密钥粘贴上面的注册码.点击确定就激活。现在是2019年5月18日，目前依然有效。]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F17%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
